"use strict";

var _react = _interopRequireDefault(require("react"));

var _ReactPolling = _interopRequireDefault(require("./ReactPolling"));

var _enzyme = require("enzyme");

var mockData = _interopRequireWildcard(require("../__mock_data__/data"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

describe('<ReactPolling />', function () {
  var onSuccess = jest.fn(),
      onFailure = jest.fn,
      url = 'http://localhost/session/status';
  describe('success test cases', function () {
    beforeAll(function () {
      global.fetch = jest.fn().mockImplementation(function () {
        return Promise.resolve({
          json: function json() {
            return new Promise(function (resolve) {
              resolve(mockData.continuePollingResponse);
            });
          },
          ok: true
        });
      });
    });
    test('should render properly with render props', function () {
      var wrapper = (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
        url: url,
        onSuccess: onSuccess,
        onFailure: onFailure,
        render: function render(_ref) {
          var isPolling = _ref.isPolling;
          return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
            id: "isPolling"
          }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
            id: "isNotPolling"
          }, " I am not polling "));
        }
      }));
      expect(wrapper.find('p').length).toBe(1);
      expect(wrapper.find('#isPolling').length).toBe(1);
    });
    test('should render properly with children props', function () {
      var wrapper = (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
        url: url,
        onSuccess: onSuccess,
        onFailure: onFailure
      }, function (_ref2) {
        var isPolling = _ref2.isPolling;
        return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
          id: "isPolling"
        }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
          id: "isNotPolling"
        }, " I am not polling "));
      }));
      expect(wrapper.find('p').length).toBe(1);
      expect(wrapper.find('#isPolling').length).toBe(1);
    });
    describe('initial tests for checking initial variables before we start polling', function () {
      var wrapper, mockedComponentDidMount;
      beforeEach(function () {
        mockedComponentDidMount = jest.spyOn(_ReactPolling["default"].prototype, 'componentDidMount');
        mockedComponentDidMount.mockImplementation();
        wrapper = (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
          url: url,
          onSuccess: onSuccess,
          onFailure: onFailure,
          render: function render(_ref3) {
            var isPolling = _ref3.isPolling;
            return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
              id: "isPolling"
            }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
              id: "isNotPolling"
            }, " I am not polling "));
          }
        }));
      });
      afterEach(function () {
        wrapper = null;
        mockedComponentDidMount.mockRestore();
      });
      test('should have right initial state', function () {
        var expectedState = {
          isPolling: false
        };
        expect(wrapper.state()).toEqual(expectedState);
      });
      test('should have right initial config', function () {
        var expectedConfig = {
          url: url,
          interval: 3000,
          shouldRetry: false,
          retryCount: 0,
          onSuccess: onSuccess,
          onFailure: onFailure,
          api: {
            method: 'GET'
          }
        };
        expect(wrapper.instance().config).toMatchObject(expectedConfig);
      });
      test('should have all the function defined', function () {
        expect(wrapper.instance().initConfig).toBeDefined();
        expect(wrapper.instance().config).toBeDefined();
        expect(wrapper.instance().startPolling).toBeDefined();
        expect(wrapper.instance().stopPolling).toBeDefined();
        expect(wrapper.instance().runPolling).toBeDefined();
      });
    });
    describe('tests with polling started', function () {
      test('startPolling function to have been called', function () {
        var mockedStartPolling = jest.spyOn(_ReactPolling["default"].prototype, 'startPolling');
        mockedStartPolling.mockImplementation();
        (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
          url: url,
          onSuccess: onSuccess,
          onFailure: onFailure,
          render: function render(_ref4) {
            var isPolling = _ref4.isPolling;
            return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
              id: "isPolling"
            }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
              id: "isNotPolling"
            }, " I am not polling "));
          }
        }));
        expect(mockedStartPolling).toHaveBeenCalledTimes(1);
        mockedStartPolling.mockRestore();
      });
      test('startPolling function to throw an error when no url provided', function () {
        expect(function () {
          (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
            url: null,
            onSuccess: onSuccess,
            onFailure: onFailure,
            render: function render(_ref5) {
              var isPolling = _ref5.isPolling;
              return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
                id: "isPolling"
              }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
                id: "isNotPolling"
              }, " I am not polling "));
            }
          }));
        }).toThrowError();
      });
      test('startPolling should set isPolling state to true, _ismounted to true and call runPolling function', function () {
        var mockedRunPolling = jest.spyOn(_ReactPolling["default"].prototype, 'runPolling');
        mockedRunPolling.mockImplementation();
        var wrapper = (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
          url: url,
          onSuccess: onSuccess,
          onFailure: onFailure,
          render: function render(_ref6) {
            var isPolling = _ref6.isPolling;
            return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
              id: "isPolling"
            }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
              id: "isNotPolling"
            }, " I am not polling "));
          }
        }));
        wrapper.update();
        expect(wrapper.state().isPolling).toBeTruthy();
        expect(wrapper.instance()._ismounted).toBeTruthy();
        expect(mockedRunPolling).toHaveBeenCalledTimes(1);
        mockedRunPolling.mockRestore();
        mockedRunPolling.mockClear();
      });
      test('stopPolling should set isPolling to false, _ismounted to false and poll to null', function () {
        var wrapper = (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
          url: url,
          onSuccess: onSuccess,
          onFailure: onFailure,
          render: function render(_ref7) {
            var isPolling = _ref7.isPolling;
            return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
              id: "isPolling"
            }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
              id: "isNotPolling"
            }, " I am not polling "));
          }
        }));
        wrapper.instance().stopPolling();
        wrapper.update();
        expect(wrapper.state().isPolling).toBeFalsy();
        expect(wrapper.instance()._ismounted).toBeTruthy();
        expect(wrapper.instance().poll).toBeNull();
      });
    });
    describe('timer events', function () {
      var mockedRunPolling, mockedOnSuccess;
      beforeEach(function () {
        jest.useFakeTimers();
        mockedRunPolling = jest.spyOn(_ReactPolling["default"].prototype, 'runPolling');
        mockedOnSuccess = jest.fn(function () {
          return true;
        });
      });
      afterEach(function () {
        jest.clearAllTimers();
        mockedRunPolling.mockClear();
        mockedOnSuccess.mockClear();
      });
      test('run Polling should call setTimeout and make api calls at every interval', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
                  url: url,
                  onSuccess: mockedOnSuccess,
                  onFailure: onFailure,
                  render: function render(_ref9) {
                    var isPolling = _ref9.isPolling;
                    return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
                      id: "isPolling"
                    }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
                      id: "isNotPolling"
                    }, " I am not polling "));
                  }
                }));
                expect(mockedRunPolling).toHaveBeenCalledTimes(1);
                expect(setTimeout).toHaveBeenCalledTimes(1);
                jest.runAllTimers();
                expect(fetch).toHaveBeenCalled();
                _context.next = 7;
                return Promise.resolve();

              case 7:
                _context.next = 9;
                return Promise.resolve();

              case 9:
                _context.next = 11;
                return Promise.resolve();

              case 11:
                _context.next = 13;
                return Promise.resolve();

              case 13:
                _context.next = 15;
                return Promise.resolve();

              case 15:
                expect(mockedOnSuccess).toHaveBeenCalled();
                _context.next = 18;
                return Promise.resolve();

              case 18:
                expect(mockedRunPolling).toHaveBeenCalledTimes(2);
                expect(setTimeout).toHaveBeenCalledTimes(2);
                jest.runAllTimers();
                expect(fetch).toHaveBeenCalled();
                _context.next = 24;
                return Promise.resolve();

              case 24:
                _context.next = 26;
                return Promise.resolve();

              case 26:
                _context.next = 28;
                return Promise.resolve();

              case 28:
                _context.next = 30;
                return Promise.resolve();

              case 30:
                expect(mockedOnSuccess).toHaveBeenCalled();

              case 31:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })));
      test('onSuccess and run Polling should get called when response from api is empty', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                global.fetch = jest.fn().mockImplementation(function () {
                  return Promise.resolve({
                    json: function json() {
                      return new Promise(function (resolve, reject) {
                        reject(mockData.continuePollingResponse);
                      });
                    },
                    ok: true
                  });
                });
                (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
                  url: url,
                  onSuccess: mockedOnSuccess,
                  onFailure: onFailure,
                  render: function render(_ref11) {
                    var isPolling = _ref11.isPolling;
                    return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
                      id: "isPolling"
                    }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
                      id: "isNotPolling"
                    }, " I am not polling "));
                  }
                }));
                expect(mockedRunPolling).toHaveBeenCalledTimes(1);
                expect(setTimeout).toHaveBeenCalledTimes(1);
                jest.runAllTimers();
                expect(fetch).toHaveBeenCalled();
                _context2.next = 8;
                return Promise.resolve();

              case 8:
                _context2.next = 10;
                return Promise.resolve();

              case 10:
                _context2.next = 12;
                return Promise.resolve();

              case 12:
                _context2.next = 14;
                return Promise.resolve();

              case 14:
                _context2.next = 16;
                return Promise.resolve();

              case 16:
                expect(mockedOnSuccess).toHaveBeenCalled();
                _context2.next = 19;
                return Promise.resolve();

              case 19:
                expect(mockedRunPolling).toHaveBeenCalledTimes(2);
                expect(setTimeout).toHaveBeenCalledTimes(2);
                jest.runAllTimers();
                expect(fetch).toHaveBeenCalled();
                _context2.next = 25;
                return Promise.resolve();

              case 25:
                _context2.next = 27;
                return Promise.resolve();

              case 27:
                _context2.next = 29;
                return Promise.resolve();

              case 29:
                _context2.next = 31;
                return Promise.resolve();

              case 31:
                expect(mockedOnSuccess).toHaveBeenCalled();

              case 32:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })));
      test('onSuccess and run Polling should get called using a custom promise', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var data, fetchData;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                data = [{
                  id: 1
                }, {
                  id: 2
                }];

                fetchData = function fetchData() {
                  return new Promise(function (resolve) {
                    resolve({
                      data: data
                    });
                  });
                };

                (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
                  url: url,
                  onSuccess: mockedOnSuccess,
                  onFailure: onFailure,
                  promise: fetchData,
                  render: function render(_ref13) {
                    var isPolling = _ref13.isPolling;
                    return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
                      id: "isPolling"
                    }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
                      id: "isNotPolling"
                    }, " I am not polling "));
                  }
                }));
                expect(mockedRunPolling).toHaveBeenCalledTimes(1);
                expect(setTimeout).toHaveBeenCalledTimes(1);
                jest.runAllTimers();
                expect(fetch).toHaveBeenCalled();
                _context3.next = 9;
                return Promise.resolve();

              case 9:
                _context3.next = 11;
                return Promise.resolve();

              case 11:
                _context3.next = 13;
                return Promise.resolve();

              case 13:
                _context3.next = 15;
                return Promise.resolve();

              case 15:
                _context3.next = 17;
                return Promise.resolve();

              case 17:
                expect(mockedOnSuccess).toHaveBeenCalled();
                expect(mockedOnSuccess).toHaveBeenCalledWith({
                  data: data
                });
                _context3.next = 21;
                return Promise.resolve();

              case 21:
                expect(mockedRunPolling).toHaveBeenCalledTimes(2);
                expect(setTimeout).toHaveBeenCalledTimes(2);
                jest.runAllTimers();
                expect(fetch).toHaveBeenCalled();
                _context3.next = 27;
                return Promise.resolve();

              case 27:
                _context3.next = 29;
                return Promise.resolve();

              case 29:
                _context3.next = 31;
                return Promise.resolve();

              case 31:
                _context3.next = 33;
                return Promise.resolve();

              case 33:
                expect(mockedOnSuccess).toHaveBeenCalled();

              case 34:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      })));
      test('run Polling should call setTimeout and make api calls at every interval with backOffFactor', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
                  url: url,
                  onSuccess: mockedOnSuccess,
                  onFailure: onFailure,
                  backOffFactor: 2,
                  render: function render(_ref15) {
                    var isPolling = _ref15.isPolling;
                    return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
                      id: "isPolling"
                    }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
                      id: "isNotPolling"
                    }, " I am not polling "));
                  }
                }));
                expect(mockedRunPolling).toHaveBeenCalledTimes(1);
                expect(setTimeout).toHaveBeenCalledTimes(1);
                expect(setTimeout).toHaveBeenCalledWith(expect.any(Function), 3000);
                jest.runAllTimers();
                expect(fetch).toHaveBeenCalled();
                _context4.next = 8;
                return Promise.resolve();

              case 8:
                _context4.next = 10;
                return Promise.resolve();

              case 10:
                _context4.next = 12;
                return Promise.resolve();

              case 12:
                _context4.next = 14;
                return Promise.resolve();

              case 14:
                _context4.next = 16;
                return Promise.resolve();

              case 16:
                expect(mockedOnSuccess).toHaveBeenCalled();
                _context4.next = 19;
                return Promise.resolve();

              case 19:
                expect(mockedRunPolling).toHaveBeenCalledTimes(2);
                expect(setTimeout).toHaveBeenCalledTimes(2);
                expect(setTimeout).toHaveBeenCalledWith(expect.any(Function), 6000);
                jest.runAllTimers();
                expect(fetch).toHaveBeenCalled();
                _context4.next = 26;
                return Promise.resolve();

              case 26:
                _context4.next = 28;
                return Promise.resolve();

              case 28:
                _context4.next = 30;
                return Promise.resolve();

              case 30:
                _context4.next = 32;
                return Promise.resolve();

              case 32:
                expect(mockedOnSuccess).toHaveBeenCalled();

              case 33:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      })));
    });
  });
  describe('error test cases', function () {
    beforeAll(function () {
      global.fetch = jest.fn().mockImplementation(function () {
        return new Promise(function (resolve, reject) {
          reject(true);
        });
      });
    });
    beforeEach(function () {
      jest.useFakeTimers();
    });
    afterEach(function () {
      jest.clearAllTimers();
    });
    test('onFailure should retry equal to config.retryTimes', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
      var mockedRunPolling, mockedStopPolling, retryCount, wrapper, i, _i, _i2;

      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              mockedRunPolling = jest.spyOn(_ReactPolling["default"].prototype, 'runPolling');
              mockedStopPolling = jest.spyOn(_ReactPolling["default"].prototype, 'stopPolling');
              retryCount = 4;
              wrapper = (0, _enzyme.shallow)( /*#__PURE__*/_react["default"].createElement(_ReactPolling["default"], {
                url: url,
                onSuccess: onSuccess,
                onFailure: onFailure,
                retryCount: retryCount,
                render: function render(_ref17) {
                  var isPolling = _ref17.isPolling;
                  return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement("p", null, "Polling Component"), isPolling ? /*#__PURE__*/_react["default"].createElement("div", {
                    id: "isPolling"
                  }, " I am polling") : /*#__PURE__*/_react["default"].createElement("div", {
                    id: "isNotPolling"
                  }, " I am not polling "));
                }
              }));
              expect(mockedRunPolling).toHaveBeenCalledTimes(1);
              expect(setTimeout).toHaveBeenCalledTimes(1);
              i = 0;

            case 7:
              if (!(i < retryCount)) {
                _context5.next = 23;
                break;
              }

              jest.runAllTimers();
              expect(fetch).toHaveBeenCalledTimes(i + 1);
              _i = 0;

            case 11:
              if (!(_i < retryCount + 1)) {
                _context5.next = 17;
                break;
              }

              _context5.next = 14;
              return Promise.resolve(true);

            case 14:
              _i++;
              _context5.next = 11;
              break;

            case 17:
              expect(mockedRunPolling).toHaveBeenCalledTimes(i + 2);
              expect(mockedStopPolling).toHaveBeenCalledTimes(0);
              expect(wrapper.state().isPolling).toBeTruthy();

            case 20:
              i++;
              _context5.next = 7;
              break;

            case 23:
              jest.runAllTimers();
              _i2 = 0;

            case 25:
              if (!(_i2 < retryCount + 1)) {
                _context5.next = 31;
                break;
              }

              _context5.next = 28;
              return Promise.resolve(true);

            case 28:
              _i2++;
              _context5.next = 25;
              break;

            case 31:
              expect(mockedStopPolling).toHaveBeenCalledTimes(1);
              expect(wrapper.instance().config._ismounted).toBeFalsy();
              expect(wrapper.state().isPolling).toBeFalsy();
              mockedRunPolling.mockRestore();
              mockedRunPolling.mockClear();

            case 36:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    })));
  });
});