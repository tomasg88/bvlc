"use strict";

exports.__esModule = true;
exports["default"] = exports.ReactPolling = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
<ReactPolling 
  url={'url to poll'}
  interval= {3000} // in milliseconds(ms)
  retryCount={3} // this is optional
  onSuccess={() => console.log('handle success')}
  onFailure={() => console.log('handle failure')} // this is optional
  method={'GET'}
  headers={headers object} // this is optional
  body={JSON.stringify(data)} // data to send in a post call. Should be stringified always
  promise={() => return axios.get('some url')} // to be used when the user wants to not use fetch and instead wants to send their own api calling logic
  backOffFactor={2} // exponential back off time for polling an api. Default is 1
  render={({ startPolling, stopPolling, isPolling }) => {
    if(isPolling) {
      return (
        <div>
          <p>Hello I am polling<p>
        </div>
      );
    } else {
      return (
        <div>Hello I stopped polling</div>
      );
    }
  }}
/>
*/
var ReactPolling = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ReactPolling, _React$Component);

  var _super = _createSuper(ReactPolling);

  /**
   * Initial config for setting up the polling service
   * @param {Object} options
   * For example:-
   * options = {
   *  url: 'api that we need to poll',
   *  interval: interval for polling
   *  retryCount: the no of times to retry when the api call fails
   *  -----------------------------------------
   *  onSuccess: what should happen on a successful response. This should either return a true to continue polling
   *  or false to stop polling
   *  -----------------------------------------
   *  onFailure: what should happen on a failure response, we can either garbage collect some variables. This is optional
   *  -----------------------------------------
   *  method: 'GET',
   *  headers: {
   *    Content-Type: 'application/json'
   *  },
   *  body: JSON.stringify(data) // in case of a post call
   *  promise={() => return axios.get('some url')} // to be used when the user wants to not use fetch and instead wants to send their own api calling logic
   *  backOffFactor={2} // exponential back off time for polling an api. Default is 1
   * }
   */
  function ReactPolling(props) {
    var _this2;

    _this2 = _React$Component.call(this, props) || this;
    _this2.state = {
      isPolling: false
    };

    _this2.initConfig(props);

    return _this2;
  }
  /**
   * Function to setup the config object with default config or the config provided by the user
   * @param {Object} options
   */


  var _proto = ReactPolling.prototype;

  _proto.initConfig = function initConfig(options) {
    var url = options.url,
        interval = options.interval,
        retryCount = options.retryCount,
        backOffFactor = options.backOffFactor,
        onSuccess = options.onSuccess,
        onFailure = options.onFailure,
        promise = options.promise,
        api = _objectWithoutPropertiesLoose(options, ["url", "interval", "retryCount", "backOffFactor", "onSuccess", "onFailure", "promise"]);

    interval = Number(interval);
    retryCount = Number(retryCount);
    backOffFactor = Number(backOffFactor);
    this.config = {
      url: url,
      interval: interval,
      shouldRetry: retryCount ? true : false,
      retryCount: retryCount,
      backOffFactor: backOffFactor,
      onSuccess: onSuccess,
      onFailure: onFailure,
      promise: promise,
      api: api
    };
  }
  /**
   * To be called by the user of this service or when the poll api fails.
   * It will set the isPolling to false and stop the timer
   */
  ;

  _proto.stopPolling = function stopPolling() {
    if (this._ismounted) {
      var isPolling = false;

      if (this.poll) {
        clearTimeout(this.poll);
        this.poll = null;
      }

      this.setState({
        isPolling: isPolling
      });
    }
  }
  /**
   * To be called manually by the user of this service.
   * This will call runPolling and start polling our api
   */
  ;

  _proto.startPolling = function startPolling() {
    // if no url specified, throw an error
    if (!this.config.url) {
      throw new Error('No url provided to poll. Please provide a config object with the url param set');
    } // reset the interval back to original


    this.config.interval = this.props.interval; // set isPolling to true

    this.setState({
      isPolling: true
    }); // call runPolling, which will start timer and call our api

    this.runPolling();
  }
  /**
   * start a timer with the interval specified by the user || default interval
   * we are using setTimeout and not setinterval because a slow back end server might take more time than our interval time and that would lead to
   * a queue of ajax requests with no response at all.
   * -----------------------------------------
   * This function would call the api first time and only on the success response of the api we would poll again after the interval
   */
  ;

  _proto.runPolling = function runPolling() {
    var _this$config = this.config,
        url = _this$config.url,
        interval = _this$config.interval,
        backOffFactor = _this$config.backOffFactor,
        onSuccess = _this$config.onSuccess,
        onFailure = _this$config.onFailure,
        promise = _this$config.promise,
        api = _this$config.api;
    var pollingPromise = promise && promise(url) || fetch(url, api);

    var _this = this;

    this.poll = setTimeout(function () {
      /* onSuccess would be handled by the user of service which would either return true or false
       * true - This means we need to continue polling
       * false - This means we need to stop polling
       */
      pollingPromise.then(function (resp) {
        if (resp && resp.json) {
          return resp.json().then(function (data) {
            if (resp.ok) {
              return data;
            } else {
              return Promise.reject({
                status: resp.status,
                data: data
              });
            }
          })["catch"](function (data) {
            if (resp.ok) {
              return data;
            } else {
              return Promise.reject({
                status: resp.status,
                data: data
              });
            }
          });
        }

        return resp;
      }).then(onSuccess).then(function (continuePolling) {
        if (_this.state.isPolling && continuePolling) {
          _this.config.interval *= backOffFactor;

          _this.runPolling();
        } else {
          _this.stopPolling();
        }
      })["catch"](function (error) {
        if (_this.config.shouldRetry && _this.config.retryCount > 0) {
          onFailure && onFailure(error);
          _this.config.retryCount--;
          _this.config.interval *= backOffFactor;

          _this.runPolling();
        } else {
          onFailure && onFailure(error);

          _this.stopPolling();
        }
      });
    }, interval);
  };

  _proto.componentDidMount = function componentDidMount() {
    // set _isMounted to true to check if our component is still mounted or the user re-directed to some other page
    this._ismounted = true;
    this.startPolling();
  };

  _proto.render = function render() {
    if (this.props.render) {
      return this.props.render({
        startPolling: this.startPolling.bind(this),
        stopPolling: this.stopPolling.bind(this),
        isPolling: this.state.isPolling
      });
    }

    return this.props.children({
      startPolling: this.startPolling.bind(this),
      stopPolling: this.stopPolling.bind(this),
      isPolling: this.state.isPolling
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.stopPolling(); // set _isMounted to false so that we do no call setState on an unmouted component

    this._ismounted = false;
  };

  return ReactPolling;
}(_react["default"].Component); // prop types check for dev environment


exports.ReactPolling = ReactPolling;
ReactPolling.propTypes = {
  url: _propTypes["default"].string,
  interval: _propTypes["default"].number,
  retryCount: _propTypes["default"].number,
  onSuccess: _propTypes["default"].func.isRequired,
  onFailure: _propTypes["default"].func,
  headers: _propTypes["default"].object,
  method: _propTypes["default"].string,
  body: _propTypes["default"].object,
  render: _propTypes["default"].func,
  promise: _propTypes["default"].func,
  backOffFactor: _propTypes["default"].number,
  children: _propTypes["default"].func
}; // default props

ReactPolling.defaultProps = {
  interval: 3000,
  retryCount: 0,
  backOffFactor: 1,
  onFailure: function onFailure() {},
  method: 'GET'
};
var _default = ReactPolling;
exports["default"] = _default;