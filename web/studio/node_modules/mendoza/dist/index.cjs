'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const OPS = ["Value", "Copy", "Blank", "ReturnIntoArray", "ReturnIntoObject", "ReturnIntoObjectSameKey", "PushField", "PushElement", "PushParent", "Pop", "PushFieldCopy", "PushFieldBlank", "PushElementCopy", "PushElementBlank", "ReturnIntoObjectPop", "ReturnIntoObjectSameKeyPop", "ReturnIntoArrayPop", "ObjectSetFieldValue", "ObjectCopyField", "ObjectDeleteField", "ArrayAppendValue", "ArrayAppendSlice", "StringAppendString", "StringAppendSlice"];
class Patcher {
  constructor(model, root, patch) {
    __publicField$1(this, "model");
    __publicField$1(this, "root");
    __publicField$1(this, "patch");
    __publicField$1(this, "i");
    __publicField$1(this, "inputStack");
    __publicField$1(this, "outputStack");
    this.model = model;
    this.root = root;
    this.patch = patch;
    this.i = 0;
    this.inputStack = [];
    this.outputStack = [];
  }
  read() {
    return this.patch[this.i++];
  }
  process() {
    this.inputStack.push({
      value: this.root
    });
    this.outputStack.push({
      value: this.root
    });
    for (; this.i < this.patch.length;) {
      let opcode = this.read();
      let op = OPS[opcode];
      if (!op) throw new Error("Unknown opcode: ".concat(opcode));
      let processor = "process".concat(op);
      this[processor].apply(this);
    }
    let entry = this.outputStack.pop();
    return this.finalizeOutput(entry);
  }
  inputEntry() {
    return this.inputStack[this.inputStack.length - 1];
  }
  inputKey(entry, idx) {
    if (!entry.keys) {
      entry.keys = this.model.objectGetKeys(entry.value).sort();
    }
    return entry.keys[idx];
  }
  outputEntry() {
    return this.outputStack[this.outputStack.length - 1];
  }
  outputArray() {
    let entry = this.outputEntry();
    if (!entry.writeValue) {
      entry.writeValue = this.model.copyArray(entry.value);
    }
    return entry.writeValue;
  }
  outputObject() {
    let entry = this.outputEntry();
    if (!entry.writeValue) {
      entry.writeValue = this.model.copyObject(entry.value);
    }
    return entry.writeValue;
  }
  outputString() {
    let entry = this.outputEntry();
    if (!entry.writeValue) {
      entry.writeValue = this.model.copyString(entry.value);
    }
    return entry.writeValue;
  }
  finalizeOutput(entry) {
    if (entry.writeValue) {
      return this.model.finalize(entry.writeValue);
    } else {
      return entry.value;
    }
  }
  // Processors:
  processValue() {
    let value = this.model.wrap(this.read());
    this.outputStack.push({
      value
    });
  }
  processCopy() {
    let input = this.inputEntry();
    this.outputStack.push({
      value: input.value
    });
  }
  processBlank() {
    this.outputStack.push({
      value: null
    });
  }
  processReturnIntoArray() {
    let entry = this.outputStack.pop();
    let result = this.finalizeOutput(entry);
    let arr = this.outputArray();
    this.model.arrayAppendValue(arr, result);
  }
  processReturnIntoObject() {
    let key = this.read();
    let entry = this.outputStack.pop();
    let result = this.finalizeOutput(entry);
    result = this.model.markChanged(result);
    let obj = this.outputObject();
    this.model.objectSetField(obj, key, result);
  }
  processReturnIntoObjectSameKey() {
    let input = this.inputEntry();
    let entry = this.outputStack.pop();
    let result = this.finalizeOutput(entry);
    let obj = this.outputObject();
    this.model.objectSetField(obj, input.key, result);
  }
  processPushField() {
    let idx = this.read();
    let entry = this.inputEntry();
    let key = this.inputKey(entry, idx);
    let value = this.model.objectGetField(entry.value, key);
    this.inputStack.push({
      value,
      key
    });
  }
  processPushElement() {
    let idx = this.read();
    let entry = this.inputEntry();
    let value = this.model.arrayGetElement(entry.value, idx);
    this.inputStack.push({
      value
    });
  }
  processPop() {
    this.inputStack.pop();
  }
  processPushFieldCopy() {
    this.processPushField();
    this.processCopy();
  }
  processPushFieldBlank() {
    this.processPushField();
    this.processBlank();
  }
  processPushElementCopy() {
    this.processPushElement();
    this.processCopy();
  }
  processPushElementBlank() {
    this.processPushElement();
    this.processBlank();
  }
  processReturnIntoObjectPop() {
    this.processReturnIntoObject();
    this.processPop();
  }
  processReturnIntoObjectSameKeyPop() {
    this.processReturnIntoObjectSameKey();
    this.processPop();
  }
  processReturnIntoArrayPop() {
    this.processReturnIntoArray();
    this.processPop();
  }
  processObjectSetFieldValue() {
    this.processValue();
    this.processReturnIntoObject();
  }
  processObjectCopyField() {
    this.processPushField();
    this.processCopy();
    this.processReturnIntoObjectSameKey();
    this.processPop();
  }
  processObjectDeleteField() {
    let idx = this.read();
    let entry = this.inputEntry();
    let key = this.inputKey(entry, idx);
    let obj = this.outputObject();
    this.model.objectDeleteField(obj, key);
  }
  processArrayAppendValue() {
    let value = this.model.wrap(this.read());
    let arr = this.outputArray();
    this.model.arrayAppendValue(arr, value);
  }
  processArrayAppendSlice() {
    let left = this.read();
    let right = this.read();
    let str = this.outputArray();
    let val = this.inputEntry().value;
    this.model.arrayAppendSlice(str, val, left, right);
  }
  processStringAppendString() {
    let value = this.model.wrap(this.read());
    let str = this.outputString();
    this.model.stringAppendValue(str, value);
  }
  processStringAppendSlice() {
    let left = this.read();
    let right = this.read();
    let str = this.outputString();
    let val = this.inputEntry().value;
    this.model.stringAppendSlice(str, val, left, right);
  }
}
function utf8charSize(code) {
  if (code >> 16) {
    return 4;
  } else if (code >> 11) {
    return 3;
  } else if (code >> 7) {
    return 2;
  } else {
    return 1;
  }
}
function utf8stringSize(str) {
  let b = 0;
  for (let i = 0; i < str.length; i++) {
    let code = str.codePointAt(i);
    let size = utf8charSize(code);
    if (size == 4) i++;
    b += size;
  }
  return b;
}
function utf8resolveIndex(str, idx) {
  let start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let byteCount = start;
  let ucsIdx = 0;
  for (ucsIdx = start; byteCount < idx; ucsIdx++) {
    let code = str.codePointAt(ucsIdx);
    let size = utf8charSize(code);
    if (size === 4) ucsIdx++;
    byteCount += size;
  }
  return ucsIdx;
}
function commonPrefix(str, str2) {
  let len = Math.min(str.length, str2.length);
  let b = 0;
  for (let i = 0; i < len;) {
    let aPoint = str.codePointAt(i);
    let bPoint = str2.codePointAt(i);
    if (aPoint !== bPoint) return b;
    let size = utf8charSize(aPoint);
    b += size;
    i += size === 4 ? 2 : 1;
  }
  return b;
}
function commonSuffix(str, str2) {
  let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let len = Math.min(str.length, str2.length) - prefix;
  let b = 0;
  for (let i = 0; i < len;) {
    let aPoint = str.codePointAt(str.length - 1 - i);
    let bPoint = str2.codePointAt(str2.length - 1 - i);
    if (aPoint !== bPoint) return b;
    let size = utf8charSize(aPoint);
    b += size;
    i += size === 4 ? 2 : 1;
  }
  return b;
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class IncrementalModel {
  constructor(meta) {
    __publicField(this, "meta");
    this.meta = meta;
  }
  wrap(data) {
    return this.wrapWithMeta(data, this.meta, this.meta);
  }
  wrapWithMeta(data, startMeta) {
    let endMeta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.meta;
    return {
      data,
      startMeta,
      endMeta
    };
  }
  asObject(value) {
    if (!value.content) {
      let fields = {};
      for (let [key, val] of Object.entries(value.data)) {
        fields[key] = this.wrapWithMeta(val, value.startMeta);
      }
      value.content = {
        type: "object",
        fields
      };
    }
    return value.content;
  }
  asArray(value) {
    if (!value.content) {
      let elements = value.data.map(item => this.wrapWithMeta(item, value.startMeta));
      let metas = elements.map(() => this.meta);
      value.content = {
        type: "array",
        elements,
        metas
      };
    }
    return value.content;
  }
  asString(value) {
    if (!value.content) {
      let str = value.data;
      let part = {
        value: str,
        utf8size: utf8stringSize(str),
        uses: [],
        startMeta: value.startMeta,
        endMeta: value.endMeta
      };
      value.content = this.stringFromParts([part]);
    }
    return value.content;
  }
  stringFromParts(parts) {
    let str = {
      type: "string",
      parts
    };
    for (let part of parts) {
      part.uses.push(str);
    }
    return str;
  }
  objectGetKeys(value) {
    if (value.content) {
      return Object.keys(value.content.fields);
    } else {
      return Object.keys(value.data);
    }
  }
  objectGetField(value, key) {
    let obj = this.asObject(value);
    return obj.fields[key];
  }
  arrayGetElement(value, idx) {
    let arr = this.asArray(value);
    return arr.elements[idx];
  }
  finalize(content) {
    this.updateEndMeta(content);
    return {
      content,
      startMeta: this.meta,
      endMeta: this.meta
    };
  }
  markChanged(value) {
    return this.wrap(unwrap(value));
  }
  updateEndMeta(content) {
    if (content.type == "string") {
      for (let part of content.parts) {
        part.endMeta = this.meta;
      }
    } else {
      if (content.type === "array") {
        for (let val of content.elements) {
          if (val.content && val.endMeta !== this.meta) {
            this.updateEndMeta(val.content);
          }
          val.endMeta = this.meta;
        }
      } else {
        for (let val of Object.values(content.fields)) {
          if (val.content && val.endMeta !== this.meta) {
            this.updateEndMeta(val.content);
          }
          val.endMeta = this.meta;
        }
      }
    }
  }
  copyString(value) {
    if (value) {
      let other = this.asString(value);
      return this.stringFromParts(other.parts.slice());
    } else {
      return {
        type: "string",
        parts: []
      };
    }
  }
  copyObject(value) {
    let obj = {
      type: "object",
      fields: {}
    };
    if (value) {
      let other = this.asObject(value);
      Object.assign(obj.fields, other.fields);
    }
    return obj;
  }
  copyArray(value) {
    let arr = value ? this.asArray(value) : null;
    let elements = arr ? arr.elements : [];
    let metas = arr ? arr.metas : [];
    return {
      type: "array",
      elements,
      metas
    };
  }
  objectSetField(target, key, value) {
    target.fields[key] = value;
  }
  objectDeleteField(target, key) {
    delete target.fields[key];
  }
  arrayAppendValue(target, value) {
    target.elements.push(value);
    target.metas.push(this.meta);
  }
  arrayAppendSlice(target, source, left, right) {
    let arr = this.asArray(source);
    let samePosition = arr.elements.length === left;
    target.elements.push(...arr.elements.slice(left, right));
    if (samePosition) {
      target.metas.push(...arr.metas.slice(left, right));
    } else {
      for (let i = left; i < right; i++) {
        target.metas.push(this.meta);
      }
    }
  }
  stringAppendValue(target, value) {
    let str = this.asString(value);
    for (let part of str.parts) {
      this.stringAppendPart(target, part);
    }
  }
  stringAppendPart(target, part) {
    target.parts.push(part);
    part.uses.push(target);
  }
  resolveStringPart(str, from, len) {
    if (len === 0) return from;
    for (let i = from; i < str.parts.length; i++) {
      let part = str.parts[i];
      if (len === part.utf8size) {
        return i + 1;
      }
      if (len < part.utf8size) {
        this.splitString(part, len);
        return i + 1;
      }
      len -= part.utf8size;
    }
    throw new Error("splitting string out of bounds");
  }
  splitString(part, idx) {
    let leftValue;
    let rightValue;
    let leftSize = idx;
    let rightSize = part.utf8size - leftSize;
    if (part.utf8size !== part.value.length) {
      let byteCount = 0;
      for (idx = 0; byteCount < leftSize; idx++) {
        let code = part.value.codePointAt(idx);
        let size = utf8charSize(code);
        if (size === 4) idx++;
        byteCount += size;
      }
    }
    leftValue = part.value.slice(0, idx);
    rightValue = part.value.slice(idx);
    let newPart = {
      value: rightValue,
      utf8size: rightSize,
      uses: part.uses.slice(),
      startMeta: part.startMeta,
      endMeta: part.endMeta
    };
    part.value = leftValue;
    part.utf8size = leftSize;
    for (let use of part.uses) {
      let ndx = use.parts.indexOf(part);
      if (ndx === -1) throw new Error("bug: mismatch between string parts and use.");
      use.parts.splice(ndx + 1, 0, newPart);
    }
  }
  stringAppendSlice(target, source, left, right) {
    let str = this.asString(source);
    let firstPart = this.resolveStringPart(str, 0, left);
    let lastPart = this.resolveStringPart(str, firstPart, right - left);
    for (let i = firstPart; i < lastPart; i++) {
      let part = str.parts[i];
      this.stringAppendPart(target, part);
    }
  }
}
function wrap(data, meta) {
  return {
    data,
    startMeta: meta,
    endMeta: meta
  };
}
function unwrap(value) {
  if (typeof value.data !== "undefined") return value.data;
  let result;
  let content = value.content;
  switch (content.type) {
    case "string":
      result = content.parts.map(part => part.value).join("");
      break;
    case "array":
      result = content.elements.map(val => unwrap(val));
      break;
    case "object":
      {
        result = {};
        for (let [key, val] of Object.entries(content.fields)) {
          result[key] = unwrap(val);
        }
      }
  }
  value.data = result;
  return result;
}
function getType(value) {
  if (value.content) return value.content.type;
  if (Array.isArray(value.data)) return "array";
  if (value.data === null) return "null";
  return typeof value.data;
}
function rebaseValue(left, right) {
  let leftType = getType(left);
  let rightType = getType(right);
  if (leftType !== rightType) return right;
  let leftModel = new IncrementalModel(left.endMeta);
  let rightModel = new IncrementalModel(right.endMeta);
  switch (leftType) {
    case "object":
      {
        let leftObj = leftModel.asObject(left);
        let rightObj = rightModel.asObject(right);
        let identicalFieldCount = 0;
        let leftFieldCount = Object.keys(leftObj.fields).length;
        let rightFieldCount = Object.keys(rightObj.fields).length;
        for (let [key, rightVal] of Object.entries(rightObj.fields)) {
          let leftVal = leftObj.fields[key];
          if (leftVal) {
            rightObj.fields[key] = rebaseValue(leftVal, rightVal);
            if (rightObj.fields[key] === leftVal) {
              identicalFieldCount++;
            }
          }
        }
        let isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;
        return isIdentical ? left : right;
      }
    case "array":
      {
        let leftArr = leftModel.asArray(left);
        let rightArr = rightModel.asArray(right);
        if (leftArr.elements.length !== rightArr.elements.length) {
          break;
        }
        let numRebased = 0;
        for (let i = 0; i < rightArr.elements.length; i++) {
          rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);
          if (rightArr.elements[i] !== leftArr.elements[i]) {
            numRebased++;
          }
        }
        return numRebased === 0 ? left : right;
      }
    case "null":
    case "boolean":
    case "number":
      {
        if (unwrap(left) === unwrap(right)) return left;
        break;
      }
    case "string":
      {
        let leftRaw = unwrap(left);
        let rightRaw = unwrap(right);
        if (leftRaw === rightRaw) return left;
        let result = rightModel.copyString(null);
        let prefix = commonPrefix(leftRaw, rightRaw);
        let suffix = commonSuffix(leftRaw, rightRaw, prefix);
        let rightLen = utf8stringSize(rightRaw);
        let leftLen = utf8stringSize(leftRaw);
        if (0 < prefix) {
          rightModel.stringAppendSlice(result, left, 0, prefix);
        }
        if (prefix < rightLen - suffix) {
          rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);
        }
        if (leftLen - suffix < leftLen) {
          rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);
        }
        let value = rightModel.finalize(result);
        if (unwrap(value) !== rightRaw) throw new Error("incorrect string rebase");
        return value;
      }
  }
  return right;
}
function applyPatch$1(left, patch, startMeta) {
  let model = new IncrementalModel(startMeta);
  let patcher = new Patcher(model, left, patch);
  return patcher.process();
}
var incrementalPatcher = /*#__PURE__*/Object.freeze({
  __proto__: null,
  applyPatch: applyPatch$1,
  getType: getType,
  rebaseValue: rebaseValue,
  unwrap: unwrap,
  wrap: wrap
});
class SimpleModel {
  wrap(data) {
    return data;
  }
  finalize(b) {
    if (Array.isArray(b)) {
      return b;
    } else {
      return b.data;
    }
  }
  markChanged(value) {
    return value;
  }
  objectGetKeys(value) {
    return Object.keys(value);
  }
  objectGetField(value, key) {
    return value[key];
  }
  arrayGetElement(value, idx) {
    return value[idx];
  }
  copyObject(value) {
    let res = {
      type: "object",
      data: {}
    };
    if (value !== null) {
      for (let [key, val] of Object.entries(value)) {
        res.data[key] = val;
      }
    }
    return res;
  }
  copyArray(value) {
    if (value === null) return [];
    return value.slice();
  }
  copyString(value) {
    return {
      type: "string",
      data: value === null ? "" : value
    };
  }
  objectSetField(target, key, value) {
    target.data[key] = value;
  }
  objectDeleteField(target, key) {
    delete target.data[key];
  }
  arrayAppendValue(target, value) {
    target.push(value);
  }
  arrayAppendSlice(target, source, left, right) {
    target.push(...source.slice(left, right));
  }
  stringAppendSlice(target, source, left, right) {
    const sourceString = source;
    const leftPos = utf8resolveIndex(sourceString, left);
    const rightPos = utf8resolveIndex(sourceString, right, leftPos);
    target.data += sourceString.slice(leftPos, rightPos);
  }
  stringAppendValue(target, value) {
    target.data += value;
  }
}
function applyPatch(left, patch) {
  let root = left;
  let patcher = new Patcher(new SimpleModel(), root, patch);
  return patcher.process();
}
exports.applyPatch = applyPatch;
exports.incremental = incrementalPatcher;
//# sourceMappingURL=index.cjs.map
