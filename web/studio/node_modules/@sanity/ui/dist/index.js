'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var ReactIs = require('react-is');
var styled = require('styled-components');
var color$1 = require('@sanity/color');
var icons = require('@sanity/icons');
var Refractor = require('react-refractor');
var reactDom$1 = require('@floating-ui/react-dom');
var reactDom = require('react-dom');
var framerMotion = require('framer-motion');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var ReactIs__default = /*#__PURE__*/_interopDefaultCompat(ReactIs);
var styled__default = /*#__PURE__*/_interopDefaultCompat(styled);
var Refractor__default = /*#__PURE__*/_interopDefaultCompat(Refractor);
const EMPTY_ARRAY = [];
const EMPTY_RECORD = {};
const FLOATING_STATIC_SIDES = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
function _fillCSSObject(keys, value) {
  return keys.reduce((style, key) => {
    style[key] = value;
    return style;
  }, {});
}
function rem(pixelValue) {
  if (pixelValue === 0) return 0;
  return "".concat(pixelValue / 16, "rem");
}
function _responsive(media, values, callback) {
  const statements = (values == null ? void 0 : values.map(callback)) || [];
  return statements.map((statement, mediaIndex) => {
    if (mediaIndex === 0) return statement;
    return {
      ["@media screen and (min-width: ".concat(media[mediaIndex - 1], "px)")]: statement
    };
  });
}
function _getArrayProp(val, defaultVal) {
  if (val === void 0) return defaultVal || EMPTY_ARRAY;
  return Array.isArray(val) ? val : [val];
}
function _getResponsiveSpace(theme, props) {
  let spaceIndexes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_ARRAY;
  if (!Array.isArray(spaceIndexes)) {
    throw new Error("the property must be array of numbers");
  }
  if (spaceIndexes.length === 0) {
    return null;
  }
  return _responsive(theme.sanity.media, spaceIndexes, spaceIndex => _fillCSSObject(props, rem(theme.sanity.space[spaceIndex])));
}
function responsiveFont(fontKey, props) {
  const {
    $size,
    $weight,
    theme
  } = props;
  const {
    fonts,
    media
  } = theme.sanity;
  const {
    family,
    sizes,
    weights
  } = fonts[fontKey];
  const fontWeight = $weight && weights[$weight] || weights.regular;
  const defaultSize = sizes[2];
  const base = {
    position: "relative",
    fontFamily: family,
    fontWeight,
    padding: "1px 0",
    margin: 0,
    "&:before": {
      content: '""',
      display: "block",
      height: 0
    },
    "&:after": {
      content: '""',
      display: "block",
      height: 0
    },
    "& > code, & > span": {
      display: "block"
    },
    "&:not([hidden])": {
      display: "block"
    }
  };
  if (!$size) {
    if (!responsiveFont.warned) {
      console.warn("No size specified for responsive font", {
        fontKey,
        $size,
        props,
        base
      });
      responsiveFont.warned = true;
    }
    return [base];
  }
  const resp = _responsive(media, $size, sizeIndex => fontSize(sizes[sizeIndex] || defaultSize));
  return [base, ...resp];
}
function fontSize(size) {
  const {
    ascenderHeight,
    descenderHeight,
    fontSize: fontSize2,
    iconSize,
    letterSpacing,
    lineHeight
  } = size;
  const negHeight = ascenderHeight + descenderHeight;
  const capHeight = lineHeight - negHeight;
  const iconOffset = (capHeight - iconSize) / 2;
  const customIconSize = Math.floor(fontSize2 * 1.125 / 2) * 2 + 1;
  const customIconOffset = (capHeight - customIconSize) / 2;
  return {
    fontSize: rem(fontSize2),
    lineHeight: "calc(".concat(lineHeight, " / ").concat(fontSize2, ")"),
    letterSpacing: rem(letterSpacing),
    transform: "translateY(".concat(rem(descenderHeight), ")"),
    "&:before": {
      marginTop: "calc(".concat(rem(0 - negHeight), " - 1px)")
    },
    "&:after": {
      marginBottom: "-1px"
    },
    "& svg:not([data-sanity-icon])": {
      fontSize: "calc(".concat(customIconSize, " / 16 * 1rem)"),
      margin: rem(customIconOffset)
    },
    "& [data-sanity-icon]": {
      fontSize: "calc(".concat(iconSize, " / 16 * 1rem)"),
      margin: rem(iconOffset)
    }
  };
}
function responsiveCodeFontStyle(props) {
  return responsiveFont("code", props);
}
function responsiveHeadingFont(props) {
  return responsiveFont("heading", props);
}
function responsiveLabelFont(props) {
  return responsiveFont("label", props);
}
function responsiveTextAlignStyle(props) {
  const {
    theme
  } = props;
  return _responsive(theme.sanity.media, props.$align, textAlign => {
    return {
      textAlign
    };
  });
}
function responsiveTextFont(props) {
  return responsiveFont("text", props);
}
function useArrayProp(val, defaultVal) {
  const __perf_hash__ = react.useMemo(() => JSON.stringify(val != null ? val : defaultVal), [defaultVal, val]);
  return react.useMemo(() => _getArrayProp(val, defaultVal),
  // Improve performance: Keep object identify for a given hash of the value
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [__perf_hash__]);
}
function _getElements(element, elementsArg) {
  const ret = [element];
  for (const el of elementsArg) {
    if (Array.isArray(el)) {
      ret.push(...el);
    } else {
      ret.push(el);
    }
  }
  return ret.filter(Boolean);
}
function useClickOutside(listener) {
  let elementsArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_ARRAY;
  let boundaryElement = arguments.length > 2 ? arguments[2] : undefined;
  const [element, setElement] = react.useState(null);
  const [elements, setElements] = react.useState(() => _getElements(element, elementsArg));
  const elementsRef = react.useRef(elements);
  react.useEffect(() => {
    const prevElements = elementsRef.current;
    const nextElements = _getElements(element, elementsArg);
    if (prevElements.length !== nextElements.length) {
      setElements(nextElements);
      elementsRef.current = nextElements;
      return;
    }
    for (const el of prevElements) {
      if (!nextElements.includes(el)) {
        setElements(nextElements);
        elementsRef.current = nextElements;
        return;
      }
    }
    for (const el of nextElements) {
      if (!prevElements.includes(el)) {
        setElements(nextElements);
        elementsRef.current = nextElements;
        return;
      }
    }
  }, [element, elementsArg]);
  react.useEffect(() => {
    if (!listener) return void 0;
    const handleWindowMouseDown = evt => {
      const target = evt.target;
      if (!(target instanceof Node)) {
        return;
      }
      if (boundaryElement && !boundaryElement.contains(target)) {
        return;
      }
      for (const el of elements) {
        if (target === el || el.contains(target)) {
          return;
        }
      }
      listener(evt);
    };
    window.addEventListener("mousedown", handleWindowMouseDown);
    return () => {
      window.removeEventListener("mousedown", handleWindowMouseDown);
    };
  }, [boundaryElement, listener, elements]);
  return setElement;
}
var resizeObservers = [];
var hasActiveObservations = function () {
  return resizeObservers.some(function (ro) {
    return ro.activeTargets.length > 0;
  });
};
var hasSkippedObservations = function () {
  return resizeObservers.some(function (ro) {
    return ro.skippedTargets.length > 0;
  });
};
var msg = 'ResizeObserver loop completed with undelivered notifications.';
var deliverResizeLoopError = function () {
  var event;
  if (typeof ErrorEvent === 'function') {
    event = new ErrorEvent('error', {
      message: msg
    });
  } else {
    event = document.createEvent('Event');
    event.initEvent('error', false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};
var ResizeObserverBoxOptions;
(function (ResizeObserverBoxOptions) {
  ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function (obj) {
  return Object.freeze(obj);
};
var ResizeObserverSize = function () {
  function ResizeObserverSize(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize;
}();
var DOMRectReadOnly = function () {
  function DOMRectReadOnly(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly.prototype.toJSON = function () {
    var _a = this,
      x = _a.x,
      y = _a.y,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom,
      left = _a.left,
      width = _a.width,
      height = _a.height;
    return {
      x: x,
      y: y,
      top: top,
      right: right,
      bottom: bottom,
      left: left,
      width: width,
      height: height
    };
  };
  DOMRectReadOnly.fromRect = function (rectangle) {
    return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly;
}();
var isSVG = function (target) {
  return target instanceof SVGElement && 'getBBox' in target;
};
var isHidden = function (target) {
  if (isSVG(target)) {
    var _a = target.getBBox(),
      width = _a.width,
      height = _a.height;
    return !width && !height;
  }
  var _b = target,
    offsetWidth = _b.offsetWidth,
    offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function (obj) {
  var _a;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function (target) {
  switch (target.tagName) {
    case 'INPUT':
      if (target.type !== 'image') {
        break;
      }
    case 'VIDEO':
    case 'AUDIO':
    case 'EMBED':
    case 'OBJECT':
    case 'CANVAS':
    case 'IFRAME':
    case 'IMG':
      return true;
  }
  return false;
};
var global$1 = typeof window !== 'undefined' ? window : {};
var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
var parseDimension = function (pixel) {
  return parseFloat(pixel || '0');
};
var size$1 = function (inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size$1(),
  borderBoxSize: size$1(),
  contentBoxSize: size$1(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function (target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === 'border-box';
  var switchSizes = verticalRegexp.test(cs.writingMode || '');
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size$1(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size$1(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size$1(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function (target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation),
    borderBoxSize = _a.borderBoxSize,
    contentBoxSize = _a.contentBoxSize,
    devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
var ResizeObserverEntry = function () {
  function ResizeObserverEntry(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry;
}();
var calculateDepthForNode = function (node) {
  if (isHidden(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};
var broadcastActiveObservations = function () {
  var shallowestDepth = Infinity;
  var callbacks = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};
var gatherActiveObservationsAtDepth = function (depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};
var process = function () {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};
var trigger;
var callbacks = [];
var notify = function () {
  return callbacks.splice(0).forEach(function (cb) {
    return cb();
  });
};
var queueMicroTask = function (callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode('');
    var config = {
      characterData: true
    };
    new MutationObserver(function () {
      return notify();
    }).observe(el_1, config);
    trigger = function () {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};
var queueResizeObserver = function (cb) {
  queueMicroTask(function ResizeObserver() {
    requestAnimationFrame(cb);
  });
};
var watching = 0;
var isWatching = function () {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = {
  attributes: true,
  characterData: true,
  childList: true,
  subtree: true
};
var events = ['resize', 'load', 'transitionend', 'animationend', 'animationstart', 'animationiteration', 'keyup', 'keydown', 'mouseup', 'mousedown', 'mouseover', 'mouseout', 'blur', 'focus'];
var time = function (timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function () {
  function Scheduler() {
    var _this = this;
    this.stopped = true;
    this.listener = function () {
      return _this.schedule();
    };
  }
  Scheduler.prototype.run = function (timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function () {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1000);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler.prototype.schedule = function () {
    this.stop();
    this.run();
  };
  Scheduler.prototype.observe = function () {
    var _this = this;
    var cb = function () {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global$1.addEventListener('DOMContentLoaded', cb);
  };
  Scheduler.prototype.start = function () {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function (name) {
        return global$1.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler.prototype.stop = function () {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function (name) {
        return global$1.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler;
}();
var scheduler = new Scheduler();
var updateCount = function (n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};
var skipNotifyOnElement = function (target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === 'inline';
};
var ResizeObservation = function () {
  function ResizeObservation(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation.prototype.isActive = function () {
    var size = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size;
    }
    if (this.lastReportedSize.inlineSize !== size.inlineSize || this.lastReportedSize.blockSize !== size.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation;
}();
var ResizeObserverDetail = function () {
  function ResizeObserverDetail(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail;
}();
var observerMap = new WeakMap();
var getObservationIndex = function (observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = function () {
  function ResizeObserverController() {}
  ResizeObserverController.connect = function (resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController.observe = function (resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController.unobserve = function (resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController.disconnect = function (resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function (ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController;
}();
var ResizeObserver = function () {
  function ResizeObserver(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== 'function') {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver.prototype.observe = function (target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver.prototype.unobserve = function (target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver.prototype.disconnect = function () {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver.toString = function () {
    return 'function ResizeObserver () { [polyfill code] }';
  };
  return ResizeObserver;
}();
const _ResizeObserver = typeof document !== "undefined" && typeof window !== "undefined" && window.ResizeObserver ? window.ResizeObserver : ResizeObserver;
const _elementSizeObserver = _createElementSizeObserver();
function _createElementRectValueListener() {
  return {
    subscribe(element, subscriber) {
      const resizeObserver = new _ResizeObserver(_ref => {
        let [entry] = _ref;
        subscriber({
          _contentRect: entry.contentRect,
          border: {
            width: entry.borderBoxSize[0].inlineSize,
            height: entry.borderBoxSize[0].blockSize
          },
          content: {
            width: entry.contentRect.width,
            height: entry.contentRect.height
          }
        });
      });
      resizeObserver.observe(element);
      return () => {
        resizeObserver.unobserve(element);
        resizeObserver.disconnect();
      };
    }
  };
}
function _createElementSizeObserver() {
  const disposeCache = /* @__PURE__ */new WeakMap();
  const subscribersCache = /* @__PURE__ */new WeakMap();
  return {
    subscribe(element, subscriber) {
      const subscribers = subscribersCache.get(element) || [];
      let dispose = disposeCache.get(element);
      if (!subscribersCache.has(element)) {
        subscribersCache.set(element, subscribers);
        const listener = _createElementRectValueListener();
        dispose = listener.subscribe(element, elementRect => {
          for (const sub of subscribers) {
            sub(elementRect);
          }
        });
      }
      subscribers.push(subscriber);
      return () => {
        const idx = subscribers.indexOf(subscriber);
        if (idx > -1) {
          subscribers.splice(idx, 1);
        }
        if (subscribers.length === 0) {
          if (dispose) dispose();
        }
      };
    }
  };
}
function useElementSize(element) {
  const [size, setSize] = react.useState(null);
  react.useEffect(() => {
    if (!element) return void 0;
    return _elementSizeObserver.subscribe(element, setSize);
  }, [element]);
  return size;
}
function useElementRect(element) {
  const elementSize = useElementSize(element);
  return (elementSize == null ? void 0 : elementSize._contentRect) || null;
}
function useGlobalKeyDown(onKeyDown) {
  return react.useEffect(() => {
    addEventListener("keydown", onKeyDown);
    return () => removeEventListener("keydown", onKeyDown);
  }, [onKeyDown]);
}
function multiplyChannel(b, s) {
  return b * s;
}
function multiply$1(b, s) {
  return {
    r: Math.round(clamp$1(multiplyChannel(b.r / 255, s.r / 255) * 255)),
    g: Math.round(clamp$1(multiplyChannel(b.g / 255, s.g / 255) * 255)),
    b: Math.round(clamp$1(multiplyChannel(b.b / 255, s.b / 255) * 255))
  };
}
function clamp$1(num) {
  return Math.max(Math.min(num, 255), 0);
}
function screenChannel(b, s) {
  return b + s - b * s;
}
function screen$1(b, s) {
  return {
    r: Math.round(clamp(screenChannel(b.r / 255, s.r / 255) * 255)),
    g: Math.round(clamp(screenChannel(b.g / 255, s.g / 255) * 255)),
    b: Math.round(clamp(screenChannel(b.b / 255, s.b / 255) * 255))
  };
}
function clamp(num) {
  return Math.max(Math.min(num, 255), 0);
}
function hexToRgb(hex) {
  if (hex.length === 4) {
    const hexR = hex.slice(1, 2);
    const hexG = hex.slice(2, 3);
    const hexB = hex.slice(3, 4);
    return {
      r: parseInt(hexR + hexR, 16),
      g: parseInt(hexG + hexG, 16),
      b: parseInt(hexB + hexB, 16)
    };
  }
  return {
    r: parseInt(hex.slice(1, 3), 16),
    g: parseInt(hex.slice(3, 5), 16),
    b: parseInt(hex.slice(5, 7), 16)
  };
}
function rgbToHex(_ref2) {
  let {
    r,
    g,
    b
  } = _ref2;
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}
function rgbToHsl(_ref3) {
  let {
    r,
    g,
    b
  } = _ref3;
  r /= 255;
  g /= 255;
  b /= 255;
  const cmin = Math.min(r, g, b);
  const cmax = Math.max(r, g, b);
  const delta = cmax - cmin;
  let h = 0;
  let s = 0;
  let l = 0;
  if (delta == 0) h = 0;else if (cmax == r) h = (g - b) / delta % 6;else if (cmax == g) h = (b - r) / delta + 2;else h = (r - g) / delta + 4;
  h = Math.round(h * 60);
  if (h < 0) h += 360;
  l = (cmax + cmin) / 2;
  s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
  s = +(s * 100).toFixed(1);
  l = +(l * 100).toFixed(1);
  return {
    h,
    s,
    l
  };
}
function hslToRgb(hsl) {
  const s = hsl.s / 100;
  const l = hsl.l / 100;
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(hsl.h / 60 % 2 - 1));
  const m = l - c / 2;
  let r = 0;
  let g = 0;
  let b = 0;
  if (0 <= hsl.h && hsl.h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (60 <= hsl.h && hsl.h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (120 <= hsl.h && hsl.h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (180 <= hsl.h && hsl.h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (240 <= hsl.h && hsl.h < 300) {
    r = x;
    g = 0;
    b = c;
  } else if (300 <= hsl.h && hsl.h < 360) {
    r = c;
    g = 0;
    b = x;
  }
  return {
    r: Math.round((r + m) * 255),
    g: Math.round((g + m) * 255),
    b: Math.round((b + m) * 255)
  };
}
const HEX_CHARS = "0123456789ABCDEFabcdef";
const HSL_RE = /hsl\(\s*(\d+)\s*,\s*((\d+(?:\.\d+)?)%)\s*,\s*((\d+(?:\.\d+)?)%)\s*\)/i;
function isHexChars(str) {
  for (const c of str) {
    if (HEX_CHARS.indexOf(c) === -1) {
      return false;
    }
  }
  return true;
}
function isHex(str) {
  if (str[0] !== "#") return false;
  if (!(str.length === 4 || str.length === 7)) return false;
  return isHexChars(str.slice(1));
}
function parseHsl(str) {
  const res = HSL_RE.exec(str);
  if (!res) {
    throw new Error('parseHsl: string is not a HSL color: "'.concat(str, '"'));
  }
  return {
    h: parseInt(res[1]),
    s: parseFloat(res[3]),
    l: parseFloat(res[5])
  };
}
function parseColor(color) {
  if (!color) return {
    r: 0,
    g: 0,
    b: 0
  };
  if (typeof color !== "string") {
    throw new Error("parseColor: expected a string");
  }
  if (isHex(color)) {
    return hexToRgb(color);
  }
  if (color.startsWith("hsl(")) {
    return hslToRgb(parseHsl(color));
  }
  throw new Error('parseColor: unexpected color format: "'.concat(color, '"'));
}
function rgba(color, a) {
  const rgb = parseColor(color);
  return "rgba(".concat(rgb.r, ",").concat(rgb.g, ",").concat(rgb.b, ",").concat(a, ")");
}
function createButtonTones(opts, base, dark, solid, muted, mode) {
  return {
    default: opts.button({
      base,
      dark,
      solid: solid.default,
      muted: muted.default,
      mode
    }),
    primary: opts.button({
      base,
      dark,
      solid: solid.primary,
      muted: muted.primary,
      mode
    }),
    positive: opts.button({
      base,
      dark,
      solid: solid.positive,
      muted: muted.positive,
      mode
    }),
    caution: opts.button({
      base,
      dark,
      solid: solid.caution,
      muted: muted.caution,
      mode
    }),
    critical: opts.button({
      base,
      dark,
      solid: solid.critical,
      muted: muted.critical,
      mode
    })
  };
}
function createButtonModes(opts, base, dark, solid, muted) {
  return {
    default: createButtonTones(opts, base, dark, solid, muted, "default"),
    ghost: createButtonTones(opts, base, dark, solid, muted, "ghost"),
    bleed: createButtonTones(opts, base, dark, solid, muted, "bleed")
  };
}
function createCardStates(opts, base, dark, name, solid, muted) {
  return {
    enabled: opts.card({
      base,
      dark,
      name,
      state: "enabled",
      solid,
      muted
    }),
    disabled: opts.card({
      base,
      dark,
      name,
      state: "disabled",
      solid,
      muted
    }),
    hovered: opts.card({
      base,
      dark,
      name,
      state: "hovered",
      solid,
      muted
    }),
    pressed: opts.card({
      base,
      dark,
      name,
      state: "pressed",
      solid,
      muted
    }),
    selected: opts.card({
      base,
      dark,
      name,
      state: "selected",
      solid,
      muted
    })
  };
}
const black = "hsl(0, 0%, 0%)";
const white = "hsl(0, 0%, 100%)";
const colors = {
  default: {
    lightest: "hsl(0, 0%, 95%)",
    lighter: "hsl(0, 0%, 70%)",
    light: "hsl(0, 0%, 65%)",
    base: "hsl(0, 0%, 50%)",
    dark: "hsl(0, 0%, 35%)",
    darker: "hsl(0, 0%, 20%)",
    darkest: "hsl(0, 0%, 5%)"
  },
  transparent: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  primary: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  positive: {
    lightest: "hsl(120, 100%, 95%)",
    lighter: "hsl(120, 100%, 70%)",
    light: "hsl(120, 100%, 65%)",
    base: "hsl(120, 100%, 50%)",
    dark: "hsl(120, 100%, 35%)",
    darker: "hsl(120, 100%, 20%)",
    darkest: "hsl(120, 100%, 5%)"
  },
  caution: {
    lightest: "hsl(60, 100%, 95%)",
    lighter: "hsl(60, 100%, 70%)",
    light: "hsl(60, 100%, 65%)",
    base: "hsl(60, 100%, 50%)",
    dark: "hsl(60, 100%, 35%)",
    darker: "hsl(60, 100%, 20%)",
    darkest: "hsl(60, 100%, 5%)"
  },
  critical: {
    lightest: "hsl(0, 100%, 95%)",
    lighter: "hsl(0, 100%, 70%)",
    light: "hsl(0, 100%, 65%)",
    base: "hsl(0, 100%, 50%)",
    dark: "hsl(0, 100%, 35%)",
    darker: "hsl(0, 100%, 20%)",
    darkest: "hsl(0, 100%, 5%)"
  }
};
const spots = {
  gray: "hsl(0, 0%, 50%)",
  red: "hsl(0, 100%, 50%)",
  orange: "hsl(30, 100%, 50%)",
  yellow: "hsl(60, 100%, 50%)",
  green: "hsl(120, 100%, 50%)",
  cyan: "hsl(180, 100%, 50%)",
  blue: "hsl(240, 100%, 50%)",
  purple: "hsl(270, 100%, 50%)",
  magenta: "hsl(300, 100%, 50%)"
};
const tones$1 = {
  transparent: {
    bg: [colors.transparent.darkest, colors.transparent.lightest],
    fg: [colors.transparent.lightest, colors.transparent.darkest],
    border: [colors.transparent.darker, colors.transparent.lighter],
    focusRing: [colors.transparent.base, colors.transparent.base]
  },
  primary: {
    bg: [colors.primary.darkest, colors.primary.lightest],
    fg: [colors.primary.lightest, colors.primary.darkest],
    border: [colors.primary.darker, colors.primary.lighter],
    focusRing: [colors.primary.base, colors.primary.base]
  },
  positive: {
    bg: [colors.positive.darkest, colors.positive.lightest],
    fg: [colors.positive.lightest, colors.positive.darkest],
    border: [colors.positive.darker, colors.positive.lighter],
    focusRing: [colors.positive.base, colors.positive.base]
  },
  caution: {
    bg: [colors.caution.darkest, colors.caution.lightest],
    fg: [colors.caution.lightest, colors.caution.darkest],
    border: [colors.caution.darker, colors.caution.lighter],
    focusRing: [colors.caution.base, colors.caution.base]
  },
  critical: {
    bg: [colors.critical.darkest, colors.critical.lightest],
    fg: [colors.critical.lightest, colors.critical.darkest],
    border: [colors.critical.darker, colors.critical.lighter],
    focusRing: [colors.critical.base, colors.critical.base]
  }
};
const defaultOpts = {
  base: _ref4 => {
    let {
      dark,
      name
    } = _ref4;
    if (name === "default") {
      return {
        bg: dark ? black : white,
        fg: dark ? white : black,
        border: dark ? colors.default.darkest : colors.default.lightest,
        focusRing: colors.primary.base,
        shadow: {
          outline: black,
          umbra: black,
          penumbra: black,
          ambient: black
        },
        skeleton: {
          from: dark ? white : black,
          to: dark ? white : black
        }
      };
    }
    return {
      bg: tones$1[name].bg[dark ? 0 : 1],
      fg: tones$1[name].fg[dark ? 0 : 1],
      border: tones$1[name].border[dark ? 0 : 1],
      focusRing: tones$1[name].focusRing[dark ? 0 : 1],
      shadow: {
        outline: black,
        umbra: black,
        penumbra: black,
        ambient: black
      },
      skeleton: {
        from: dark ? white : black,
        to: dark ? white : black
      }
    };
  },
  solid: _ref5 => {
    let {
      base,
      dark,
      state,
      tone
    } = _ref5;
    const color = colors[tone];
    if (state === "hovered") {
      return {
        bg: dark ? color.light : color.dark,
        bg2: dark ? color.light : color.dark,
        border: dark ? color.lighter : color.darker,
        fg: dark ? color.darkest : color.lightest,
        muted: {
          fg: black
        },
        accent: {
          fg: black
        },
        link: {
          fg: black
        },
        code: {
          bg: black,
          fg: black
        },
        skeleton: base.skeleton
      };
    }
    return {
      bg: color.base,
      bg2: color.base,
      border: dark ? color.light : color.dark,
      fg: dark ? color.darkest : color.lightest,
      muted: {
        fg: black
      },
      accent: {
        fg: black
      },
      link: {
        fg: black
      },
      code: {
        bg: black,
        fg: black
      },
      skeleton: base.skeleton
    };
  },
  muted: _ref6 => {
    let {
      base,
      dark,
      state,
      tone
    } = _ref6;
    const color = colors[tone];
    if (state === "hovered") {
      return {
        bg: dark ? color.darker : color.lighter,
        bg2: dark ? color.darker : color.lighter,
        border: dark ? color.lighter : color.darker,
        fg: dark ? color.lightest : color.darkest,
        muted: {
          fg: black
        },
        accent: {
          fg: black
        },
        link: {
          fg: black
        },
        code: {
          bg: black,
          fg: black
        },
        skeleton: base.skeleton
      };
    }
    return {
      bg: dark ? color.darkest : color.lightest,
      bg2: dark ? color.darkest : color.lightest,
      border: dark ? color.darker : color.lighter,
      fg: dark ? color.lighter : color.darker,
      muted: {
        fg: black
      },
      accent: {
        fg: black
      },
      link: {
        fg: black
      },
      code: {
        bg: black,
        fg: black
      },
      skeleton: base.skeleton
    };
  },
  button: _ref7 => {
    let {
      base,
      mode,
      muted,
      solid
    } = _ref7;
    if (mode === "bleed") {
      return {
        ...muted,
        enabled: {
          bg: "transparent",
          bg2: "transparent",
          fg: muted.enabled.fg,
          border: "transparent",
          muted: {
            fg: black
          },
          accent: {
            fg: black
          },
          link: {
            fg: black
          },
          code: {
            bg: black,
            fg: black
          },
          skeleton: base.skeleton
        },
        hovered: {
          bg: muted.enabled.bg,
          bg2: muted.enabled.bg,
          fg: muted.hovered.fg,
          border: "transparent",
          muted: {
            fg: black
          },
          accent: {
            fg: black
          },
          link: {
            fg: black
          },
          code: {
            bg: black,
            fg: black
          },
          skeleton: base.skeleton
        }
      };
    }
    if (mode === "ghost") return {
      ...solid,
      enabled: muted.enabled
    };
    return solid;
  },
  card: _ref8 => {
    let {
      base
    } = _ref8;
    return {
      bg: black,
      bg2: black,
      fg: black,
      border: black,
      muted: {
        fg: black
      },
      accent: {
        fg: black
      },
      link: {
        fg: black
      },
      code: {
        bg: black,
        fg: black
      },
      skeleton: base.skeleton
    };
  },
  input: () => {
    return {
      bg: black,
      fg: black,
      border: black,
      placeholder: black
    };
  },
  selectable: _ref9 => {
    let {
      muted,
      state,
      tone
    } = _ref9;
    return muted[tone][state];
  },
  spot: _ref10 => {
    let {
      key
    } = _ref10;
    return spots[key];
  },
  syntax: () => ({
    atrule: black,
    attrName: black,
    attrValue: black,
    attribute: black,
    boolean: black,
    builtin: black,
    cdata: black,
    char: black,
    class: black,
    className: black,
    comment: black,
    constant: black,
    deleted: black,
    doctype: black,
    entity: black,
    function: black,
    hexcode: black,
    id: black,
    important: black,
    inserted: black,
    keyword: black,
    number: black,
    operator: black,
    prolog: black,
    property: black,
    pseudoClass: black,
    pseudoElement: black,
    punctuation: black,
    regex: black,
    selector: black,
    string: black,
    symbol: black,
    tag: black,
    unit: black,
    url: black,
    variable: black
  })
};
function createInputModes(opts, base, dark, solid, muted) {
  return {
    default: {
      enabled: opts.input({
        base,
        dark,
        mode: "default",
        state: "enabled",
        solid: solid.default,
        muted: muted.default
      }),
      disabled: opts.input({
        base,
        dark,
        mode: "default",
        state: "disabled",
        solid: solid.default,
        muted: muted.default
      }),
      hovered: opts.input({
        base,
        dark,
        mode: "default",
        state: "hovered",
        solid: solid.default,
        muted: muted.default
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: "default",
        state: "readOnly",
        solid: solid.default,
        muted: muted.default
      })
    },
    invalid: {
      enabled: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "enabled",
        solid: solid.default,
        muted: muted.default
      }),
      disabled: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "disabled",
        solid: solid.default,
        muted: muted.default
      }),
      hovered: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "hovered",
        solid: solid.default,
        muted: muted.default
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "readOnly",
        solid: solid.default,
        muted: muted.default
      })
    }
  };
}
function createMutedTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "selected"
      })
    },
    transparent: {
      enabled: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "selected"
      })
    },
    primary: {
      enabled: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "selected"
      })
    },
    positive: {
      enabled: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "selected"
      })
    },
    caution: {
      enabled: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "selected"
      })
    },
    critical: {
      enabled: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "selected"
      })
    }
  };
}
function createSelectableTones(opts, base, dark, solid, muted) {
  return {
    default: _createSelectableStates(opts, base, dark, solid, muted, "default"),
    primary: _createSelectableStates(opts, base, dark, solid, muted, "primary"),
    positive: _createSelectableStates(opts, base, dark, solid, muted, "positive"),
    caution: _createSelectableStates(opts, base, dark, solid, muted, "caution"),
    critical: _createSelectableStates(opts, base, dark, solid, muted, "critical")
  };
}
function _createSelectableStates(opts, base, dark, solid, muted, tone) {
  return {
    enabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "enabled",
      tone
    }),
    hovered: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "hovered",
      tone
    }),
    pressed: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "pressed",
      tone
    }),
    selected: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "selected",
      tone
    }),
    disabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "disabled",
      tone
    })
  };
}
function createSolidTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "selected"
      })
    },
    transparent: {
      enabled: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "selected"
      })
    },
    primary: {
      enabled: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "selected"
      })
    },
    positive: {
      enabled: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "selected"
      })
    },
    caution: {
      enabled: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "selected"
      })
    },
    critical: {
      enabled: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "selected"
      })
    }
  };
}
function createSpot(opts, base, dark) {
  return {
    gray: opts.spot({
      base,
      dark,
      key: "gray"
    }),
    blue: opts.spot({
      base,
      dark,
      key: "blue"
    }),
    purple: opts.spot({
      base,
      dark,
      key: "purple"
    }),
    magenta: opts.spot({
      base,
      dark,
      key: "magenta"
    }),
    red: opts.spot({
      base,
      dark,
      key: "red"
    }),
    orange: opts.spot({
      base,
      dark,
      key: "orange"
    }),
    yellow: opts.spot({
      base,
      dark,
      key: "yellow"
    }),
    green: opts.spot({
      base,
      dark,
      key: "green"
    }),
    cyan: opts.spot({
      base,
      dark,
      key: "cyan"
    })
  };
}
function createColorTheme() {
  let partialOpts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const builders = {
    ...defaultOpts,
    ...partialOpts
  };
  return {
    light: _createColorScheme(builders, false),
    dark: _createColorScheme(builders, true)
  };
}
function _createColorScheme(opts, dark) {
  return {
    default: _createColor(opts, dark, "default"),
    transparent: _createColor(opts, dark, "transparent"),
    primary: _createColor(opts, dark, "primary"),
    positive: _createColor(opts, dark, "positive"),
    caution: _createColor(opts, dark, "caution"),
    critical: _createColor(opts, dark, "critical")
  };
}
function _createColor(opts, dark, name) {
  const base = opts.base({
    dark,
    name
  });
  const solid = createSolidTones(opts, base, dark, name);
  const muted = createMutedTones(opts, base, dark, name);
  return {
    base,
    button: createButtonModes(opts, base, dark, solid, muted),
    card: createCardStates(opts, base, dark, name, solid, muted),
    dark,
    input: createInputModes(opts, base, dark, solid, muted),
    selectable: createSelectableTones(opts, base, dark, solid, muted),
    spot: createSpot(opts, base, dark),
    syntax: opts.syntax({
      base,
      dark
    }),
    solid,
    muted
  };
}
function multiply(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex = rgbToHex(multiply$1(b, s));
  return hex;
}
function screen(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex = rgbToHex(screen$1(b, s));
  return hex;
}
const tones = {
  default: color$1.hues.gray,
  transparent: color$1.hues.gray,
  primary: color$1.hues.blue,
  positive: color$1.hues.green,
  caution: color$1.hues.yellow,
  critical: color$1.hues.red
};
const NEUTRAL_TONES = ["default", "transparent"];
const color = createColorTheme({
  base: _ref11 => {
    let {
      dark,
      name
    } = _ref11;
    if (name === "default") {
      const tints2 = color$1.hues.gray;
      const skeletonFrom2 = dark ? tints2[900].hex : tints2[100].hex;
      return {
        fg: dark ? color$1.white.hex : color$1.black.hex,
        bg: dark ? color$1.black.hex : color$1.white.hex,
        border: tints2[dark ? 800 : 200].hex,
        focusRing: color$1.hues.blue[dark ? 500 : 500].hex,
        shadow: {
          outline: rgba(tints2[500].hex, 0.4),
          umbra: dark ? rgba(tints2[950].hex, 0.4) : rgba(tints2[500].hex, 0.2),
          penumbra: dark ? rgba(tints2[950].hex, 0.28) : rgba(tints2[500].hex, 0.14),
          ambient: dark ? rgba(tints2[950].hex, 0.24) : rgba(tints2[500].hex, 0.12)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (name === "transparent") {
      const tints2 = tones.default;
      const skeletonFrom2 = tints2[dark ? 800 : 200].hex;
      return {
        fg: tints2[dark ? 100 : 900].hex,
        bg: tints2[dark ? 950 : 50].hex,
        border: tints2[dark ? 800 : 300].hex,
        focusRing: color$1.hues.blue[500].hex,
        shadow: {
          outline: rgba(tints2[500].hex, 0.4),
          umbra: dark ? rgba(tints2[900].hex, 0.4) : rgba(tints2[500].hex, 0.2),
          penumbra: dark ? rgba(tints2[900].hex, 0.28) : rgba(tints2[500].hex, 0.14),
          ambient: dark ? rgba(tints2[900].hex, 0.24) : rgba(tints2[500].hex, 0.12)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    const tints = tones[name] || tones.default;
    const skeletonFrom = tints[dark ? 800 : 200].hex;
    return {
      fg: tints[dark ? 100 : 900].hex,
      bg: tints[dark ? 950 : 50].hex,
      border: tints[dark ? 800 : 200].hex,
      focusRing: tints[500].hex,
      shadow: {
        outline: rgba(tints[500].hex, 0.4),
        umbra: dark ? rgba(tints[900].hex, 0.4) : rgba(tints[500].hex, 0.2),
        penumbra: dark ? rgba(tints[900].hex, 0.28) : rgba(tints[500].hex, 0.14),
        ambient: dark ? rgba(tints[900].hex, 0.24) : rgba(tints[500].hex, 0.12)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  solid: _ref12 => {
    let {
      base,
      dark,
      name,
      state,
      tone
    } = _ref12;
    const mix = dark ? screen : multiply;
    const mix2 = dark ? multiply : screen;
    const defaultTints = tones[name] || tones.default;
    const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
    let tints = tones[tone === "default" ? name : tone] || defaultTints;
    if (state === "disabled") {
      tints = defaultTints;
      const bg2 = mix(base.bg, tints[dark ? 800 : 200].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 800 : 200].hex),
        fg: mix(base.bg, dark ? color$1.black.hex : color$1.white.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        accent: {
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        link: {
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        code: {
          bg: bg2,
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "hovered") {
      const bg2 = mix(base.bg, tints[dark ? 300 : 600].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 300 : 600].hex),
        fg: mix(base.bg, dark ? color$1.black.hex : color$1.white.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix2(bg2, color$1.hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix2(bg2, color$1.hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "pressed") {
      const bg2 = mix(base.bg, tints[dark ? 200 : 800].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: mix(base.bg, tints[dark ? 200 : 800].hex),
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 200 : 800].hex),
        fg: mix(base.bg, dark ? color$1.black.hex : color$1.white.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix2(bg2, color$1.hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix2(bg2, color$1.hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "selected") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix(base.bg, tints[dark ? 200 : 800].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 200 : 800].hex),
        fg: mix(base.bg, dark ? color$1.black.hex : color$1.white.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix2(bg2, color$1.hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix2(bg2, color$1.hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    const bg = mix(base.bg, tints[dark ? 400 : 500].hex);
    const skeletonFrom = mix2(bg, tints[dark ? 200 : 800].hex);
    return {
      bg,
      bg2: mix2(bg, tints[dark ? 50 : 950].hex),
      border: mix(base.bg, tints[dark ? 400 : 500].hex),
      fg: mix(base.bg, dark ? color$1.black.hex : color$1.white.hex),
      muted: {
        fg: mix(base.bg, tints[dark ? 900 : 100].hex)
      },
      accent: {
        fg: mix2(bg, color$1.hues.red[dark ? 900 : 100].hex)
      },
      link: {
        fg: mix2(bg, color$1.hues.blue[dark ? 900 : 100].hex)
      },
      code: {
        bg: mix(bg, tints[dark ? 950 : 50].hex),
        fg: mix(base.bg, tints[dark ? 900 : 100].hex)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  muted: _ref13 => {
    let {
      base,
      dark,
      name,
      state,
      tone
    } = _ref13;
    const mix = dark ? screen : multiply;
    const defaultTints = tones[name] || tones.default;
    const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
    let tints = tones[tone === "default" ? name : tone] || defaultTints;
    if (state === "disabled") {
      tints = defaultTints;
      const bg2 = base.bg;
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 950 : 50].hex),
        fg: mix(bg2, tints[dark ? 800 : 200].hex),
        muted: {
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        accent: {
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        link: {
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        code: {
          bg: bg2,
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        skeleton: {
          from: rgba(skeletonFrom2, 0.5),
          to: rgba(skeletonFrom2, 0.25)
        }
      };
    }
    if (state === "hovered") {
      const bg2 = mix(base.bg, tints[dark ? 950 : 50].hex);
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 900 : 100].hex),
        fg: mix(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix(base.bg, color$1.hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix(base.bg, color$1.hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "pressed") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix(base.bg, tints[dark ? 900 : 100].hex);
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 900 : 100].hex),
        fg: mix(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix(bg2, color$1.hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix(bg2, color$1.hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "selected") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix(base.bg, tints[dark ? 900 : 100].hex);
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 900 : 100].hex),
        fg: mix(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix(bg2, color$1.hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix(bg2, color$1.hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    const bg = base.bg;
    const skeletonFrom = mix(bg, tints[dark ? 900 : 100].hex);
    return {
      bg,
      bg2: mix(bg, tints[dark ? 950 : 50].hex),
      border: mix(bg, tints[dark ? 900 : 100].hex),
      fg: mix(base.bg, tints[dark ? 300 : 700].hex),
      muted: {
        fg: mix(base.bg, tints[dark ? 400 : 600].hex)
      },
      accent: {
        fg: mix(base.bg, color$1.hues.red[dark ? 400 : 500].hex)
      },
      link: {
        fg: mix(base.bg, color$1.hues.blue[dark ? 400 : 600].hex)
      },
      code: {
        bg: mix(base.bg, tints[dark ? 950 : 50].hex),
        fg: mix(base.bg, tints[dark ? 400 : 600].hex)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  button: _ref14 => {
    let {
      base,
      mode,
      muted,
      solid
    } = _ref14;
    if (mode === "bleed") {
      return {
        enabled: {
          ...muted.enabled,
          border: muted.enabled.bg
        },
        hovered: {
          ...muted.hovered,
          border: muted.hovered.bg
        },
        pressed: {
          ...muted.pressed,
          border: muted.pressed.bg
        },
        selected: {
          ...muted.selected,
          border: muted.selected.bg
        },
        disabled: {
          ...muted.disabled,
          border: muted.disabled.bg
        }
      };
    }
    if (mode === "ghost") {
      return {
        ...solid,
        enabled: {
          ...muted.enabled,
          border: base.border
        },
        disabled: muted.disabled
      };
    }
    return solid;
  },
  card: _ref15 => {
    let {
      base,
      dark,
      muted,
      name,
      solid,
      state
    } = _ref15;
    if (state === "hovered") {
      return muted[name].hovered;
    }
    if (state === "disabled") {
      return muted[name].disabled;
    }
    const isNeutral = NEUTRAL_TONES.includes(name);
    const tints = tones[name] || tones.default;
    const mix = dark ? screen : multiply;
    if (state === "pressed") {
      if (isNeutral) {
        return muted.primary.pressed;
      }
      return muted[name].pressed;
    }
    if (state === "selected") {
      if (isNeutral) {
        return solid.primary.enabled;
      }
      return solid[name].enabled;
    }
    const bg = base.bg;
    const skeletonFrom = mix(base.bg, tints[dark ? 900 : 100].hex);
    return {
      bg,
      bg2: mix(bg, tints[dark ? 950 : 50].hex),
      fg: base.fg,
      border: base.border,
      muted: {
        fg: mix(base.bg, tints[dark ? 400 : 600].hex)
      },
      accent: {
        fg: mix(base.bg, color$1.hues.red[dark ? 400 : 500].hex)
      },
      link: {
        fg: mix(base.bg, color$1.hues.blue[dark ? 400 : 600].hex)
      },
      code: {
        bg: mix(base.bg, tints[dark ? 950 : 50].hex),
        fg: tints[dark ? 400 : 600].hex
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  input: _ref16 => {
    let {
      base,
      dark,
      mode,
      state
    } = _ref16;
    const mix = dark ? screen : multiply;
    if (mode === "invalid") {
      const tints = tones.critical;
      return {
        bg: mix(base.bg, tints[dark ? 950 : 50].hex),
        fg: mix(base.bg, tints[dark ? 400 : 600].hex),
        border: mix(base.bg, tints[dark ? 800 : 200].hex),
        placeholder: mix(base.bg, tints[dark ? 600 : 400].hex)
      };
    }
    if (state === "hovered") {
      return {
        bg: base.bg,
        fg: base.fg,
        border: mix(base.bg, color$1.hues.gray[dark ? 700 : 300].hex),
        placeholder: mix(base.bg, color$1.hues.gray[dark ? 600 : 400].hex)
      };
    }
    if (state === "disabled") {
      return {
        bg: mix(base.bg, color$1.hues.gray[dark ? 950 : 50].hex),
        fg: mix(base.bg, color$1.hues.gray[dark ? 700 : 300].hex),
        border: mix(base.bg, color$1.hues.gray[dark ? 900 : 100].hex),
        placeholder: mix(base.bg, color$1.hues.gray[dark ? 800 : 200].hex)
      };
    }
    if (state === "readOnly") {
      return {
        bg: mix(base.bg, color$1.hues.gray[dark ? 950 : 50].hex),
        fg: mix(base.bg, color$1.hues.gray[dark ? 200 : 800].hex),
        border: mix(base.bg, color$1.hues.gray[dark ? 800 : 200].hex),
        placeholder: mix(base.bg, color$1.hues.gray[dark ? 600 : 400].hex)
      };
    }
    return {
      bg: base.bg,
      fg: base.fg,
      border: base.border,
      placeholder: mix(base.bg, color$1.hues.gray[dark ? 600 : 400].hex)
    };
  },
  selectable: _ref17 => {
    let {
      base,
      muted,
      tone,
      solid,
      state
    } = _ref17;
    if (state === "enabled") {
      return {
        ...muted[tone].enabled,
        bg: base.bg
      };
    }
    if (state === "pressed") {
      if (tone === "default") {
        return muted.primary.pressed;
      }
      return muted[tone].pressed;
    }
    if (state === "selected") {
      if (tone === "default") {
        return solid.primary.enabled;
      }
      return solid[tone].enabled;
    }
    if (state === "disabled") {
      return {
        ...muted[tone].disabled,
        bg: base.bg
      };
    }
    return muted[tone][state];
  },
  spot: _ref18 => {
    let {
      base,
      dark,
      key
    } = _ref18;
    const mix = dark ? screen : multiply;
    return mix(base.bg, color$1.hues[key][dark ? 400 : 500].hex);
  },
  syntax: _ref19 => {
    let {
      base,
      dark
    } = _ref19;
    const mix = dark ? screen : multiply;
    const mainShade = dark ? 400 : 600;
    const secondaryShade = dark ? 600 : 400;
    return {
      atrule: mix(base.bg, color$1.hues.purple[mainShade].hex),
      attrName: mix(base.bg, color$1.hues.green[mainShade].hex),
      attrValue: mix(base.bg, color$1.hues.yellow[mainShade].hex),
      attribute: mix(base.bg, color$1.hues.yellow[mainShade].hex),
      boolean: mix(base.bg, color$1.hues.purple[mainShade].hex),
      builtin: mix(base.bg, color$1.hues.purple[mainShade].hex),
      cdata: mix(base.bg, color$1.hues.yellow[mainShade].hex),
      char: mix(base.bg, color$1.hues.yellow[mainShade].hex),
      class: mix(base.bg, color$1.hues.orange[mainShade].hex),
      className: mix(base.bg, color$1.hues.cyan[mainShade].hex),
      comment: mix(base.bg, color$1.hues.gray[secondaryShade].hex),
      constant: mix(base.bg, color$1.hues.purple[mainShade].hex),
      deleted: mix(base.bg, color$1.hues.red[mainShade].hex),
      doctype: mix(base.bg, color$1.hues.gray[secondaryShade].hex),
      entity: mix(base.bg, color$1.hues.red[mainShade].hex),
      function: mix(base.bg, color$1.hues.green[mainShade].hex),
      hexcode: mix(base.bg, color$1.hues.blue[mainShade].hex),
      id: mix(base.bg, color$1.hues.purple[mainShade].hex),
      important: mix(base.bg, color$1.hues.purple[mainShade].hex),
      inserted: mix(base.bg, color$1.hues.yellow[mainShade].hex),
      keyword: mix(base.bg, color$1.hues.magenta[mainShade].hex),
      number: mix(base.bg, color$1.hues.purple[mainShade].hex),
      operator: mix(base.bg, color$1.hues.magenta[mainShade].hex),
      prolog: mix(base.bg, color$1.hues.gray[secondaryShade].hex),
      property: mix(base.bg, color$1.hues.blue[mainShade].hex),
      pseudoClass: mix(base.bg, color$1.hues.yellow[mainShade].hex),
      pseudoElement: mix(base.bg, color$1.hues.yellow[mainShade].hex),
      punctuation: mix(base.bg, color$1.hues.gray[mainShade].hex),
      regex: mix(base.bg, color$1.hues.blue[mainShade].hex),
      selector: mix(base.bg, color$1.hues.red[mainShade].hex),
      string: mix(base.bg, color$1.hues.yellow[mainShade].hex),
      symbol: mix(base.bg, color$1.hues.purple[mainShade].hex),
      tag: mix(base.bg, color$1.hues.red[mainShade].hex),
      unit: mix(base.bg, color$1.hues.orange[mainShade].hex),
      url: mix(base.bg, color$1.hues.red[mainShade].hex),
      variable: mix(base.bg, color$1.hues.red[mainShade].hex)
    };
  }
});
const fonts = {
  code: {
    family: "ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace",
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [{
      ascenderHeight: 3,
      descenderHeight: 3,
      fontSize: 10,
      iconSize: 17,
      lineHeight: 13,
      letterSpacing: 0
    }, {
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 13,
      iconSize: 21,
      lineHeight: 17,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 21,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 19,
      iconSize: 29,
      lineHeight: 25,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 22,
      iconSize: 33,
      lineHeight: 29,
      letterSpacing: 0
    }]
  },
  heading: {
    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 700,
      medium: 800,
      semibold: 900,
      bold: 900
    },
    sizes: [{
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 12,
      iconSize: 17,
      lineHeight: 17,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 21,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 21,
      iconSize: 33,
      lineHeight: 27,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 27,
      iconSize: 41,
      lineHeight: 33,
      letterSpacing: 0
    }, {
      ascenderHeight: 8,
      descenderHeight: 8,
      fontSize: 33,
      iconSize: 49,
      lineHeight: 39,
      letterSpacing: 0
    }, {
      ascenderHeight: 9,
      descenderHeight: 9,
      fontSize: 38,
      iconSize: 53,
      lineHeight: 45,
      letterSpacing: 0
    }]
  },
  label: {
    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", system-ui, sans-serif',
    weights: {
      regular: 600,
      medium: 700,
      semibold: 800,
      bold: 900
    },
    sizes: [{
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 9.8,
      iconSize: 15,
      lineHeight: 11,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 11.25,
      iconSize: 17,
      lineHeight: 12,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 12.75,
      iconSize: 19,
      lineHeight: 13,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 14,
      iconSize: 21,
      lineHeight: 14,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 15.5,
      iconSize: 23,
      lineHeight: 15,
      letterSpacing: 0.5
    }]
  },
  text: {
    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [{
      ascenderHeight: 3,
      descenderHeight: 3,
      fontSize: 10,
      iconSize: 17,
      lineHeight: 13,
      letterSpacing: 0
    }, {
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 13,
      iconSize: 21,
      lineHeight: 17,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 21,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 19,
      iconSize: 29,
      lineHeight: 25,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 22,
      iconSize: 33,
      lineHeight: 29,
      letterSpacing: 0
    }]
  }
};
const studioTheme = {
  avatar: {
    sizes: [{
      distance: -3,
      size: 25
    }, {
      distance: -6,
      size: 35
    }, {
      distance: -9,
      size: 55
    }]
  },
  button: {
    textWeight: "medium"
  },
  color,
  container: [320, 640, 960, 1280, 1600, 1920],
  focusRing: {
    offset: 1,
    width: 2
  },
  fonts,
  media: [360, 600, 900, 1200, 1800, 2400],
  radius: [0, 1, 3, 6, 9, 12, 21],
  shadows: [null, {
    umbra: [0, 0, 0, 0],
    penumbra: [0, 0, 0, 0],
    ambient: [0, 0, 0, 0]
  }, {
    umbra: [0, 3, 5, -1],
    penumbra: [0, 6, 10, 0],
    ambient: [0, 1, 18, 0]
  }, {
    umbra: [0, 7, 8, -4],
    penumbra: [0, 12, 17, 2],
    ambient: [0, 5, 22, 4]
  }, {
    umbra: [0, 9, 11, -5],
    penumbra: [0, 18, 28, 2],
    ambient: [0, 7, 34, 6]
  }, {
    umbra: [0, 11, 15, -7],
    penumbra: [0, 24, 38, 3],
    ambient: [0, 9, 46, 8]
  }],
  space: [0, 4, 8, 12, 20, 32, 52, 84, 136, 220],
  input: {
    checkbox: {
      size: 17
    },
    radio: {
      size: 17,
      markSize: 9
    },
    switch: {
      width: 33,
      height: 17,
      padding: 4,
      transitionDurationMs: 150,
      transitionTimingFunction: "ease-out"
    },
    border: {
      width: 1
    }
  }
  // styles: {
  //   button: {
  //     root: {
  //       transition: 'background-color 100ms,border-color 100ms,color 100ms',
  //     },
  //   },
  //   card: {
  //     root: {
  //       transition: 'background-color 100ms,border-color 100ms,color 100ms',
  //     },
  //   },
  // },
};

const DEFAULT_THEME_LAYER = {
  dialog: {
    zOffset: 600
  },
  popover: {
    zOffset: 400
  },
  tooltip: {
    zOffset: 200
  }
};
function getGlobalScope() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof window !== "undefined") return window;
  if (typeof self !== "undefined") return self;
  if (typeof global !== "undefined") return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
const globalScope = getGlobalScope();
const key$8 = Symbol.for("@sanity/ui/context/theme");
globalScope[key$8] = globalScope[key$8] || react.createContext(null);
const ThemeContext = globalScope[key$8];
function ThemeProvider(props) {
  const parentTheme = react.useContext(ThemeContext);
  const {
    children,
    scheme = (parentTheme == null ? void 0 : parentTheme.scheme) || "light",
    theme: themeProp = (parentTheme == null ? void 0 : parentTheme.theme) || null,
    tone = (parentTheme == null ? void 0 : parentTheme.tone) || "default"
  } = props;
  const theme = react.useMemo(() => {
    if (!themeProp) return null;
    const {
      color: rootColor,
      layer: rootLayer,
      ...restTheme
    } = themeProp;
    const colorScheme = rootColor[scheme] || rootColor.light;
    const color = colorScheme[tone] || colorScheme.default;
    const layer = rootLayer || DEFAULT_THEME_LAYER;
    return {
      sanity: {
        ...restTheme,
        color,
        layer
      }
    };
  }, [scheme, themeProp, tone]);
  const value = react.useMemo(() => themeProp && {
    version: 0,
    theme: themeProp,
    scheme,
    tone
  }, [themeProp, scheme, tone]);
  if (!theme) {
    return /* @__PURE__ */jsxRuntime.jsx("pre", {
      children: 'ThemeProvider: no "theme" property provided'
    });
  }
  return /* @__PURE__ */jsxRuntime.jsx(ThemeContext.Provider, {
    value,
    children: /* @__PURE__ */jsxRuntime.jsx(styled.ThemeProvider, {
      theme,
      children
    })
  });
}
function isRecord(value) {
  return Boolean(value && typeof value === "object");
}
function useRootTheme() {
  const value = react.useContext(ThemeContext);
  if (!value) {
    throw new Error("useRootTheme(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("useRootTheme(): the context value is not compatible");
  }
  return value;
}
function ThemeColorProvider(props) {
  const {
    children,
    scheme,
    tone
  } = props;
  const root = useRootTheme();
  return /* @__PURE__ */jsxRuntime.jsx(ThemeProvider, {
    scheme: scheme || root.scheme,
    theme: root.theme,
    tone,
    children
  });
}
function useTheme() {
  return styled.useTheme();
}
const MEDIA_STORE_CACHE = /* @__PURE__ */new WeakMap();
function _getMediaQuery(media, index) {
  if (index === 0) {
    return "screen and (max-width: ".concat(media[index] - 1, "px)");
  }
  if (index === media.length) {
    return "screen and (min-width: ".concat(media[index - 1], "px)");
  }
  return "screen and (min-width: ".concat(media[index - 1], "px) and (max-width: ").concat(media[index] - 1, "px)");
}
function _createMediaStore(media) {
  const mediaLen = media.length;
  let sizes;
  const getSizes = () => {
    if (!sizes) {
      sizes = [];
      for (let index = mediaLen; index > -1; index -= 1) {
        const mediaQuery = _getMediaQuery(media, index);
        sizes.push({
          index,
          mq: window.matchMedia(mediaQuery)
        });
      }
    }
    return sizes;
  };
  const getSnapshot = () => {
    for (const {
      index,
      mq
    } of getSizes()) {
      if (mq.matches) return index;
    }
    return 0;
  };
  const subscribe = onStoreChange => {
    const disposeFns = [];
    for (const {
      mq
    } of getSizes()) {
      const handleChange = () => {
        if (mq.matches) onStoreChange();
      };
      mq.addEventListener("change", handleChange);
      disposeFns.push(() => mq.removeEventListener("change", handleChange));
    }
    return () => {
      for (const disposeFn of disposeFns) {
        disposeFn();
      }
    };
  };
  return {
    getSnapshot,
    subscribe
  };
}
function getServerSnapshot$2() {
  return 0;
}
function useMediaIndex() {
  const theme = useTheme();
  const {
    media
  } = theme.sanity;
  let store = MEDIA_STORE_CACHE.get(media);
  if (!store) {
    store = _createMediaStore(media);
    MEDIA_STORE_CACHE.set(media, store);
  }
  return react.useSyncExternalStore(store.subscribe, store.getSnapshot, getServerSnapshot$2);
}
let MEDIA_QUERY_CACHE$1;
function getMatchMedia$1() {
  if (!MEDIA_QUERY_CACHE$1) {
    MEDIA_QUERY_CACHE$1 = window.matchMedia("(prefers-color-scheme: dark)");
  }
  return MEDIA_QUERY_CACHE$1;
}
function subscribe$1(onStoreChange) {
  const matchMedia = getMatchMedia$1();
  matchMedia.addEventListener("change", onStoreChange);
  return () => matchMedia.removeEventListener("change", onStoreChange);
}
function getSnapshot$1() {
  return getMatchMedia$1().matches;
}
function getServerSnapshot$1() {
  return false;
}
function usePrefersDark() {
  return react.useSyncExternalStore(subscribe$1, getSnapshot$1, getServerSnapshot$1);
}
let MEDIA_QUERY_CACHE;
function getMatchMedia() {
  if (!MEDIA_QUERY_CACHE) {
    MEDIA_QUERY_CACHE = window.matchMedia("(prefers-reduced-motion: reduce)");
  }
  return MEDIA_QUERY_CACHE;
}
function subscribe(onStoreChange) {
  const matchMedia = getMatchMedia();
  matchMedia.addEventListener("change", onStoreChange);
  return () => matchMedia.removeEventListener("change", onStoreChange);
}
function getSnapshot() {
  return getMatchMedia().matches;
}
function getServerSnapshot() {
  return false;
}
function usePrefersReducedMotion() {
  return react.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
}
const useIsomorphicEffect = typeof window !== "undefined" ? react.useLayoutEffect : react.useEffect;
function useForwardedRef(ref) {
  const innerRef = react.useRef(null);
  useIsomorphicEffect(() => {
    if (!ref) return;
    if (typeof ref === "function") {
      ref(innerRef.current);
    } else {
      ref.current = innerRef.current;
    }
  });
  return innerRef;
}
function useCustomValidity(ref, customValidity) {
  react.useEffect(() => {
    if (ref.current) {
      ref.current.setCustomValidity(customValidity || "");
    }
  }, [customValidity, ref]);
}
const BORDER_VALUE = "1px solid var(--card-border-color)";
function responsiveBorderStyle() {
  return [border, borderTop, borderRight, borderBottom, borderLeft];
}
function border(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$border, value => value ? {
    "&&": {
      border: BORDER_VALUE
    }
  } : {
    "&&": {
      border: 0
    }
  });
}
function borderTop(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderTop, value => value ? {
    "&&": {
      borderTop: BORDER_VALUE
    }
  } : {
    "&&": {
      borderTop: 0
    }
  });
}
function borderRight(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderRight, value => value ? {
    "&&": {
      borderRight: BORDER_VALUE
    }
  } : {
    "&&": {
      borderRight: 0
    }
  });
}
function borderBottom(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderBottom, value => value ? {
    "&&": {
      borderBottom: BORDER_VALUE
    }
  } : {
    "&&": {
      borderBottom: 0
    }
  });
}
function borderLeft(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderLeft, value => value ? {
    "&&": {
      borderLeft: BORDER_VALUE
    }
  } : {
    "&&": {
      borderLeft: 0
    }
  });
}
const BASE_STYLE$4 = {
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
const BOX_SIZING = {
  content: "content-box",
  border: "border-box"
};
const BOX_HEIGHT = {
  stretch: "stretch",
  fill: "100%"
};
function boxStyle() {
  return BASE_STYLE$4;
}
function responsiveBoxStyle() {
  return [responsiveBoxSizingStyle, responsiveBoxHeightStyle, responsiveBoxOverflowStyle, responsiveBoxDisplayStyle];
}
function responsiveBoxDisplayStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$display, display => ({
    "&:not([hidden])": {
      display
    }
  }));
}
function responsiveBoxSizingStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$sizing, sizing => ({
    boxSizing: BOX_SIZING[sizing]
  }));
}
function responsiveBoxHeightStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$height, height => ({
    height: BOX_HEIGHT[height]
  }));
}
function responsiveBoxOverflowStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$overflow, overflow => ({
    overflow
  }));
}
const BASE_STYLE$3 = {
  "&&:not([hidden])": {
    display: "flex"
  }
};
function responsiveFlexStyle() {
  return [BASE_STYLE$3, responsiveFlexAlignStyle, responsiveFlexGapStyle, responsiveFlexWrapStyle, responsiveFlexJustifyStyle, responsiveFlexDirectionStyle];
}
function responsiveFlexAlignStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$align, align => {
    return {
      alignItems: align
    };
  });
}
function responsiveFlexGapStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gap, gap => ({
    gap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveFlexWrapStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$wrap, wrap => {
    return {
      flexWrap: wrap
    };
  });
}
function responsiveFlexJustifyStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$justify, justify => {
    return {
      justifyContent: justify
    };
  });
}
function responsiveFlexDirectionStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$direction, direction => {
    return {
      flexDirection: direction
    };
  });
}
const BASE_STYLE$2 = {
  minWidth: 0,
  minHeight: 0
};
function flexItemStyle() {
  return [BASE_STYLE$2, responsiveFlexItemStyle];
}
function responsiveFlexItemStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  if (!props.$flex) return EMPTY_ARRAY;
  return _responsive(media, props.$flex, flex => ({
    flex
  }));
}
function focusRingBorderStyle(border) {
  return "inset 0 0 0 ".concat(border.width, "px ").concat(border.color);
}
function focusRingStyle(opts) {
  const {
    base,
    border,
    focusRing
  } = opts;
  const focusRingOutsetWidth = focusRing.offset + focusRing.width;
  const focusRingInsetWidth = 0 - focusRing.offset;
  const bgColor = base ? base.bg : "var(--card-bg-color)";
  return [focusRingInsetWidth > 0 && "inset 0 0 0 ".concat(focusRingInsetWidth, "px var(--card-focus-ring-color)"), border && focusRingBorderStyle(border), focusRingInsetWidth < 0 && "0 0 0 ".concat(0 - focusRingInsetWidth, "px ").concat(bgColor), focusRingOutsetWidth > 0 && "0 0 0 ".concat(focusRingOutsetWidth, "px var(--card-focus-ring-color)")].filter(Boolean).join(",");
}
const GRID_CSS = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
const GRID_AUTO_COLUMS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
const GRID_AUTO_ROWS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
function responsiveGridStyle() {
  return [GRID_CSS, responsiveGridAutoFlowStyle, responsiveGridAutoRowsStyle, responsiveGridAutoColsStyle, responsiveGridColumnsStyle, responsiveGridRowsStyle, responsiveGridGapStyle, responsiveGridGapXStyle, responsiveGridGapYStyle];
}
function responsiveGridAutoFlowStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$autoFlow, autoFlow => ({
    gridAutoFlow: autoFlow
  }));
}
function responsiveGridAutoRowsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$autoRows, autoRows => ({
    gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows]
  }));
}
function responsiveGridAutoColsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$autoCols, autoCols => ({
    gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols]
  }));
}
function responsiveGridColumnsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$columns, columns => ({
    gridTemplateColumns: columns && "repeat(".concat(columns, ",minmax(0,1fr));")
  }));
}
function responsiveGridRowsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$rows, rows => ({
    gridTemplateRows: rows && "repeat(".concat(rows, ",minmax(0,1fr));")
  }));
}
function responsiveGridGapStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gap, gap => ({
    gridGap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveGridGapXStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gapX, gapX => ({
    columnGap: gapX ? rem(space[gapX]) : void 0
  }));
}
function responsiveGridGapYStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gapY, gapY => ({
    rowGap: gapY ? rem(space[gapY]) : void 0
  }));
}
function responsiveGridItemStyle() {
  return [responsiveGridItemRowStyle, responsiveGridItemRowStartStyle, responsiveGridItemRowEndStyle, responsiveGridItemColumnStyle, responsiveGridItemColumnStartStyle, responsiveGridItemColumnEndStyle];
}
const GRID_ITEM_ROW = {
  auto: "auto",
  full: "1 / -1"
};
const GRID_ITEM_COLUMN = {
  auto: "auto",
  full: "1 / -1"
};
function responsiveGridItemRowStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$row, row => {
    if (typeof row === "number") {
      return {
        gridRow: "span ".concat(row, " / span ").concat(row)
      };
    }
    return {
      gridRow: GRID_ITEM_ROW[row]
    };
  });
}
function responsiveGridItemRowStartStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$rowStart, rowStart => ({
    gridRowStart: rowStart
  }));
}
function responsiveGridItemRowEndStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$rowEnd, rowEnd => ({
    gridRowEnd: rowEnd
  }));
}
function responsiveGridItemColumnStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$column, column => {
    if (typeof column === "number") {
      return {
        gridColumn: "span ".concat(column, " / span ").concat(column)
      };
    }
    return {
      gridColumn: GRID_ITEM_COLUMN[column]
    };
  });
}
function responsiveGridItemColumnStartStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$columnStart, columnStart => ({
    gridColumnStart: columnStart
  }));
}
function responsiveGridItemColumnEndStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$columnEnd, columnEnd => ({
    gridColumnEnd: columnEnd
  }));
}
function responsiveInputPaddingStyle(props) {
  const {
    $fontSize,
    $iconLeft,
    $iconRight,
    $padding,
    $space,
    theme
  } = props;
  const {
    fonts,
    media,
    space: spaceScale
  } = theme.sanity;
  const len = Math.max($padding.length, $space.length, $fontSize.length);
  const _padding = [];
  const _space = [];
  const _fontSize = [];
  for (let i = 0; i < len; i += 1) {
    _fontSize[i] = $fontSize[i] === void 0 ? _fontSize[i - 1] : $fontSize[i];
    _padding[i] = $padding[i] === void 0 ? _padding[i - 1] : $padding[i];
    _space[i] = $space[i] === void 0 ? _space[i - 1] : $space[i];
  }
  return _responsive(media, _padding, (_, i) => {
    const size = fonts.text.sizes[_fontSize[i]] || fonts.text.sizes[2];
    const emSize = size.lineHeight - size.ascenderHeight - size.descenderHeight;
    const p = spaceScale[_padding[i]];
    const s = spaceScale[_space[i]];
    const styles = {
      paddingTop: rem(p - size.ascenderHeight),
      paddingRight: rem(p),
      paddingBottom: rem(p - size.descenderHeight),
      paddingLeft: rem(p)
    };
    if ($iconRight) styles.paddingRight = rem(p + emSize + s);
    if ($iconLeft) styles.paddingLeft = rem(p + emSize + s);
    return styles;
  });
}
function responsiveInputPaddingIconRightStyle(props) {
  return responsiveInputPaddingStyle({
    ...props,
    $iconRight: true
  });
}
var __freeze$D = Object.freeze;
var __defProp$E = Object.defineProperty;
var __template$D = (cooked, raw) => __freeze$D(__defProp$E(cooked, "raw", {
  value: __freeze$D(raw || cooked.slice())
}));
var _a$D, _b$m, _c$d;
const ROOT_STYLE = styled.css(_a$D || (_a$D = __template$D(["\n  &:not([hidden]) {\n    display: flex;\n  }\n\n  align-items: center;\n"])));
function textInputRootStyle() {
  return ROOT_STYLE;
}
function textInputBaseStyle(props) {
  const {
    theme,
    $scheme,
    $tone,
    $weight
  } = props;
  const font = theme.sanity.fonts.text;
  const color = theme.sanity.color.input;
  return styled.css(_b$m || (_b$m = __template$D(["\n    appearance: none;\n    background: none;\n    border: 0;\n    border-radius: 0;\n    outline: none;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: ", ";\n    font-weight: ", ";\n    margin: 0;\n    position: relative;\n    z-index: 1;\n    display: block;\n\n    /* NOTE: This is a hack to disable Chrome\u2019s autofill styles */\n    &:-webkit-autofill,\n    &:-webkit-autofill:hover,\n    &:-webkit-autofill:focus,\n    &:-webkit-autofill:active {\n      -webkit-text-fill-color: var(--input-fg-color) !important;\n      transition: background-color 5000s;\n      transition-delay: 86400s /* 24h */;\n    }\n\n    /* &:is(textarea) */\n    &[data-as='textarea'] {\n      resize: none;\n    }\n\n    color: var(--input-fg-color);\n\n    &::placeholder {\n      color: var(--input-placeholder-color);\n    }\n\n    &[data-scheme='", "'][data-tone='", "'] {\n      --input-fg-color: ", ";\n      --input-placeholder-color: ", ";\n\n      /* enabled */\n      &:not(:invalid):not(:disabled):not(:read-only) {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* disabled */\n      &:not(:invalid):disabled {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* invalid */\n      &:invalid {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* readOnly */\n      &:read-only {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n    }\n  "])), font.family, $weight && font.weights[$weight] || font.weights.regular, $scheme, $tone, color.default.enabled.fg, color.default.enabled.placeholder, color.default.enabled.fg, color.default.enabled.placeholder, color.default.disabled.fg, color.default.disabled.placeholder, color.invalid.enabled.fg, color.invalid.enabled.placeholder, color.default.readOnly.fg, color.default.readOnly.placeholder);
}
function textInputFontSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    fonts,
    media
  } = theme.sanity;
  return _responsive(media, props.$fontSize, sizeIndex => {
    const size = fonts.text.sizes[sizeIndex] || fonts.text.sizes[2];
    return {
      fontSize: rem(size.fontSize),
      lineHeight: size.lineHeight / size.fontSize
    };
  });
}
function textInputRepresentationStyle(props) {
  const {
    $hasPrefix,
    $hasSuffix,
    $scheme,
    $tone,
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color = theme.sanity.color.input;
  return styled.css(_c$d || (_c$d = __template$D(["\n    --input-box-shadow: none;\n\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    display: block;\n    pointer-events: none;\n    z-index: 0;\n\n    background-color: var(--card-bg-color);\n    box-shadow: var(--input-box-shadow);\n\n    border-top-left-radius: ", ";\n    border-bottom-left-radius: ", ";\n    border-top-right-radius: ", ";\n    border-bottom-right-radius: ", ";\n\n    &[data-scheme='", "'][data-tone='", "'] {\n      --card-bg-color: ", ";\n      --card-fg-color: ", ";\n\n      /* enabled */\n      *:not(:disabled) + &[data-border] {\n        --input-box-shadow: ", ";\n      }\n\n      /* invalid */\n      *:not(:disabled):invalid + & {\n        --card-bg-color: ", ";\n        --card-fg-color: ", ";\n\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* focused */\n      *:not(:disabled):focus + & {\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n\n        &:not([data-border]) {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* disabled */\n      *:disabled + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* readOnly */\n      *:read-only + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n      }\n\n      /* hovered */\n      @media (hover: hover) {\n        *:not(:disabled):not(:read-only):not(:invalid):hover + & {\n          --card-bg-color: ", ";\n          --card-fg-color: ", ";\n        }\n\n        *:not(:disabled):not(:read-only):not(:invalid):not(:focus):hover + &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n    }\n  "])), $hasPrefix ? 0 : void 0, $hasPrefix ? 0 : void 0, $hasSuffix ? 0 : void 0, $hasSuffix ? 0 : void 0, $scheme, $tone, color.default.enabled.bg, color.default.enabled.fg, focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), color.invalid.enabled.bg, color.invalid.enabled.fg, focusRingBorderStyle({
    color: color.invalid.enabled.border,
    width: input.border.width
  }), focusRingStyle({
    border: {
      color: color.default.enabled.border,
      width: input.border.width
    },
    focusRing
  }), focusRingStyle({
    focusRing
  }), color.default.disabled.bg, color.default.disabled.fg, focusRingBorderStyle({
    color: color.default.disabled.border,
    width: input.border.width
  }), color.default.readOnly.bg, color.default.readOnly.fg, color.default.hovered.bg, color.default.hovered.fg, focusRingBorderStyle({
    color: color.default.hovered.border,
    width: input.border.width
  }));
}
function responsiveMarginStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["margin"], props.$margin), _getResponsiveSpace(theme, ["marginLeft", "marginRight"], props.$marginX), _getResponsiveSpace(theme, ["marginTop", "marginBottom"], props.$marginY), _getResponsiveSpace(theme, ["marginTop"], props.$marginTop), _getResponsiveSpace(theme, ["marginRight"], props.$marginRight), _getResponsiveSpace(theme, ["marginBottom"], props.$marginBottom), _getResponsiveSpace(theme, ["marginLeft"], props.$marginLeft)].filter(Boolean);
}
function responsivePaddingStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["padding"], props.$padding), _getResponsiveSpace(theme, ["paddingLeft", "paddingRight"], props.$paddingX), _getResponsiveSpace(theme, ["paddingTop", "paddingBottom"], props.$paddingY), _getResponsiveSpace(theme, ["paddingTop"], props.$paddingTop), _getResponsiveSpace(theme, ["paddingRight"], props.$paddingRight), _getResponsiveSpace(theme, ["paddingBottom"], props.$paddingBottom), _getResponsiveSpace(theme, ["paddingLeft"], props.$paddingLeft)].filter(Boolean);
}
function responsiveRadiusStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    radius
  } = theme.sanity;
  return _responsive(media, props.$radius, radiusIndex => ({
    borderRadius: rem(radius[radiusIndex])
  }));
}
function toBoxShadow(shadow, color) {
  return "".concat(shadow.map(rem).join(" "), " ").concat(color);
}
function shadowStyle(shadow) {
  if (!shadow) return EMPTY_RECORD;
  const outline = "0 0 0 ".concat(rem(1), " var(--card-shadow-outline-color)");
  const umbra = toBoxShadow(shadow.umbra, "var(--card-shadow-umbra-color)");
  const penumbra = toBoxShadow(shadow.penumbra, "var(--card-shadow-penumbra-color)");
  const ambient = toBoxShadow(shadow.ambient, "var(--card-shadow-ambient-color)");
  return {
    boxShadow: "".concat(outline, ", ").concat(umbra, ", ").concat(penumbra, ", ").concat(ambient)
  };
}
function responsiveShadowStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    shadows
  } = theme.sanity;
  return _responsive(media, props.$shadow, shadow => shadowStyle(shadows[shadow]));
}
var __freeze$C = Object.freeze;
var __defProp$D = Object.defineProperty;
var __template$C = (cooked, raw) => __freeze$C(__defProp$D(cooked, "raw", {
  value: __freeze$C(raw || cooked.slice())
}));
var _a$C, _b$l, _c$c;
function textBaseStyle(props) {
  const {
    $accent,
    $muted,
    theme
  } = props;
  const {
    weights
  } = theme.sanity.fonts.text;
  return styled.css(_c$c || (_c$c = __template$C(["\n    color: var(--card-fg-color);\n\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n      background-color: var(--card-code-bg-color);\n      color: var(--card-code-fg-color);\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n      color: var(--card-link-color);\n      outline: none;\n\n      @media (hover: hover) {\n        &:hover {\n          text-decoration: underline;\n        }\n      }\n\n      &:focus {\n        box-shadow:\n          0 0 0 1px var(--card-bg-color),\n          0 0 0 3px var(--card-focus-ring-color);\n      }\n\n      &:focus:not(:focus-visible) {\n        box-shadow: none;\n      }\n    }\n\n    & strong {\n      font-weight: ", ";\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && styled.css(_a$C || (_a$C = __template$C(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && styled.css(_b$l || (_b$l = __template$C(["\n      color: var(--card-muted-fg-color);\n    "]))), theme.sanity.fonts.code.family, weights.bold);
}
var __freeze$B = Object.freeze;
var __defProp$C = Object.defineProperty;
var __template$B = (cooked, raw) => __freeze$B(__defProp$C(cooked, "raw", {
  value: __freeze$B(raw || cooked.slice())
}));
var _a$B;
const Root$E = styled__default.default.div(responsiveTextFont, responsiveTextAlignStyle, textBaseStyle);
const SpanWithTextOverflow$2 = styled__default.default.span(_a$B || (_a$B = __template$B(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
const Text = react.forwardRef(function Text2(props, ref) {
  const {
    accent = false,
    align,
    children: childrenProp,
    muted = false,
    size = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = /* @__PURE__ */jsxRuntime.jsx(SpanWithTextOverflow$2, {
      children
    });
  }
  return /* @__PURE__ */jsxRuntime.jsx(Root$E, {
    "data-ui": "Text",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    ref,
    $size: useArrayProp(size),
    $weight: weight,
    children: /* @__PURE__ */jsxRuntime.jsx("span", {
      children
    })
  });
});
const avatarStyle = {
  root: avatarRootStyle,
  arrow: avatarArrowStyle,
  bgStroke: avatarBgStrokeStyle,
  stroke: avatarStrokeStyle,
  initials: avatarInitialsStyle
};
function avatarArrowStyle() {
  return {
    position: "absolute",
    boxSizing: "border-box",
    zIndex: 0,
    opacity: 0,
    transition: "all 0.2s linear",
    transform: "rotate(-90deg) translate3d(0, 6px, 0)",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    "& > svg": {
      width: "11px",
      height: "7px",
      position: "absolute",
      top: "-5px",
      left: "50%",
      transform: "translateX(-6px)",
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:not([hidden])": {
        display: "block"
      }
    },
    "[data-arrow-position='inside'] > &": {
      transform: "rotate(-90deg) translate3d(0, 6px, 0)",
      opacity: 0
    },
    "[data-arrow-position='top'] > &": {
      opacity: 1,
      transform: "rotate(0deg)"
    },
    "[data-arrow-position='bottom'] > &": {
      opacity: 1,
      transform: "rotate(-180deg)"
    }
  };
}
function avatarRootStyle(props) {
  const {
    $color,
    theme
  } = props;
  const {
    focusRing
  } = theme.sanity;
  return {
    backgroundColor: $color,
    position: "relative",
    boxSizing: "border-box",
    userSelect: "none",
    boxShadow: "0 0 0 1px var(--card-bg-color)",
    '&[data-status="inactive"]': {
      opacity: 0.5
    },
    "&>svg": {
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:not([hidden])": {
        display: "block"
      }
    },
    /* &:is(button) */
    '&[data-as="button"]': {
      WebkitFontSmoothing: "inherit",
      appearance: "none",
      margin: 0,
      padding: 0,
      border: 0,
      font: "inherit",
      color: "inherit",
      outline: "none",
      // @ts-expect-error -- TODO wait for CSSObject types to be fixed in `styled-components` itself
      "&:focus": {
        boxShadow: focusRingStyle({
          focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: "none"
      }
    }
  };
}
function responsiveAvatarSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props.$size, size => {
    const avatarSize = avatar.sizes[size] || avatar.sizes[0];
    return {
      width: rem(avatarSize.size),
      height: rem(avatarSize.size),
      borderRadius: rem(avatarSize.size / 2),
      "&>svg": {
        width: rem(avatarSize.size),
        height: rem(avatarSize.size),
        borderRadius: rem(avatarSize.size / 2)
      }
    };
  });
}
function avatarInitialsStyle(props) {
  const {
    theme
  } = props;
  const {
    base
  } = theme.sanity.color;
  return {
    width: "100%",
    height: "100%",
    color: base.fg,
    alignItems: "center",
    justifyContent: "center",
    textTransform: "uppercase",
    textAlign: "center",
    borderRadius: "50%",
    "&:not([hidden])": {
      display: "flex"
    }
  };
}
function avatarBgStrokeStyle() {
  return {
    strokeWidth: "4px",
    stroke: "var(--card-bg-color)"
  };
}
function avatarStrokeStyle() {
  return {
    strokeWidth: "3px",
    '[data-status="editing"] &': {
      strokeDasharray: "2 4",
      strokeLinecap: "round"
    }
  };
}
const Root$D = styled__default.default.div(responsiveAvatarSizeStyle, avatarStyle.root);
const Arrow = styled__default.default.div(avatarStyle.arrow);
const BgStroke = styled__default.default.ellipse(avatarStyle.bgStroke);
const Stroke = styled__default.default.ellipse(avatarStyle.stroke);
const Initials = styled__default.default.div(avatarStyle.initials);
const Avatar = react.forwardRef(function Avatar2(props, ref) {
  const {
    as: asProp,
    color: colorKey = "gray",
    src,
    title,
    initials,
    onImageLoadError,
    arrowPosition: arrowPositionProp,
    animateArrowFrom,
    status = "online",
    size: sizeProp = 0,
    ...restProps
  } = props;
  const as = ReactIs__default.default.isValidElementType(asProp) ? asProp : "div";
  const size = useArrayProp(sizeProp);
  const theme = useTheme();
  const color = theme.sanity.color.spot[colorKey] || theme.sanity.color.spot.gray;
  const avatarSize = theme.sanity.avatar.sizes[size[0]] || theme.sanity.avatar.sizes[0];
  const _sizeRem = avatarSize.size;
  const _radius = _sizeRem / 2;
  const elementId = react.useId();
  const [arrowPosition, setArrowPosition] = react.useState(animateArrowFrom || arrowPositionProp || "inside");
  const [imageFailed, setImageFailed] = react.useState(false);
  const imageId = "avatar-image-".concat(elementId);
  react.useEffect(() => {
    if (arrowPosition === arrowPositionProp) return void 0;
    const raf = requestAnimationFrame(() => setArrowPosition(arrowPositionProp));
    return () => cancelAnimationFrame(raf);
  }, [arrowPosition, arrowPositionProp]);
  react.useEffect(() => {
    if (src) setImageFailed(false);
  }, [src]);
  const handleImageError = react.useCallback(() => {
    setImageFailed(true);
    if (onImageLoadError) {
      onImageLoadError(new Error("Avatar: the image failed to load"));
    }
  }, [onImageLoadError]);
  const initialsSize = react.useMemo(() => size.map(s => s === 0 ? 0 : s + 1), [size]);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$D, {
    as,
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Avatar",
    ...restProps,
    $size: size,
    $color: color,
    "aria-label": title,
    "data-arrow-position": arrowPosition,
    "data-status": status,
    ref,
    title,
    children: [/* @__PURE__ */jsxRuntime.jsx(Arrow, {
      children: /* @__PURE__ */jsxRuntime.jsx("svg", {
        width: "11",
        height: "7",
        viewBox: "0 0 11 7",
        fill: "none",
        children: /* @__PURE__ */jsxRuntime.jsx("path", {
          d: "M6.67948 1.50115L11 7L0 7L4.32052 1.50115C4.92109 0.736796 6.07891 0.736795 6.67948 1.50115Z",
          fill: color
        })
      })
    }), !imageFailed && src && /* @__PURE__ */jsxRuntime.jsxs("svg", {
      viewBox: "0 0 ".concat(_sizeRem, " ").concat(_sizeRem),
      fill: "none",
      children: [/* @__PURE__ */jsxRuntime.jsx("defs", {
        children: /* @__PURE__ */jsxRuntime.jsx("pattern", {
          id: imageId,
          patternContentUnits: "objectBoundingBox",
          width: "1",
          height: "1",
          children: /* @__PURE__ */jsxRuntime.jsx("image", {
            href: src,
            width: "1",
            height: "1",
            onError: handleImageError
          })
        })
      }), /* @__PURE__ */jsxRuntime.jsx("circle", {
        cx: _radius,
        cy: _radius,
        r: _radius,
        fill: "url(#".concat(imageId, ")")
      }), /* @__PURE__ */jsxRuntime.jsx(BgStroke, {
        cx: _radius,
        cy: _radius,
        rx: _radius,
        ry: _radius,
        vectorEffect: "non-scaling-stroke"
      }), /* @__PURE__ */jsxRuntime.jsx(Stroke, {
        cx: _radius,
        cy: _radius,
        rx: _radius,
        ry: _radius,
        stroke: color,
        vectorEffect: "non-scaling-stroke"
      })]
    }), (imageFailed || !src) && initials && /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
      children: /* @__PURE__ */jsxRuntime.jsx(Initials, {
        children: /* @__PURE__ */jsxRuntime.jsx(Text, {
          as: "span",
          size: initialsSize,
          children: /* @__PURE__ */jsxRuntime.jsx("strong", {
            children: initials
          })
        })
      })
    })]
  });
});
var __freeze$A = Object.freeze;
var __defProp$B = Object.defineProperty;
var __template$A = (cooked, raw) => __freeze$A(__defProp$B(cooked, "raw", {
  value: __freeze$A(raw || cooked.slice())
}));
var _a$A;
function _responsiveAvatarCounterSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props.$size, size => {
    const avatarSize = avatar.sizes[size];
    if (!avatarSize) return EMPTY_RECORD;
    return {
      borderRadius: rem(avatarSize.size / 2),
      minWidth: rem(avatarSize.size),
      height: rem(avatarSize.size)
    };
  });
}
function _avatarCounterBaseStyle(props) {
  const {
    theme
  } = props;
  return styled.css(_a$A || (_a$A = __template$A(["\n    align-items: center;\n    justify-content: center;\n    box-sizing: border-box;\n    user-select: none;\n    color: inherit;\n    color: var(--card-fg-color);\n    background: var(--card-bg-color);\n    box-shadow:\n      0 0 0 1px var(--card-bg-color),\n      inset 0 0 0 1.5px var(--card-hairline-hard-color);\n    padding: 0 ", ";\n\n    &:not([hidden]) {\n      display: flex;\n    }\n  "])), rem(theme.sanity.space[2]));
}
const Root$C = styled__default.default.div(_responsiveAvatarCounterSizeStyle, _avatarCounterBaseStyle);
const AvatarCounter = react.forwardRef(function AvatarCounter2(props, ref) {
  const {
    count,
    size: sizeProp = 0
  } = props;
  const size = useArrayProp(sizeProp);
  const counterSize = react.useMemo(() => size.map(s => s === 0 ? 0 : s + 1), [size]);
  return /* @__PURE__ */jsxRuntime.jsx(Root$C, {
    $size: size,
    "data-ui": "AvatarCounter",
    ref,
    children: /* @__PURE__ */jsxRuntime.jsx(Text, {
      as: "span",
      size: counterSize,
      children: /* @__PURE__ */jsxRuntime.jsx("strong", {
        children: count
      })
    })
  });
});
function childrenToElementArray(children) {
  const childrenArray = Array.isArray(children) ? children : [children];
  return childrenArray.filter(node => ReactIs.isElement(node) || ReactIs.isFragment(node) || typeof node === "string");
}
var __freeze$z = Object.freeze;
var __defProp$A = Object.defineProperty;
var __template$z = (cooked, raw) => __freeze$z(__defProp$A(cooked, "raw", {
  value: __freeze$z(raw || cooked.slice())
}));
var _a$z;
const BASE_STYLES = styled.css(_a$z || (_a$z = __template$z(["\n  white-space: nowrap;\n\n  & > div {\n    vertical-align: top;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  }\n"])));
function avatarStackStyle() {
  return BASE_STYLES;
}
function responsiveAvatarStackSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props.$size, size => {
    const avatarSize = avatar.sizes[size];
    if (!avatarSize) return EMPTY_RECORD;
    return {
      "& > div + div": {
        marginLeft: rem(avatarSize.distance)
      }
    };
  });
}
const Root$B = styled__default.default.div(responsiveAvatarStackSizeStyle, avatarStackStyle);
const AvatarStack = react.forwardRef(function AvatarStack2(props, ref) {
  const {
    children: childrenProp,
    maxLength: maxLengthProp = 4,
    size: sizeProp = 0,
    ...restProps
  } = props;
  const children = childrenToElementArray(childrenProp).filter(child => typeof child !== "string");
  const maxLength = Math.max(maxLengthProp, 0);
  const size = useArrayProp(sizeProp);
  const len = children.length;
  const visibleCount = maxLength - 1;
  const extraCount = len - visibleCount;
  const visibleChildren = extraCount > 1 ? children.slice(extraCount, len) : children;
  return /* @__PURE__ */jsxRuntime.jsxs(Root$B, {
    "data-ui": "AvatarStack",
    ...restProps,
    ref,
    $size: size,
    children: [len === 0 && /* @__PURE__ */jsxRuntime.jsx("div", {
      children: /* @__PURE__ */jsxRuntime.jsx(AvatarCounter, {
        count: len
      })
    }), len !== 0 && extraCount > 1 && /* @__PURE__ */jsxRuntime.jsx("div", {
      children: /* @__PURE__ */jsxRuntime.jsx(AvatarCounter, {
        count: extraCount,
        size
      })
    }), visibleChildren.map((child, childIndex) => /* @__PURE__ */jsxRuntime.jsx("div", {
      children: react.cloneElement(child, {
        size
      })
    }, String(childIndex)))]
  });
});
const Root$A = styled__default.default.div(boxStyle, flexItemStyle, responsiveBoxStyle, responsiveGridItemStyle, responsiveMarginStyle, responsivePaddingStyle);
const Box = react.forwardRef(function Box2(props, ref) {
  const {
    as: asProp = "div",
    column,
    columnStart,
    columnEnd,
    display = "block",
    flex,
    height,
    margin = 0,
    marginX,
    marginY,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    overflow,
    padding = 0,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    row,
    rowStart,
    rowEnd,
    sizing,
    ...restProps
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(Root$A, {
    "data-as": typeof asProp === "string" ? asProp : void 0,
    "data-ui": "Box",
    ...restProps,
    $column: useArrayProp(column),
    $columnStart: useArrayProp(columnStart),
    $columnEnd: useArrayProp(columnEnd),
    $display: useArrayProp(display),
    $flex: useArrayProp(flex),
    $height: useArrayProp(height),
    $margin: useArrayProp(margin),
    $marginX: useArrayProp(marginX),
    $marginY: useArrayProp(marginY),
    $marginTop: useArrayProp(marginTop),
    $marginRight: useArrayProp(marginRight),
    $marginBottom: useArrayProp(marginBottom),
    $marginLeft: useArrayProp(marginLeft),
    $overflow: useArrayProp(overflow),
    $padding: useArrayProp(padding),
    $paddingX: useArrayProp(paddingX),
    $paddingY: useArrayProp(paddingY),
    $paddingTop: useArrayProp(paddingTop),
    $paddingRight: useArrayProp(paddingRight),
    $paddingBottom: useArrayProp(paddingBottom),
    $paddingLeft: useArrayProp(paddingLeft),
    $row: useArrayProp(row),
    $rowStart: useArrayProp(rowStart),
    $rowEnd: useArrayProp(rowEnd),
    $sizing: useArrayProp(sizing),
    as: asProp,
    ref,
    children: props.children
  });
});
var __freeze$y = Object.freeze;
var __defProp$z = Object.defineProperty;
var __template$y = (cooked, raw) => __freeze$y(__defProp$z(cooked, "raw", {
  value: __freeze$y(raw || cooked.slice())
}));
var _a$y, _b$k, _c$b;
function labelBaseStyle(props) {
  const {
    $accent,
    $muted,
    theme
  } = props;
  const {
    fonts
  } = theme.sanity;
  return styled.css(_c$b || (_c$b = __template$y(["\n    text-transform: uppercase;\n\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && styled.css(_a$y || (_a$y = __template$y(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && styled.css(_b$k || (_b$k = __template$y(["\n      color: var(--card-muted-fg-color);\n    "]))), fonts.code.family);
}
var __freeze$x = Object.freeze;
var __defProp$y = Object.defineProperty;
var __template$x = (cooked, raw) => __freeze$x(__defProp$y(cooked, "raw", {
  value: __freeze$x(raw || cooked.slice())
}));
var _a$x;
const Root$z = styled__default.default.div(responsiveLabelFont, responsiveTextAlignStyle, labelBaseStyle);
const SpanWithTextOverflow$1 = styled__default.default.span(_a$x || (_a$x = __template$x(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
const Label = react.forwardRef(function Label2(props, ref) {
  const {
    accent,
    align,
    children: childrenProp,
    muted = false,
    size = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = /* @__PURE__ */jsxRuntime.jsx(SpanWithTextOverflow$1, {
      children
    });
  } else {
    children = /* @__PURE__ */jsxRuntime.jsx("span", {
      children
    });
  }
  return /* @__PURE__ */jsxRuntime.jsx(Root$z, {
    "data-ui": "Label",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    $size: useArrayProp(size),
    $weight: weight,
    ref,
    children
  });
});
function badgeStyle(props) {
  const {
    $mode,
    $tone,
    theme
  } = props;
  const palette = theme.sanity.color[$mode === "outline" ? "muted" : "solid"];
  const color = palette[$tone] || palette.default;
  return {
    backgroundColor: color.enabled.bg,
    color: color.enabled.fg,
    boxShadow: "inset 0 0 0 1px ".concat(color.enabled.border),
    cursor: "default",
    "&:not([hidden])": {
      display: "inline-block"
    }
  };
}
const Root$y = styled__default.default(Box)(responsiveRadiusStyle, badgeStyle);
const Badge = react.forwardRef(function Badge2(props, ref) {
  const {
    children,
    fontSize,
    mode = "default",
    padding = 1,
    radius = 2,
    tone = "default",
    ...restProps
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(Root$y, {
    "data-ui": "Badge",
    ...restProps,
    $mode: mode,
    $tone: tone,
    $radius: useArrayProp(radius),
    padding: useArrayProp(padding),
    ref,
    children: /* @__PURE__ */jsxRuntime.jsx(Label, {
      size: fontSize,
      children
    })
  });
});
const Root$x = styled__default.default(Box)(flexItemStyle, responsiveFlexStyle);
const Flex = react.forwardRef(function Flex2(props, ref) {
  const {
    align,
    as,
    direction = "row",
    gap,
    justify,
    wrap,
    ...restProps
  } = props;
  return (
    // @ts-expect-error -- some dollar prefixed typings aren't inferred correctly https://github.com/styled-components/styled-components/issues/4062
    /* @__PURE__ */
    jsxRuntime.jsx(Root$x, {
      "data-ui": "Flex",
      ...restProps,
      $align: useArrayProp(align),
      $direction: useArrayProp(direction),
      $gap: useArrayProp(gap),
      $justify: useArrayProp(justify),
      $wrap: useArrayProp(wrap),
      forwardedAs: as,
      ref
    })
  );
});
var __freeze$w = Object.freeze;
var __defProp$x = Object.defineProperty;
var __template$w = (cooked, raw) => __freeze$w(__defProp$x(cooked, "raw", {
  value: __freeze$w(raw || cooked.slice())
}));
var _a$w, _b$j;
const rotate$1 = styled.keyframes(_a$w || (_a$w = __template$w(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"])));
const Root$w = styled__default.default(Text)(_b$j || (_b$j = __template$w(["\n  & > span > svg {\n    animation: ", " 500ms linear infinite;\n  }\n"])), rotate$1);
const Spinner = react.forwardRef(function Spinner2(props, ref) {
  return /* @__PURE__ */jsxRuntime.jsx(Root$w, {
    "data-ui": "Spinner",
    ...props,
    ref,
    children: /* @__PURE__ */jsxRuntime.jsx(icons.SpinnerIcon, {})
  });
});
function _colorVarsStyle(base, color) {
  let checkered = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var _a, _b, _c, _d, _e, _f, _g, _h;
  return {
    // Base
    // @todo: rename to "--base-"?
    "--card-shadow-outline-color": base.shadow.outline,
    "--card-shadow-umbra-color": base.shadow.umbra,
    "--card-shadow-penumbra-color": base.shadow.penumbra,
    "--card-shadow-ambient-color": base.shadow.ambient,
    "--card-focus-ring-color": base.focusRing,
    // Card
    "--card-bg-color": color.bg,
    "--card-bg-image": checkered ? "repeating-conic-gradient(".concat(color.bg, " 0% 25%, ").concat(color.bg2 || color.bg, " 0% 50%)") : void 0,
    "--card-fg-color": color.fg,
    "--card-border-color": color.border,
    "--card-muted-fg-color": (_a = color.muted) == null ? void 0 : _a.fg,
    "--card-accent-fg-color": (_b = color.accent) == null ? void 0 : _b.fg,
    "--card-link-fg-color": (_c = color.link) == null ? void 0 : _c.fg,
    "--card-code-bg-color": (_d = color.code) == null ? void 0 : _d.bg,
    "--card-code-fg-color": (_e = color.code) == null ? void 0 : _e.fg,
    "--card-skeleton-color-from": (_f = color.skeleton) == null ? void 0 : _f.from,
    "--card-skeleton-color-to": (_g = color.skeleton) == null ? void 0 : _g.to,
    // @todo: deprecate
    "--card-link-color": (_h = color.link) == null ? void 0 : _h.fg,
    "--card-hairline-soft-color": color.border,
    "--card-hairline-hard-color": color.border
  };
}
var __freeze$v = Object.freeze;
var __defProp$w = Object.defineProperty;
var __template$v = (cooked, raw) => __freeze$v(__defProp$w(cooked, "raw", {
  value: __freeze$v(raw || cooked.slice())
}));
var _a$v;
function buttonBaseStyles() {
  return styled.css(_a$v || (_a$v = __template$v(["\n    -webkit-font-smoothing: inherit;\n    appearance: none;\n    display: inline-flex;\n    align-items: center;\n    font: inherit;\n    border: 0;\n    outline: none;\n    user-select: none;\n    text-decoration: none;\n    border: 0;\n    box-sizing: border-box;\n    padding: 0;\n    margin: 0;\n    white-space: nowrap;\n    text-align: left;\n    position: relative;\n\n    & > span {\n      display: block;\n      flex: 1;\n      min-width: 0;\n      border-radius: inherit;\n    }\n\n    &::-moz-focus-inner {\n      border: 0;\n      padding: 0;\n    }\n  "])));
}
const buttonTheme = {
  border: {
    width: 1
  }
};
function buttonColorStyles(props) {
  var _a2, _b;
  const {
    $mode,
    theme
  } = props;
  const {
    focusRing
  } = theme.sanity;
  const base = theme.sanity.color.base;
  const mode = theme.sanity.color.button[$mode] || theme.sanity.color.button.default;
  const color = mode[props.$tone] || mode.default;
  const border = {
    width: buttonTheme.border.width,
    color: "var(--card-border-color)"
  };
  return [_colorVarsStyle(base, color.enabled), {
    backgroundColor: "var(--card-bg-color)",
    color: "var(--card-fg-color)",
    boxShadow: focusRingBorderStyle(border),
    '&:disabled, &[data-disabled="true"]': _colorVarsStyle(base, color.disabled),
    "&:not([data-disabled='true'])": {
      "&:focus": {
        boxShadow: focusRingStyle({
          base,
          border,
          focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: focusRingBorderStyle(border)
      },
      "@media (hover: hover)": {
        "&:hover": _colorVarsStyle(base, color.hovered),
        "&:active": _colorVarsStyle(base, color.pressed),
        "&[data-hovered]": _colorVarsStyle(base, color.hovered)
      },
      "&[data-selected]": _colorVarsStyle(base, color.pressed)
    }
  }, (_b = (_a2 = theme.sanity.styles) == null ? void 0 : _a2.button) == null ? void 0 : _b.root].filter(Boolean);
}
var __freeze$u = Object.freeze;
var __defProp$v = Object.defineProperty;
var __template$u = (cooked, raw) => __freeze$u(__defProp$v(cooked, "raw", {
  value: __freeze$u(raw || cooked.slice())
}));
var _a$u;
const Root$v = styled__default.default.button(responsiveRadiusStyle, buttonBaseStyles, buttonColorStyles);
const LoadingBox = styled__default.default.div(_a$u || (_a$u = __template$u(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background-color: var(--card-bg-color);\n  border-radius: inherit;\n  z-index: 1;\n  box-shadow: inherit;\n"])));
const Button = react.forwardRef(function Button2(props, ref) {
  const {
    children,
    disabled,
    fontSize,
    icon,
    iconRight,
    justify: justifyProp = "center",
    loading,
    mode = "default",
    padding: paddingProp = 3,
    paddingX: paddingXProp,
    paddingY: paddingYProp,
    paddingTop: paddingTopProp,
    paddingBottom: paddingBottomProp,
    paddingLeft: paddingLeftProp,
    paddingRight: paddingRightProp,
    radius: radiusProp = 2,
    selected,
    space: spaceProp = 3,
    text,
    textAlign,
    tone = "default",
    type = "button",
    ...restProps
  } = props;
  const justify = useArrayProp(justifyProp);
  const padding = useArrayProp(paddingProp);
  const paddingX = useArrayProp(paddingXProp);
  const paddingY = useArrayProp(paddingYProp);
  const paddingTop = useArrayProp(paddingTopProp);
  const paddingBottom = useArrayProp(paddingBottomProp);
  const paddingLeft = useArrayProp(paddingLeftProp);
  const paddingRight = useArrayProp(paddingRightProp);
  const radius = useArrayProp(radiusProp);
  const space = useArrayProp(spaceProp);
  const theme = useTheme();
  const boxProps = react.useMemo(() => ({
    // flex: 1,
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight
  }), [padding, paddingX, paddingY, paddingTop, paddingBottom, paddingLeft, paddingRight]);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$v, {
    "data-ui": "Button",
    ...restProps,
    $mode: mode,
    $radius: radius,
    $tone: tone,
    "data-disabled": Boolean(loading || disabled),
    "data-selected": selected ? "" : void 0,
    disabled: Boolean(loading || disabled),
    ref,
    type,
    children: [Boolean(loading) && /* @__PURE__ */jsxRuntime.jsx(LoadingBox, {
      children: /* @__PURE__ */jsxRuntime.jsx(Spinner, {})
    }), (icon || text || iconRight) && /* @__PURE__ */jsxRuntime.jsx(Box, {
      as: "span",
      ...boxProps,
      children: /* @__PURE__ */jsxRuntime.jsxs(Flex, {
        as: "span",
        justify,
        children: [icon && /* @__PURE__ */jsxRuntime.jsxs(Text, {
          size: fontSize,
          children: [react.isValidElement(icon) && icon, ReactIs.isValidElementType(icon) && react.createElement(icon)]
        }), text && /* @__PURE__ */jsxRuntime.jsx(Box, {
          flex: iconRight ? 1 : void 0,
          marginLeft: icon ? space : void 0,
          marginRight: iconRight ? space : void 0,
          children: /* @__PURE__ */jsxRuntime.jsx(Text, {
            align: textAlign,
            size: fontSize,
            textOverflow: "ellipsis",
            weight: theme.sanity.button.textWeight,
            children: text
          })
        }), iconRight && /* @__PURE__ */jsxRuntime.jsxs(Text, {
          size: fontSize,
          children: [react.isValidElement(iconRight) && iconRight, ReactIs.isValidElementType(iconRight) && react.createElement(iconRight)]
        })]
      })
    }), children && /* @__PURE__ */jsxRuntime.jsx(Box, {
      as: "span",
      ...boxProps,
      children
    })]
  });
});
var __freeze$t = Object.freeze;
var __defProp$u = Object.defineProperty;
var __template$t = (cooked, raw) => __freeze$t(__defProp$u(cooked, "raw", {
  value: __freeze$t(raw || cooked.slice())
}));
var _a$t, _b$i, _c$a;
function cardStyle(props) {
  return [cardBaseStyle(props), cardColorStyle(props)];
}
function cardBaseStyle(props) {
  const {
    $checkered,
    theme
  } = props;
  const space = theme.sanity.space;
  return styled.css(_b$i || (_b$i = __template$t(["\n    ", "\n\n    &[data-as='button'] {\n      -webkit-font-smoothing: inherit;\n      appearance: none;\n      outline: none;\n      font: inherit;\n      text-align: inherit;\n      border: 0;\n      width: -webkit-fill-available;\n      width: stretch;\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      outline: none;\n      text-decoration: none;\n    }\n\n    /* &:is(pre) */\n    &[data-as='pre'] {\n      font: inherit;\n    }\n  "])), $checkered && styled.css(_a$t || (_a$t = __template$t(["\n      background-size: ", "px ", "px;\n      background-position: 50% 50%;\n      background-image: var(--card-bg-image);\n    "])), space[3], space[3]));
}
function cardColorStyle(props) {
  var _a2, _b2;
  const {
    $checkered,
    $focusRing,
    theme
  } = props;
  const {
    focusRing
  } = theme.sanity;
  const {
    base,
    card,
    dark
  } = theme.sanity.color;
  const border = {
    width: 0,
    color: "var(--card-border-color)"
  };
  return styled.css(_c$a || (_c$a = __template$t(["\n    color-scheme: ", ";\n\n    ", "\n\n    background-color: var(--card-bg-color);\n    color: var(--card-fg-color);\n\n    /* &:is(button) */\n    &[data-as='button'] {\n      --card-focus-ring-box-shadow: none;\n\n      cursor: default;\n      box-shadow: var(--card-focus-ring-box-shadow);\n\n      &:disabled {\n        ", "\n      }\n\n      &:not(:disabled) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-pressed]):not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n\n        &:focus {\n          --card-focus-ring-box-shadow: ", ";\n        }\n\n        &:focus:not(:focus-visible) {\n          --card-focus-ring-box-shadow: ", ";\n        }\n      }\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      cursor: pointer;\n      box-shadow: var(--card-focus-ring-box-shadow);\n\n      &[data-disabled] {\n        ", "\n      }\n\n      &:not([data-disabled]) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-pressed]):not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n\n        &:focus {\n          --card-focus-ring-box-shadow: ", ";\n        }\n\n        &:focus:not(:focus-visible) {\n          --card-focus-ring-box-shadow: ", ";\n        }\n      }\n    }\n\n    ", "\n  "])), dark ? "dark" : "light", _colorVarsStyle(base, card.enabled, $checkered), _colorVarsStyle(base, card.disabled, $checkered), _colorVarsStyle(base, card.pressed, $checkered), _colorVarsStyle(base, card.selected, $checkered), _colorVarsStyle(base, card.hovered, $checkered), _colorVarsStyle(base, card.pressed, $checkered), $focusRing ? focusRingStyle({
    base,
    border,
    focusRing
  }) : void 0, $focusRing ? focusRingBorderStyle(border) : void 0, _colorVarsStyle(base, card.disabled, $checkered), _colorVarsStyle(base, card.pressed, $checkered), _colorVarsStyle(base, card.selected, $checkered), _colorVarsStyle(base, card.hovered, $checkered), _colorVarsStyle(base, card.pressed, $checkered), $focusRing ? focusRingStyle({
    base,
    border,
    focusRing
  }) : void 0, $focusRing ? focusRingBorderStyle(border) : void 0, (_b2 = (_a2 = theme.sanity.styles) == null ? void 0 : _a2.card) == null ? void 0 : _b2.root);
}
const Root$u = styled__default.default(Box)(responsiveBorderStyle, responsiveRadiusStyle, responsiveShadowStyle, cardStyle);
const Card = react.forwardRef(function Card2(props, ref) {
  const {
    __unstable_checkered: checkered = false,
    __unstable_focusRing: focusRing = false,
    as: asProp,
    border,
    borderTop,
    borderRight,
    borderBottom,
    borderLeft,
    pressed,
    radius = 0,
    scheme,
    selected,
    shadow,
    tone: toneProp = "default",
    ...restProps
  } = props;
  const as = ReactIs.isValidElementType(asProp) ? asProp : "div";
  const rootTheme = useRootTheme();
  const tone = toneProp === "inherit" ? rootTheme.tone : toneProp;
  return /* @__PURE__ */jsxRuntime.jsx(ThemeColorProvider, {
    scheme,
    tone,
    children: /* @__PURE__ */jsxRuntime.jsx(Root$u, {
      "data-as": typeof as === "string" ? as : void 0,
      "data-scheme": rootTheme.scheme,
      "data-ui": "Card",
      "data-tone": tone,
      ...restProps,
      $border: useArrayProp(border),
      $borderTop: useArrayProp(borderTop),
      $borderRight: useArrayProp(borderRight),
      $borderBottom: useArrayProp(borderBottom),
      $borderLeft: useArrayProp(borderLeft),
      $checkered: checkered,
      $focusRing: focusRing,
      $radius: useArrayProp(radius),
      $shadow: useArrayProp(shadow),
      $tone: tone,
      "data-checkered": checkered ? "" : void 0,
      "data-pressed": pressed ? "" : void 0,
      "data-selected": selected ? "" : void 0,
      forwardedAs: as,
      ref,
      selected
    })
  });
});
var __freeze$s = Object.freeze;
var __defProp$t = Object.defineProperty;
var __template$s = (cooked, raw) => __freeze$s(__defProp$t(cooked, "raw", {
  value: __freeze$s(raw || cooked.slice())
}));
var _a$s, _b$h;
function checkboxBaseStyles() {
  return styled.css(_a$s || (_a$s = __template$s(["\n    position: relative;\n    display: inline-block;\n  "])));
}
function inputElementStyles(props) {
  const {
    theme
  } = props;
  const color = theme.sanity.color.input;
  const {
    focusRing,
    input,
    radius
  } = theme.sanity;
  return styled.css(_b$h || (_b$h = __template$s(["\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    outline: none;\n    opacity: 0;\n    z-index: 1;\n    padding: 0;\n    margin: 0;\n\n    & + span {\n      position: relative;\n      display: block;\n      height: ", ";\n      width: ", ";\n      box-sizing: border-box;\n      box-shadow: ", ";\n      border-radius: ", ";\n      line-height: 1;\n      background-color: ", ";\n\n      & > svg {\n        display: block;\n        position: absolute;\n        opacity: 0;\n        height: 100%;\n        width: 100%;\n\n        & > path {\n          vector-effect: non-scaling-stroke;\n          stroke-width: 2 !important;\n        }\n      }\n    }\n\n    &:not(:disabled):focus + span {\n      box-shadow: ", ";\n    }\n\n    &:not(:disabled):focus:not(:focus-visible) + span {\n      box-shadow: ", ";\n    }\n\n    &:checked + span > svg:first-child {\n      opacity: 1;\n    }\n\n    &[data-read-only] + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n\n    &:not([data-read-only]):disabled + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n\n    &:indeterminate + span > svg:last-child {\n      opacity: 1;\n    }\n  "])), rem(input.checkbox.size), rem(input.checkbox.size), focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), rem(radius[2]), color.default.enabled.bg, focusRingStyle({
    border: {
      width: input.border.width,
      color: color.default.enabled.border
    },
    focusRing
  }), focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), color.default.readOnly.bg, focusRingBorderStyle({
    width: input.border.width,
    color: color.default.readOnly.border
  }), color.default.readOnly.fg, color.default.disabled.bg, focusRingBorderStyle({
    width: input.border.width,
    color: color.default.disabled.border
  }), color.default.disabled.fg);
}
const Root$t = styled__default.default.div(checkboxBaseStyles);
const Input$5 = styled__default.default.input(inputElementStyles);
const Checkbox = react.forwardRef(function Checkbox2(props, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    customValidity,
    readOnly,
    style,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  react.useEffect(() => {
    if (ref.current) {
      ref.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate, ref]);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$t, {
    className,
    "data-ui": "Checkbox",
    style,
    children: [/* @__PURE__ */jsxRuntime.jsx(Input$5, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      checked,
      disabled: disabled || readOnly,
      type: "checkbox",
      readOnly,
      ref
    }), /* @__PURE__ */jsxRuntime.jsxs("span", {
      children: [/* @__PURE__ */jsxRuntime.jsx(icons.CheckmarkIcon, {}), /* @__PURE__ */jsxRuntime.jsx(icons.RemoveIcon, {})]
    })]
  });
});
var __freeze$r = Object.freeze;
var __defProp$s = Object.defineProperty;
var __template$r = (cooked, raw) => __freeze$r(__defProp$s(cooked, "raw", {
  value: __freeze$r(raw || cooked.slice())
}));
var _a$r;
function codeSyntaxHighlightingStyle(_ref20) {
  let {
    theme
  } = _ref20;
  const color = theme.sanity.color.syntax;
  return {
    "&.atrule": {
      color: color.atrule
    },
    "&.attr-name": {
      color: color.attrName
    },
    "&.attr-value": {
      color: color.attrValue
    },
    "&.attribute": {
      color: color.attribute
    },
    "&.boolean": {
      color: color.boolean
    },
    "&.builtin": {
      color: color.builtin
    },
    "&.cdata": {
      color: color.cdata
    },
    "&.char": {
      color: color.char
    },
    "&.class": {
      color: color.class
    },
    "&.class-name": {
      color: color.className
    },
    "&.comment": {
      color: color.comment
    },
    "&.constant": {
      color: color.constant
    },
    "&.deleted": {
      color: color.deleted
    },
    "&.doctype": {
      color: color.doctype
    },
    "&.entity": {
      color: color.entity
    },
    "&.function": {
      color: color.function
    },
    "&.hexcode": {
      color: color.hexcode
    },
    "&.id": {
      color: color.id
    },
    "&.important": {
      color: color.important
    },
    "&.inserted": {
      color: color.inserted
    },
    "&.keyword": {
      color: color.keyword
    },
    "&.number": {
      color: color.number
    },
    "&.operator": {
      color: color.operator
    },
    "&.prolog": {
      color: color.prolog
    },
    "&.property": {
      color: color.property
    },
    "&.pseudo-class": {
      color: color.pseudoClass
    },
    "&.pseudo-element": {
      color: color.pseudoElement
    },
    "&.punctuation": {
      color: color.punctuation
    },
    "&.regex": {
      color: color.regex
    },
    "&.selector": {
      color: color.selector
    },
    "&.string": {
      color: color.string
    },
    "&.symbol": {
      color: color.symbol
    },
    "&.tag": {
      color: color.tag
    },
    "&.unit": {
      color: color.unit
    },
    "&.url": {
      color: color.url
    },
    "&.variable": {
      color: color.variable
    }
  };
}
function codeBaseStyle() {
  return styled.css(_a$r || (_a$r = __template$r(["\n    color: var(--card-code-fg-color);\n\n    & code {\n      font-family: inherit;\n\n      &.refractor .token {\n        ", "\n      }\n    }\n\n    & a {\n      color: inherit;\n      text-decoration: underline;\n      border-radius: 1px;\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), codeSyntaxHighlightingStyle);
}
const Root$s = styled__default.default.pre(codeBaseStyle, responsiveCodeFontStyle);
const Code = react.forwardRef(function Code2(props, ref) {
  const {
    children,
    language: languageProp,
    size = 2,
    weight,
    ...restProps
  } = props;
  const language = typeof languageProp === "string" ? languageProp : void 0;
  const registered = language ? Refractor__default.default.hasLanguage(language) : false;
  return /* @__PURE__ */jsxRuntime.jsxs(Root$s, {
    "data-ui": "Code",
    ...restProps,
    $size: useArrayProp(size),
    $weight: weight,
    ref,
    children: [!(language && registered) && /* @__PURE__ */jsxRuntime.jsx("code", {
      children
    }), language && registered && /* @__PURE__ */jsxRuntime.jsx(Refractor__default.default, {
      inline: true,
      language,
      value: String(children)
    })]
  });
});
const BASE_STYLE$1 = {
  width: "100%",
  margin: "0 auto"
};
function containerBaseStyle() {
  return BASE_STYLE$1;
}
function responsiveContainerWidthStyle(props) {
  const {
    theme
  } = props;
  const {
    container,
    media
  } = theme.sanity;
  return _responsive(media, props.$width, val => ({
    maxWidth: val === "auto" ? "none" : rem(container[val])
  }));
}
const Root$r = styled__default.default(Box)(containerBaseStyle, responsiveContainerWidthStyle);
const Container = react.forwardRef(function Container2(props, ref) {
  const {
    as,
    width = 2,
    ...restProps
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(Root$r, {
    "data-ui": "Container",
    ...restProps,
    $width: useArrayProp(width),
    forwardedAs: as,
    ref
  });
});
const Root$q = styled__default.default(Box)(responsiveGridStyle);
const Grid = react.forwardRef(function Grid2(props, ref) {
  const {
    as,
    autoRows,
    autoCols,
    autoFlow,
    columns,
    gap,
    gapX,
    gapY,
    rows,
    children,
    ...restProps
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(Root$q, {
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Grid",
    ...restProps,
    $autoRows: useArrayProp(autoRows),
    $autoCols: useArrayProp(autoCols),
    $autoFlow: useArrayProp(autoFlow),
    $columns: useArrayProp(columns),
    $gap: useArrayProp(gap),
    $gapX: useArrayProp(gapX),
    $gapY: useArrayProp(gapY),
    $rows: useArrayProp(rows),
    forwardedAs: as,
    ref,
    children
  });
});
var __freeze$q = Object.freeze;
var __defProp$r = Object.defineProperty;
var __template$q = (cooked, raw) => __freeze$q(__defProp$r(cooked, "raw", {
  value: __freeze$q(raw || cooked.slice())
}));
var _a$q, _b$g, _c$9;
function headingBaseStyle(props) {
  const {
    $accent,
    $muted,
    theme
  } = props;
  return styled.css(_c$9 || (_c$9 = __template$q(["\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n      color: var(--card-link-color);\n      outline: none;\n\n      @media (hover: hover) {\n        &:hover {\n          text-decoration: underline;\n        }\n      }\n\n      &:focus {\n        box-shadow:\n          0 0 0 1px var(--card-bg-color),\n          0 0 0 3px var(--card-focus-ring-color);\n      }\n\n      &:focus:not(:focus-visible) {\n        box-shadow: none;\n      }\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && styled.css(_a$q || (_a$q = __template$q(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && styled.css(_b$g || (_b$g = __template$q(["\n      color: var(--card-muted-fg-color);\n    "]))), theme.sanity.fonts.code.family);
}
var __freeze$p = Object.freeze;
var __defProp$q = Object.defineProperty;
var __template$p = (cooked, raw) => __freeze$p(__defProp$q(cooked, "raw", {
  value: __freeze$p(raw || cooked.slice())
}));
var _a$p;
const Root$p = styled__default.default.div(headingBaseStyle, responsiveTextAlignStyle, responsiveHeadingFont);
const SpanWithTextOverflow = styled__default.default.span(_a$p || (_a$p = __template$p(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  overflow: clip;\n"])));
const Heading = react.forwardRef(function Heading2(props, ref) {
  const {
    accent = false,
    align,
    children: childrenProp,
    muted = false,
    size = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = /* @__PURE__ */jsxRuntime.jsx(SpanWithTextOverflow, {
      children
    });
  }
  return /* @__PURE__ */jsxRuntime.jsx(Root$p, {
    "data-ui": "Heading",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    $size: useArrayProp(size),
    $weight: weight,
    ref,
    children: /* @__PURE__ */jsxRuntime.jsx("span", {
      children
    })
  });
});
function inlineBaseStyle() {
  return {
    lineHeight: 0,
    "&&:not([hidden])": {
      display: "block"
    },
    "& > div": {
      display: "inline-block",
      verticalAlign: "middle"
    }
  };
}
function inlineSpaceStyle(props) {
  const {
    theme
  } = props;
  return _responsive(theme.sanity.media, props.$space, spaceIndex => {
    const space = rem(theme.sanity.space[spaceIndex]);
    return {
      margin: "-".concat(space, " 0 0 -").concat(space),
      "& > div": {
        padding: "".concat(space, " 0 0 ").concat(space)
      }
    };
  });
}
const Root$o = styled__default.default(Box)(inlineBaseStyle, inlineSpaceStyle);
const Inline = react.forwardRef(function Inline2(props, ref) {
  const {
    as,
    children: childrenProp,
    space,
    ...restProps
  } = props;
  const children = react.useMemo(() => childrenToElementArray(childrenProp).filter(Boolean).map((child, idx) => /* @__PURE__ */jsxRuntime.jsx("div", {
    children: child
  }, idx)), [childrenProp]);
  return /* @__PURE__ */jsxRuntime.jsx(Root$o, {
    "data-ui": "Inline",
    ...restProps,
    $space: useArrayProp(space),
    forwardedAs: as,
    ref,
    children
  });
});
var __freeze$o = Object.freeze;
var __defProp$p = Object.defineProperty;
var __template$o = (cooked, raw) => __freeze$o(__defProp$p(cooked, "raw", {
  value: __freeze$o(raw || cooked.slice())
}));
var _a$o;
function kbdStyle() {
  return styled.css(_a$o || (_a$o = __template$o(["\n    background: var(--card-bg-color);\n    font: inherit;\n    box-shadow: inset 0 0 0 1px var(--card-hairline-hard-color);\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
const Root$n = styled__default.default.kbd(responsiveRadiusStyle, kbdStyle);
const KBD = react.forwardRef(function KBD2(props, ref) {
  const {
    children,
    fontSize = 1,
    padding = 1,
    radius = 2,
    ...restProps
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(Root$n, {
    "data-ui": "KBD",
    ...restProps,
    $radius: useArrayProp(radius),
    ref,
    children: /* @__PURE__ */jsxRuntime.jsx(Box, {
      as: "span",
      padding,
      children: /* @__PURE__ */jsxRuntime.jsx(Code, {
        as: "span",
        muted: true,
        size: fontSize,
        children
      })
    })
  });
});
const key$7 = Symbol.for("@sanity/ui/context/boundaryElement");
globalScope[key$7] = globalScope[key$7] || react.createContext(null);
const BoundaryElementContext = globalScope[key$7];
function BoundaryElementProvider(props) {
  const {
    children,
    element
  } = props;
  const value = react.useMemo(() => ({
    version: 0,
    element
  }), [element]);
  return /* @__PURE__ */jsxRuntime.jsx(BoundaryElementContext.Provider, {
    value,
    children
  });
}
const DEFAULT_VALUE = {
  version: 0,
  element: null
};
function useBoundaryElement() {
  const value = react.useContext(BoundaryElementContext);
  if (value && (!isRecord(value) || value.version !== 0)) {
    throw new Error("useBoundaryElement(): the context value is not compatible");
  }
  return value || DEFAULT_VALUE;
}
function findMaxBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1) {
    const bp = media[i];
    if (bp > width) {
      ret.push(i);
    }
  }
  return ret;
}
function findMinBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1) {
    const bp = media[i];
    if (bp <= width) {
      ret.push(i);
    }
  }
  return ret;
}
const ElementQuery = react.forwardRef(function ElementQuery2(props, ref) {
  const theme = useTheme();
  const {
    children,
    media = theme.sanity.media,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const [element, setElement] = react.useState(null);
  const elementSize = useElementSize(element);
  const width = react.useMemo(() => {
    var _a;
    return (_a = elementSize == null ? void 0 : elementSize.border.width) != null ? _a : window.innerWidth;
  }, [elementSize]);
  const max = react.useMemo(() => findMaxBreakpoints(media, width), [media, width]);
  const min = react.useMemo(() => findMinBreakpoints(media, width), [media, width]);
  const setRef = react.useCallback(el => {
    forwardedRef.current = el;
    setElement(el);
  }, [forwardedRef]);
  return /* @__PURE__ */jsxRuntime.jsx("div", {
    "data-ui": "ElementQuery",
    ...restProps,
    "data-eq-max": max.length ? max.join(" ") : void 0,
    "data-eq-min": min.length ? min.join(" ") : void 0,
    ref: setRef,
    children
  });
});
var __defProp$o = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp$o(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ErrorBoundary extends react.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      error: null
    });
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, info) {
    this.props.onCatch({
      error,
      info
    });
  }
  render() {
    const {
      error
    } = this.state;
    if (error) {
      const message = typeof (error == null ? void 0 : error.message) === "string" ? error.message : "Error";
      return /* @__PURE__ */jsxRuntime.jsx(Code, {
        children: message
      });
    }
    return this.props.children;
  }
}
function getLayerContext(contextValue) {
  if (!isRecord(contextValue) || contextValue.version !== 0) {
    throw new Error("the context value is not compatible");
  }
  if (!contextValue) {
    throw new Error("components using `useLayer()` should be wrapped in a <LayerProvider>.");
  }
  if (contextValue.version === 0) {
    return contextValue;
  }
  throw new Error("could not get layer context");
}
const key$6 = Symbol.for("@sanity/ui/context/layer");
globalScope[key$6] = globalScope[key$6] || react.createContext(null);
const LayerContext = globalScope[key$6];
function useLayer() {
  const value = react.useContext(LayerContext);
  if (!value) {
    throw new Error("useLayer(): missing context value");
  }
  try {
    return getLayerContext(value);
  } catch (err) {
    if (err instanceof Error) {
      throw new Error("useLayer(): ".concat(err.message));
    } else {
      throw new Error("useLayer(): ".concat(err));
    }
  }
}
function _raf(fn) {
  const frameId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _raf2(fn) {
  let innerDispose = null;
  const outerDispose = _raf(() => {
    innerDispose = _raf(fn);
  });
  return () => {
    if (innerDispose) innerDispose();
    outerDispose();
  };
}
function _isEnterToClickElement(element) {
  return isHTMLAnchorElement(element) || isHTMLButtonElement(element);
}
function isHTMLElement(node) {
  return node instanceof Node && node.nodeType === Node.ELEMENT_NODE;
}
function isHTMLAnchorElement(element) {
  return isHTMLElement(element) && element.nodeName === "A";
}
function isHTMLInputElement(element) {
  return isHTMLElement(element) && element.nodeName === "INPUT";
}
function isHTMLButtonElement(element) {
  return isHTMLElement(element) && element.nodeName === "BUTTON";
}
function isHTMLSelectElement(element) {
  return isHTMLElement(element) && element.nodeName === "SELECT";
}
function isHTMLTextAreaElement(element) {
  return isHTMLElement(element) && element.nodeName === "TEXTAREA";
}
function containsOrEqualsElement(element, node) {
  return element.contains(node) || element === node;
}
function _hasFocus(element) {
  return Boolean(document.activeElement) && element.contains(document.activeElement);
}
function isFocusable(element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (isHTMLAnchorElement(element)) {
    return Boolean(element.href) && element.rel !== "ignore";
  }
  if (isHTMLInputElement(element)) {
    return element.type !== "hidden" && element.type !== "file" && !element.disabled;
  }
  if (isHTMLButtonElement(element) || isHTMLSelectElement(element) || isHTMLTextAreaElement(element)) {
    return !element.disabled;
  }
  return false;
}
function attemptFocus(element) {
  if (!isFocusable(element)) {
    return false;
  }
  try {
    element.focus();
  } catch (_) {}
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusFirstDescendant(child))) {
      return true;
    }
  }
  return false;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusLastDescendant(child))) {
      return true;
    }
  }
  return false;
}
function _isScrollable(el) {
  if (!(el instanceof Element)) return false;
  const style = window.getComputedStyle(el);
  return style.overflowX.includes("auto") || style.overflowX.includes("scroll") || style.overflowY.includes("auto") || style.overflowY.includes("scroll");
}
function LayerProvider(props) {
  var _a;
  const {
    children,
    zOffset: zOffsetProp = 0
  } = props;
  const parentContextValue = react.useContext(LayerContext);
  const parent = parentContextValue && getLayerContext(parentContextValue);
  const parentRegisterChild = parent == null ? void 0 : parent.registerChild;
  const parentLevel = (_a = parent == null ? void 0 : parent.level) != null ? _a : 0;
  const level = parentLevel + 1;
  const zOffset = useArrayProp(zOffsetProp);
  const maxMediaIndex = zOffset.length - 1;
  const mediaIndex = Math.min(useMediaIndex(), maxMediaIndex);
  const zIndex = parent ? parent.zIndex + zOffset[mediaIndex] : zOffset[mediaIndex];
  const [, setChildLayers] = react.useState({});
  const [size, setSize] = react.useState(0);
  const isTopLayer = size === 0;
  const registerChild = react.useCallback(childLevel => {
    const parentDispose = parentRegisterChild == null ? void 0 : parentRegisterChild(childLevel);
    if (childLevel !== void 0) {
      setChildLayers(state => {
        var _a2;
        const prevLen = (_a2 = state[childLevel]) != null ? _a2 : 0;
        const nextState = {
          ...state,
          [childLevel]: prevLen + 1
        };
        setSize(Object.keys(nextState).length);
        return nextState;
      });
    } else {
      setSize(v => v + 1);
    }
    return () => {
      if (childLevel !== void 0) {
        setChildLayers(state => {
          const nextState = {
            ...state
          };
          if (nextState[childLevel] === 1) {
            delete nextState[childLevel];
            setSize(Object.keys(nextState).length);
          } else {
            nextState[childLevel] -= 1;
          }
          return nextState;
        });
      } else {
        setSize(v => v - 1);
      }
      parentDispose == null ? void 0 : parentDispose();
    };
  }, [parentRegisterChild]);
  react.useEffect(() => parentRegisterChild == null ? void 0 : parentRegisterChild(level), [level, parentRegisterChild]);
  const value = react.useMemo(() => ({
    version: 0,
    isTopLayer,
    level,
    registerChild,
    size,
    zIndex
  }), [isTopLayer, level, registerChild, size, zIndex]);
  return /* @__PURE__ */jsxRuntime.jsx(LayerContext.Provider, {
    value,
    children
  });
}
const Root$m = styled__default.default.div({
  position: "relative"
});
const LayerChildren = react.forwardRef(function LayerChildren2(props, ref) {
  const {
    children,
    onActivate,
    onFocus,
    style = EMPTY_RECORD,
    ...restProps
  } = props;
  const {
    zIndex,
    isTopLayer
  } = useLayer();
  const lastFocusedRef = react.useRef(null);
  const forwardedRef = useForwardedRef(ref);
  const isTopLayerRef = react.useRef(isTopLayer);
  react.useEffect(() => {
    const becameTopLayer = isTopLayerRef.current !== isTopLayer && isTopLayer;
    if (becameTopLayer) {
      onActivate == null ? void 0 : onActivate({
        activeElement: lastFocusedRef.current
      });
    }
    isTopLayerRef.current = isTopLayer;
  }, [isTopLayer, onActivate]);
  const handleFocus = react.useCallback(event => {
    onFocus == null ? void 0 : onFocus(event);
    const rootElement = forwardedRef.current;
    const target = document.activeElement;
    if (!isTopLayer || !rootElement || !target) return;
    if (isHTMLElement(target) && containsOrEqualsElement(rootElement, target)) {
      lastFocusedRef.current = target;
    }
  }, [forwardedRef, isTopLayer, onFocus]);
  return /* @__PURE__ */jsxRuntime.jsx(Root$m, {
    ...restProps,
    "data-ui": "Layer",
    onFocus: handleFocus,
    ref: forwardedRef,
    style: {
      ...style,
      zIndex
    },
    children
  });
});
const Layer = react.forwardRef(function Layer2(props, ref) {
  const {
    children,
    zOffset = 1,
    ...restProps
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(LayerProvider, {
    zOffset,
    children: /* @__PURE__ */jsxRuntime.jsx(LayerChildren, {
      ...restProps,
      ref,
      children
    })
  });
});
const key$5 = Symbol.for("@sanity/ui/context/portal");
const elementKey = Symbol.for("@sanity/ui/context/portal/element");
globalScope[elementKey] = null;
const defaultContextValue = {
  version: 0,
  boundaryElement: null,
  get element() {
    if (typeof document === "undefined") {
      return null;
    }
    if (globalScope[elementKey]) {
      return globalScope[elementKey];
    }
    globalScope[elementKey] = document.createElement("div");
    globalScope[elementKey].setAttribute("data-portal", "");
    document.body.appendChild(globalScope[elementKey]);
    return globalScope[elementKey];
  }
};
globalScope[key$5] = globalScope[key$5] || react.createContext(defaultContextValue);
const PortalContext = globalScope[key$5];
function usePortal() {
  const value = react.useContext(PortalContext);
  if (!value) {
    throw new Error("usePortal(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("usePortal(): the context value is not compatible");
  }
  return value;
}
function Portal(props) {
  var _a;
  const {
    children,
    __unstable_name: name
  } = props;
  const portal = usePortal();
  const portalElement = (name ? portal.elements && portal.elements[name] : portal.element) || ((_a = portal.elements) == null ? void 0 : _a.default);
  if (!portalElement) {
    return null;
  }
  return reactDom.createPortal(children, portalElement);
}
function useUnique(value) {
  const valueRef = react.useRef(value);
  if (!_isEqual(valueRef.current, value)) {
    valueRef.current = value;
  }
  return valueRef.current;
}
function _isEqual(objA, objB) {
  if (!objA || !objB) {
    return objA === objB;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  return keysA.every(key => objA[key] === objB[key]);
}
const __BROWSER__ = typeof document !== "undefined";
function PortalProvider(props) {
  const {
    boundaryElement,
    children,
    element,
    __unstable_elements: elementsProp
  } = props;
  const elements = useUnique(elementsProp);
  const value = react.useMemo(() => {
    return {
      version: 0,
      boundaryElement: boundaryElement || null,
      element: element || __BROWSER__ && document.body || null,
      elements
    };
  }, [boundaryElement, element, elements]);
  return /* @__PURE__ */jsxRuntime.jsx(PortalContext.Provider, {
    value,
    children
  });
}
var __freeze$n = Object.freeze;
var __defProp$n = Object.defineProperty;
var __template$n = (cooked, raw) => __freeze$n(__defProp$n(cooked, "raw", {
  value: __freeze$n(raw || cooked.slice())
}));
var _a$n;
const Root$l = styled__default.default.div(_a$n || (_a$n = __template$n(["\n  display: block;\n  width: 0;\n  height: 0;\n  position: absolute;\n  overflow: hidden;\n  overflow: clip;\n"])));
const SrOnly = react.forwardRef(function SrOnly2(props, ref) {
  const {
    as,
    children
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(Root$l, {
    "aria-hidden": true,
    as,
    "data-ui": "SrOnly",
    ref,
    children
  });
});
var __freeze$m = Object.freeze;
var __defProp$m = Object.defineProperty;
var __template$m = (cooked, raw) => __freeze$m(__defProp$m(cooked, "raw", {
  value: __freeze$m(raw || cooked.slice())
}));
var _a$m, _b$f;
const Root$k = styled__default.default.div(_a$m || (_a$m = __template$m(["\n  position: relative;\n"])));
const ItemWrapper = styled__default.default.div(_b$f || (_b$f = __template$m(["\n  position: absolute;\n  left: 0;\n  right: 0;\n"])));
const VirtualList = react.forwardRef(function VirtualList2(props, ref) {
  const {
    as = "div",
    gap = 0,
    getItemKey,
    items = [],
    onChange,
    renderItem,
    ...restProps
  } = props;
  const {
    space
  } = useTheme().sanity;
  const forwardedRef = useForwardedRef(ref);
  const wrapperRef = react.useRef(null);
  const [scrollTop, setScrollTop] = react.useState(0);
  const [scrollHeight, setScrollHeight] = react.useState(0);
  const [itemHeight, setItemHeight] = react.useState(-1);
  react.useEffect(() => {
    if (!wrapperRef.current) return;
    const firstElement = wrapperRef.current.firstChild;
    if (firstElement instanceof HTMLElement) {
      setItemHeight(firstElement.offsetHeight);
    }
  }, [renderItem]);
  react.useEffect(() => {
    if (!forwardedRef.current) return;
    let _scrollEl = forwardedRef.current.parentNode;
    while (_scrollEl && !_isScrollable(_scrollEl)) {
      _scrollEl = _scrollEl.parentNode;
    }
    if (_scrollEl) {
      const scrollEl = _scrollEl;
      if (!(scrollEl instanceof HTMLElement)) return;
      const handleScroll2 = () => {
        setScrollTop(scrollEl.scrollTop);
      };
      scrollEl.addEventListener("scroll", handleScroll2, {
        passive: true
      });
      const ro = new _ResizeObserver(entries => {
        setScrollHeight(entries[0].contentRect.height);
      });
      ro.observe(scrollEl);
      handleScroll2();
      return () => {
        scrollEl.removeEventListener("scroll", handleScroll2);
        ro.unobserve(scrollEl);
        ro.disconnect();
      };
    }
    const handleScroll = () => {
      setScrollTop(window.scrollY);
    };
    const handleResize = () => {
      setScrollHeight(window.innerHeight);
    };
    window.addEventListener("scroll", handleScroll, {
      passive: true
    });
    window.addEventListener("resize", handleResize);
    setScrollHeight(window.innerHeight);
    handleScroll();
    return () => {
      window.removeEventListener("scroll", handleScroll);
      window.removeEventListener("resize", handleResize);
    };
  }, [forwardedRef]);
  const len = items.length;
  const height = itemHeight ? len * (itemHeight + space[gap]) - space[gap] : 0;
  const fromIndex = height ? Math.max(Math.floor(scrollTop / height * len) - 2, 0) : 0;
  const toIndex = height ? Math.ceil((scrollTop + scrollHeight) / height * len) + 1 : 0;
  react.useEffect(() => {
    if (!onChange) return;
    onChange({
      fromIndex,
      gap: space[gap],
      itemHeight,
      scrollHeight,
      scrollTop,
      toIndex
    });
  }, [fromIndex, gap, itemHeight, onChange, scrollHeight, scrollTop, space, toIndex]);
  const children = react.useMemo(() => {
    if (!renderItem || items.length === 0) return null;
    if (itemHeight === -1) {
      return [/* @__PURE__ */jsxRuntime.jsx(ItemWrapper, {
        children: renderItem(items[0])
      }, 0)];
    }
    return items.slice(fromIndex, toIndex).map((item, _itemIndex) => {
      const itemIndex = fromIndex + _itemIndex;
      const node = renderItem(item);
      const key = getItemKey ? getItemKey(item, itemIndex) : itemIndex;
      return /* @__PURE__ */jsxRuntime.jsx(ItemWrapper, {
        style: {
          top: itemIndex * (itemHeight + space[gap])
        },
        children: node
      }, key);
    });
  }, [fromIndex, gap, getItemKey, itemHeight, items, renderItem, space, toIndex]);
  const wrapperStyle = react.useMemo(() => ({
    height
  }), [height]);
  return /* @__PURE__ */jsxRuntime.jsx(Root$k, {
    as,
    "data-ui": "VirtualList",
    ...restProps,
    ref: forwardedRef,
    children: /* @__PURE__ */jsxRuntime.jsx("div", {
      ref: wrapperRef,
      style: wrapperStyle,
      children
    })
  });
});
const DEFAULT_POPOVER_DISTANCE = 4;
const DEFAULT_POPOVER_PADDING = 4;
const DEFAULT_POPOVER_ARROW_WIDTH = 27;
const DEFAULT_POPOVER_ARROW_HEIGHT = 11;
const DEFAULT_POPOVER_MARGINS = [0, 0, 0, 0];
const DEFAULT_FALLBACK_PLACEMENTS$1 = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
function size(options) {
  const {
    apply,
    margins,
    padding = 0
  } = options;
  return {
    name: "@sanity/ui/size",
    async fn(args) {
      const {
        elements,
        placement,
        platform,
        rects
      } = args;
      const {
        floating,
        reference
      } = rects;
      const overflow = await reactDom$1.detectOverflow(args, {
        altBoundary: true,
        boundary: options.boundaryElement || void 0,
        elementContext: "floating",
        padding,
        rootBoundary: "viewport"
      });
      let maxWidth = Infinity;
      let maxHeight = Infinity;
      const floatingW = floating.width;
      const floatingH = floating.height;
      if (placement.includes("top")) {
        maxWidth = floatingW - (overflow.left + overflow.right);
        maxHeight = floatingH - overflow.top;
      }
      if (placement.includes("right")) {
        maxWidth = floatingW - overflow.right;
        maxHeight = floatingH - (overflow.top + overflow.bottom);
      }
      if (placement.includes("bottom")) {
        maxWidth = floatingW - (overflow.left + overflow.right);
        maxHeight = floatingH - overflow.bottom;
      }
      if (placement.includes("left")) {
        maxWidth = floatingW - overflow.left;
        maxHeight = floatingH - (overflow.top + overflow.bottom);
      }
      apply({
        availableWidth: maxWidth - margins[1] - margins[3],
        availableHeight: maxHeight - margins[0] - margins[2],
        elements,
        referenceWidth: reference.width - margins[1] - margins[3]
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      const targetH = nextDimensions.height;
      const targetW = nextDimensions.width;
      if (floatingW !== targetW || floatingH !== targetH) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
}
function calcCurrentWidth(params) {
  const {
    mediaIndex,
    theme,
    width
  } = params;
  const w = width[mediaIndex];
  const currentWidth = w === void 0 ? width[width.length - 1] : w;
  return typeof currentWidth === "number" ? theme.sanity.container[currentWidth] : void 0;
}
function calcMaxWidth(params) {
  const {
    boundaryWidth,
    currentWidth
  } = params;
  if (currentWidth === void 0 && boundaryWidth === void 0) {
    return void 0;
  }
  return Math.min(currentWidth != null ? currentWidth : Infinity, (boundaryWidth || Infinity) - DEFAULT_POPOVER_PADDING * 2);
}
var __freeze$l = Object.freeze;
var __defProp$l = Object.defineProperty;
var __template$l = (cooked, raw) => __freeze$l(__defProp$l(cooked, "raw", {
  value: __freeze$l(raw || cooked.slice())
}));
var _a$l, _b$e, _c$8;
const Root$j = styled__default.default.div(_a$l || (_a$l = __template$l(["\n  position: absolute;\n  pointer-events: none;\n  width: ", "px;\n  height: ", "px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    display: block;\n    transform-origin: ", "px ", "px;\n  }\n\n  [data-placement^='top'] > & {\n    bottom: -", "px;\n  }\n\n  [data-placement^='right'] > & {\n    left: -", "px;\n\n    & > svg {\n      transform: rotate(90deg);\n    }\n  }\n\n  [data-placement^='left'] > & {\n    right: -", "px;\n\n    & > svg {\n      transform: rotate(-90deg);\n    }\n  }\n\n  [data-placement^='bottom'] > & {\n    top: -", "px;\n\n    & > svg {\n      transform: rotate(180deg);\n    }\n  }\n"])), DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH / 2, DEFAULT_POPOVER_ARROW_WIDTH / 2, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH);
const BorderPath = styled__default.default.path(_b$e || (_b$e = __template$l(["\n  fill: var(--card-shadow-outline-color);\n"])));
const ShapePath = styled__default.default.path(_c$8 || (_c$8 = __template$l(["\n  fill: var(--card-bg-color);\n"])));
const PopoverArrow = react.forwardRef(function PopoverArrow2(props, ref) {
  return /* @__PURE__ */jsxRuntime.jsx(Root$j, {
    "data-ui": "Popover__arrow",
    ...props,
    ref,
    children: /* @__PURE__ */jsxRuntime.jsxs("svg", {
      width: DEFAULT_POPOVER_ARROW_WIDTH,
      height: DEFAULT_POPOVER_ARROW_HEIGHT,
      viewBox: "0 0 27 11",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/* @__PURE__ */jsxRuntime.jsx(BorderPath, {
        d: "M1.18708 1C3.29803 1.0011 5.29585 1.95479 6.62414 3.59561L11.1683 9.20895C12.369 10.6922 14.631 10.6922 15.8317 9.20894L20.3759 3.59561C21.7042 1.95478 23.702 1.0011 25.8129 1H21.9436C21.0533 1.49255 20.2545 2.15618 19.5986 2.96641L15.0545 8.57975C14.254 9.56855 12.746 9.56855 11.9455 8.57975L7.40139 2.96642C6.74548 2.15618 5.94673 1.49255 5.05643 1H1.18708Z"
      }), /* @__PURE__ */jsxRuntime.jsx(ShapePath, {
        d: "M1.18342 0C3.59749 0 5.88246 1.0901 7.40138 2.96642L11.9455 8.57975C12.746 9.56855 14.254 9.56855 15.0545 8.57975L19.5986 2.96641C21.1175 1.0901 23.4025 0 25.8166 0H27H0H1.18342Z"
      })]
    })
  });
});
const Root$i = styled__default.default(Card)({
  "&:not([hidden])": {
    display: "flex"
  },
  flexDirection: "column",
  width: "max-content",
  minWidth: "min-content"
});
const PopoverCard = react.memo(react.forwardRef(function PopoverCard2(props, ref) {
  const {
    __unstable_margins: marginsProp,
    arrow,
    arrowRef,
    arrowX,
    arrowY,
    children,
    padding,
    placement,
    overflow,
    radius,
    scheme,
    shadow,
    strategy,
    style,
    tone,
    width,
    x: xProp,
    y: yProp,
    ...restProps
  } = props;
  const {
    zIndex
  } = useLayer();
  const margins = react.useMemo(() => marginsProp || DEFAULT_POPOVER_MARGINS, [marginsProp]);
  const x = (xProp != null ? xProp : 0) + margins[3];
  const y = (yProp != null ? yProp : 0) + margins[0];
  const rootStyle = react.useMemo(() => ({
    position: strategy,
    top: y,
    left: x,
    width,
    zIndex,
    ...style
  }), [strategy, style, width, x, y, zIndex]);
  const staticSide = placement && FLOATING_STATIC_SIDES[placement.split("-")[0]];
  const arrowStyle = react.useMemo(() => {
    const style2 = {
      left: arrowX !== null ? arrowX : void 0,
      top: arrowY !== null ? arrowY : void 0,
      right: void 0,
      bottom: void 0
    };
    if (staticSide) style2[staticSide] = 0 - DEFAULT_POPOVER_ARROW_WIDTH;
    return style2;
  }, [arrowX, arrowY, staticSide]);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$i, {
    "data-ui": "Popover",
    ...restProps,
    "data-placement": placement,
    radius,
    ref,
    scheme,
    shadow,
    sizing: "border",
    style: rootStyle,
    tone,
    children: [/* @__PURE__ */jsxRuntime.jsx(Flex, {
      "data-ui": "Popover__wrapper",
      direction: "column",
      flex: 1,
      overflow,
      children: /* @__PURE__ */jsxRuntime.jsx(Flex, {
        direction: "column",
        flex: 1,
        padding,
        children
      })
    }), arrow && /* @__PURE__ */jsxRuntime.jsx(PopoverArrow, {
      ref: arrowRef,
      style: arrowStyle
    })]
  });
}));
PopoverCard.displayName = "PopoverCard";
const Popover = react.memo(react.forwardRef(function Popover2(props, ref) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const theme = useTheme();
  const boundaryElementContext = useBoundaryElement();
  const {
    __unstable_margins: margins = DEFAULT_POPOVER_MARGINS,
    arrow: arrowProp = true,
    boundaryElement = boundaryElementContext.element,
    children: childProp,
    constrainSize = false,
    content,
    disabled,
    fallbackPlacements = (_b = props.fallbackPlacements) != null ? _b : DEFAULT_FALLBACK_PLACEMENTS$1[(_a = props.placement) != null ? _a : "bottom"],
    matchReferenceWidth,
    floatingBoundary = (_c = props.boundaryElement) != null ? _c : boundaryElementContext.element,
    open,
    overflow = "hidden",
    padding: paddingProp,
    placement: placementProp = "bottom",
    portal,
    preventOverflow = true,
    radius: radiusProp = 3,
    referenceBoundary = (_d = props.boundaryElement) != null ? _d : boundaryElementContext.element,
    referenceElement,
    scheme,
    shadow: shadowProp = 3,
    tone = "inherit",
    width: widthProp = "auto",
    zOffset: zOffsetProp = (_e = theme.sanity.layer) == null ? void 0 : _e.popover.zOffset,
    updateRef,
    ...restProps
  } = props;
  const boundarySize = (_f = useElementSize(boundaryElement)) == null ? void 0 : _f.border;
  const padding = useArrayProp(paddingProp);
  const radius = useArrayProp(radiusProp);
  const shadow = useArrayProp(shadowProp);
  const widthArrayProp = useArrayProp(widthProp);
  const zOffset = useArrayProp(zOffsetProp);
  const forwardedRef = useForwardedRef(ref);
  const arrowRef = react.useRef(null);
  const rootBoundary = "viewport";
  const mediaIndex = useMediaIndex();
  const boundaryWidth = constrainSize || preventOverflow ? boundarySize == null ? void 0 : boundarySize.width : void 0;
  const width = calcCurrentWidth({
    mediaIndex,
    theme,
    width: widthArrayProp
  });
  const widthRef = react.useRef(width);
  react.useEffect(() => {
    widthRef.current = width;
  }, [width]);
  const maxWidth = calcMaxWidth({
    boundaryWidth,
    currentWidth: width
  });
  const maxWidthRef = react.useRef(maxWidth);
  react.useEffect(() => {
    maxWidthRef.current = maxWidth;
  }, [maxWidth]);
  const referenceWidthRef = react.useRef();
  react.useEffect(() => {
    const floatingElement = forwardedRef.current;
    if (!open || !floatingElement) return;
    const referenceWidth = referenceWidthRef.current;
    if (matchReferenceWidth) {
      if (referenceWidth !== void 0) {
        floatingElement.style.width = "".concat(referenceWidth, "px");
      }
    } else if (width !== void 0) {
      floatingElement.style.width = "".concat(width, "px");
    }
    if (typeof maxWidth === "number") {
      floatingElement.style.maxWidth = "".concat(maxWidth, "px");
    }
  }, [width, forwardedRef, matchReferenceWidth, maxWidth, open]);
  const middleware = react.useMemo(() => {
    const ret = [];
    if (constrainSize || preventOverflow) {
      ret.push(reactDom$1.flip({
        boundary: floatingBoundary || void 0,
        fallbackPlacements,
        padding: DEFAULT_POPOVER_PADDING,
        rootBoundary
      }));
    }
    ret.push(reactDom$1.offset({
      mainAxis: arrowProp ? DEFAULT_POPOVER_DISTANCE : 0
    }));
    if (constrainSize || matchReferenceWidth) {
      ret.push(size({
        apply(_ref21) {
          let {
            availableWidth,
            availableHeight,
            elements,
            referenceWidth
          } = _ref21;
          referenceWidthRef.current = referenceWidth;
          const _currentWidth = widthRef.current;
          const _maxWidth = maxWidthRef.current;
          if (matchReferenceWidth) {
            elements.floating.style.width = "".concat(referenceWidth, "px");
          } else if (_currentWidth !== void 0) {
            elements.floating.style.width = "".concat(_currentWidth, "px");
          }
          if (constrainSize) {
            elements.floating.style.maxWidth = "".concat(Math.min(availableWidth, _maxWidth != null ? _maxWidth : Infinity), "px");
            elements.floating.style.maxHeight = "".concat(availableHeight, "px");
          }
        },
        boundaryElement: floatingBoundary || void 0,
        constrainSize,
        margins,
        matchReferenceWidth,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    if (preventOverflow) {
      ret.push(reactDom$1.shift({
        boundary: floatingBoundary || void 0,
        rootBoundary,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    if (arrowProp) {
      ret.push(reactDom$1.arrow({
        element: arrowRef,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    ret.push(reactDom$1.hide({
      boundary: referenceBoundary || void 0,
      padding: DEFAULT_POPOVER_PADDING,
      strategy: "referenceHidden"
    }));
    return ret;
  }, [arrowProp, constrainSize, fallbackPlacements, floatingBoundary, margins, matchReferenceWidth, preventOverflow, referenceBoundary]);
  const {
    x,
    y,
    middlewareData,
    placement,
    refs,
    strategy,
    update
  } = reactDom$1.useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: reactDom$1.autoUpdate
  });
  const referenceHidden = (_g = middlewareData.hide) == null ? void 0 : _g.referenceHidden;
  const arrowX = (_h = middlewareData.arrow) == null ? void 0 : _h.x;
  const arrowY = (_i = middlewareData.arrow) == null ? void 0 : _i.y;
  const setArrow = react.useCallback(arrowEl => {
    arrowRef.current = arrowEl;
  }, []);
  const setFloating = react.useCallback(node => {
    forwardedRef.current = node;
    refs.setFloating(node);
  }, [forwardedRef, refs]);
  const setReference = react.useCallback(node => {
    refs.setReference(node);
    const childRef = childProp == null ? void 0 : childProp.ref;
    if (typeof childRef === "function") {
      childRef(node);
    } else if (childRef) {
      childRef.current = node;
    }
  }, [childProp, refs]);
  const child = react.useMemo(() => {
    if (!childProp || referenceElement) return null;
    return react.cloneElement(childProp, {
      ref: setReference
    });
  }, [childProp, referenceElement, setReference]);
  react.useEffect(() => {
    if (updateRef) {
      if (typeof updateRef === "function") {
        updateRef(update);
      } else if (updateRef) {
        updateRef.current = update;
      }
    }
  }, [update, updateRef]);
  react.useEffect(() => {
    refs.setReference(referenceElement || null);
  }, [referenceElement, refs]);
  if (disabled) {
    return childProp || /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {});
  }
  const popover = /* @__PURE__ */jsxRuntime.jsx(LayerProvider, {
    zOffset,
    children: /* @__PURE__ */jsxRuntime.jsx(PopoverCard, {
      ...restProps,
      __unstable_margins: margins,
      arrow: arrowProp,
      arrowRef: setArrow,
      arrowX,
      arrowY,
      hidden: referenceHidden,
      overflow,
      padding,
      placement,
      radius,
      ref: setFloating,
      scheme,
      shadow,
      strategy,
      tone,
      width: matchReferenceWidth ? referenceWidthRef.current : width,
      x,
      y,
      children: content
    })
  });
  return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [open && /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
      children: portal ? /* @__PURE__ */jsxRuntime.jsx(Portal, {
        __unstable_name: typeof portal === "string" ? portal : void 0,
        children: popover
      }) : popover
    }), child]
  });
}));
Popover.displayName = "Popover";
var __freeze$k = Object.freeze;
var __defProp$k = Object.defineProperty;
var __template$k = (cooked, raw) => __freeze$k(__defProp$k(cooked, "raw", {
  value: __freeze$k(raw || cooked.slice())
}));
var _a$k, _b$d;
function radioBaseStyle() {
  return styled.css(_a$k || (_a$k = __template$k(["\n    position: relative;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n\n    &[data-read-only] {\n      outline: 1px solid red;\n    }\n  "])));
}
function inputElementStyle(props) {
  const {
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color = theme.sanity.color.input;
  const dist = (input.radio.size - input.radio.markSize) / 2;
  return styled.css(_b$d || (_b$d = __template$k(["\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    opacity: 0;\n    height: 100%;\n    width: 100%;\n    outline: none;\n    z-index: 1;\n    padding: 0;\n    margin: 0;\n    border-radius: ", ";\n    border: none;\n\n    /* enabled */\n    & + span {\n      display: block;\n      position: relative;\n      height: ", ";\n      width: ", ";\n      border-radius: ", ";\n      background: ", ";\n      box-shadow: ", ";\n\n      &::after {\n        content: '';\n        position: absolute;\n        top: ", ";\n        left: ", ";\n        height: ", ";\n        width: ", ";\n        border-radius: ", ";\n        background: ", ";\n        opacity: 0;\n      }\n    }\n\n    /* focused */\n    &:not(:disabled):focus + span {\n      box-shadow: ", ";\n    }\n\n    &:not(:disabled):focus:not(:focus-visible) + span {\n      box-shadow: ", ";\n    }\n\n    &:checked + span::after {\n      opacity: 1;\n    }\n\n    /* read only */\n    &[data-read-only] + span {\n      box-shadow: 0 0 0 1px ", ";\n      background: ", ";\n\n      &::after {\n        background: ", ";\n      }\n    }\n\n    /* disabled */\n    &:not([data-read-only]):disabled + span {\n      box-shadow: 0 0 0 1px ", ";\n      background: ", ";\n\n      &::after {\n        background: ", ";\n      }\n    }\n  "])), rem(input.radio.size / 2), rem(input.radio.size), rem(input.radio.size), rem(input.radio.size / 2), color.default.enabled.bg, focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), rem(dist), rem(dist), rem(input.radio.markSize), rem(input.radio.markSize), rem(input.radio.markSize / 2), color.default.enabled.fg, focusRingStyle({
    border: {
      width: input.border.width,
      color: color.default.enabled.border
    },
    focusRing
  }), focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), color.default.readOnly.border, color.default.readOnly.bg, color.default.readOnly.fg, color.default.disabled.border, color.default.disabled.bg, color.default.disabled.fg);
}
const Root$h = styled__default.default.div(radioBaseStyle);
const Input$4 = styled__default.default.input(inputElementStyle);
const Radio = react.forwardRef(function Radio2(props, forwardedRef) {
  const {
    className,
    disabled,
    style,
    customValidity,
    readOnly,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$h, {
    className,
    "data-ui": "Radio",
    style,
    children: [/* @__PURE__ */jsxRuntime.jsx(Input$4, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      disabled: disabled || readOnly,
      readOnly,
      ref,
      type: "radio"
    }), /* @__PURE__ */jsxRuntime.jsx("span", {})]
  });
});
var __freeze$j = Object.freeze;
var __defProp$j = Object.defineProperty;
var __template$j = (cooked, raw) => __freeze$j(__defProp$j(cooked, "raw", {
  value: __freeze$j(raw || cooked.slice())
}));
var _a$j, _b$c, _c$7, _d$5;
function rootStyle() {
  return styled.css(_a$j || (_a$j = __template$j(["\n    position: relative;\n    width: -webkit-fill-available;\n    width: stretch;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
function inputBaseStyle(props) {
  const {
    theme
  } = props;
  const font = theme.sanity.fonts.text;
  return styled.css(_b$c || (_b$c = __template$j(["\n    -webkit-font-smoothing: antialiased;\n    appearance: none;\n    border: 0;\n    font-family: ", ";\n    color: inherit;\n    width: 100%;\n    outline: none;\n    margin: 0;\n\n    &:disabled {\n      opacity: 1;\n    }\n  "])), font.family);
}
function inputColorStyle(props) {
  const {
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color = theme.sanity.color.input;
  return styled.css(_c$7 || (_c$7 = __template$j(["\n    /* enabled */\n    background-color: ", ";\n    color: ", ";\n    box-shadow: ", ";\n\n    /* hovered */\n    @media (hover: hover) {\n      &:not(:disabled):hover {\n        background-color: ", ";\n        color: ", ";\n        box-shadow: ", ";\n      }\n    }\n\n    /* focused */\n    &:not(:disabled):focus {\n      box-shadow: ", ";\n    }\n\n    /* read-only */\n    &[data-read-only] {\n      background-color: ", ";\n      color: ", ";\n      box-shadow: ", ";\n    }\n\n    /* disabled */\n    &:not([data-read-only]):disabled {\n      background-color: ", ";\n      color: ", ";\n      box-shadow: ", ";\n    }\n  "])), color.default.enabled.bg, color.default.enabled.fg, focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), color.default.hovered.bg, color.default.hovered.fg, focusRingBorderStyle({
    color: color.default.hovered.border,
    width: input.border.width
  }), focusRingStyle({
    border: {
      width: input.border.width,
      color: color.default.enabled.border
    },
    focusRing
  }), color.default.readOnly.bg, color.default.readOnly.fg, focusRingBorderStyle({
    color: color.default.readOnly.border,
    width: input.border.width
  }), color.default.disabled.bg, color.default.disabled.fg, focusRingBorderStyle({
    color: color.default.disabled.border,
    width: input.border.width
  }));
}
function textSize(size) {
  return {
    fontSize: rem(size.fontSize),
    lineHeight: rem(size.lineHeight)
  };
}
function inputTextSizeStyle(props) {
  const {
    theme,
    $fontSize
  } = props;
  const {
    sizes
  } = theme.sanity.fonts.text;
  return _responsive(theme.sanity.media, $fontSize, sizeIndex => textSize(sizes[sizeIndex] || sizes[2]));
}
function inputStyle() {
  return [responsiveRadiusStyle, inputBaseStyle, inputColorStyle, inputTextSizeStyle, responsiveInputPaddingIconRightStyle];
}
function iconBoxStyle(props) {
  const {
    theme
  } = props;
  const color = theme.sanity.color.input;
  return styled.css(_d$5 || (_d$5 = __template$j(["\n    pointer-events: none;\n    position: absolute;\n    top: 0;\n    right: 0;\n\n    /* enabled */\n    --card-fg-color: ", ";\n\n    /* hover */\n    @media (hover: hover) {\n      select:not(disabled):not(:read-only):hover + && {\n        --card-fg-color: ", ";\n      }\n    }\n\n    /* disabled */\n    select:disabled + && {\n      --card-fg-color: ", ";\n    }\n\n    /* read-only */\n    select[data-read-only] + && {\n      --card-fg-color: ", ";\n    }\n  "])), color.default.enabled.fg, color.default.hovered.fg, color.default.disabled.fg, color.default.readOnly.fg);
}
const selectStyle = {
  root: rootStyle,
  input: inputStyle,
  iconBox: iconBoxStyle
};
const Root$g = styled__default.default.div(selectStyle.root);
const Input$3 = styled__default.default.select(selectStyle.input);
const IconBox = styled__default.default(Box)(selectStyle.iconBox);
const Select = react.forwardRef(function Select2(props, forwardedRef) {
  const {
    children,
    customValidity,
    disabled,
    fontSize = 2,
    padding = 3,
    radius = 1,
    readOnly,
    space = 3,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$g, {
    "data-ui": "Select",
    children: [/* @__PURE__ */jsxRuntime.jsx(Input$3, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      "data-ui": "Select",
      ...restProps,
      $fontSize: useArrayProp(fontSize),
      $padding: useArrayProp(padding),
      $radius: useArrayProp(radius),
      $space: useArrayProp(space),
      disabled: disabled || readOnly,
      ref,
      children
    }), /* @__PURE__ */jsxRuntime.jsx(IconBox, {
      padding,
      children: /* @__PURE__ */jsxRuntime.jsx(Text, {
        size: fontSize,
        children: /* @__PURE__ */jsxRuntime.jsx(icons.SelectIcon, {})
      })
    })]
  });
});
const BASE_STYLE = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  },
  gridTemplateColumns: "minmax(0, 1fr)",
  gridAutoRows: "min-content"
};
function stackBaseStyle() {
  return BASE_STYLE;
}
function responsiveStackSpaceStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$space, spaceIndex => ({
    gridGap: rem(space[spaceIndex])
  }));
}
const Root$f = styled__default.default(Box)(stackBaseStyle, responsiveStackSpaceStyle);
const Stack = react.forwardRef(function Stack2(props, ref) {
  const {
    as,
    space,
    ...restProps
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(Root$f, {
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Stack",
    ...restProps,
    $space: useArrayProp(space),
    forwardedAs: as,
    ref
  });
});
var __freeze$i = Object.freeze;
var __defProp$i = Object.defineProperty;
var __template$i = (cooked, raw) => __freeze$i(__defProp$i(cooked, "raw", {
  value: __freeze$i(raw || cooked.slice())
}));
var _a$i, _b$b, _c$6, _d$4, _e$2, _f$2, _g;
function switchBaseStyles() {
  return styled.css(_a$i || (_a$i = __template$i(["\n    position: relative;\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
function switchInputStyles() {
  return styled.css(_b$b || (_b$b = __template$i(["\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    opacity: 0;\n    height: 100%;\n    width: 100%;\n    outline: none;\n    padding: 0;\n    margin: 0;\n\n    /* Place the input element above the representation element */\n    z-index: 1;\n  "])));
}
function switchRepresentationStyles(props) {
  const {
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color = theme.sanity.color.button.default;
  return styled.css(_c$6 || (_c$6 = __template$i(["\n    --switch-bg-color: ", ";\n    --switch-fg-color: ", ";\n    --switch-box-shadow: none;\n\n    &:not([hidden]) {\n      display: block;\n    }\n    position: relative;\n    width: ", ";\n    height: ", ";\n    border-radius: ", ";\n\n    /* Make sure it\u2019s not possible to interact with the wrapper element */\n    pointer-events: none;\n\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      z-index: 1;\n      box-shadow: var(--switch-box-shadow);\n      border-radius: inherit;\n    }\n\n    /* Focus styles */\n    input:focus + && {\n      --switch-box-shadow: ", ";\n    }\n\n    input:focus:not(:focus-visible) + && {\n      --switch-box-shadow: none;\n    }\n\n    input:checked + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n\n    @media (hover: hover) {\n      input:not(:disabled):hover + && {\n        --switch-bg-color: ", ";\n        --switch-fg-color: ", ";\n      }\n\n      input:not(:disabled):checked:hover + && {\n        --switch-bg-color: ", ";\n        --switch-fg-color: ", ";\n      }\n    }\n\n    input:not([data-read-only]):disabled + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n  "])), color.default.enabled.bg, color.default.enabled.fg, rem(input.switch.width), rem(input.switch.height), rem(input.switch.height / 2), focusRingStyle({
    focusRing
  }), color.positive.enabled.bg, color.positive.enabled.fg, color.default.hovered.bg, color.default.hovered.fg, color.positive.hovered.bg, color.positive.hovered.fg, color.default.disabled.bg, color.default.disabled.fg);
}
function switchTrackStyles(props) {
  const {
    theme
  } = props;
  const {
    input
  } = theme.sanity;
  return styled.css(_d$4 || (_d$4 = __template$i(["\n    &:not([hidden]) {\n      display: block;\n    }\n    background-color: var(--switch-bg-color);\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: ", ";\n    height: ", ";\n    border-radius: ", ";\n  "])), rem(input.switch.width), rem(input.switch.height), rem(input.switch.height / 2));
}
function switchThumbStyles(props) {
  const {
    $indeterminate,
    theme
  } = props;
  const {
    input
  } = theme.sanity;
  const trackWidth = input.switch.width;
  const trackHeight = input.switch.height;
  const trackPadding = input.switch.padding;
  const size = trackHeight - input.switch.padding * 2;
  const checkedOffset = trackWidth - trackPadding * 2 - size;
  const indeterminateOffset = trackWidth / 2 - size / 2 - trackPadding;
  const checked = $indeterminate !== true && props.$checked === true;
  return styled.css(_g || (_g = __template$i(["\n    &:not([hidden]) {\n      display: block;\n    }\n    position: absolute;\n    left: ", ";\n    top: ", ";\n    height: ", ";\n    width: ", ";\n    border-radius: ", ";\n    transition-property: transform;\n    transition-duration: ", "ms;\n    transition-timing-function: ", ";\n    background: var(--switch-fg-color);\n    transform: translate3d(0, 0, 0);\n\n    ", "\n\n    ", "\n  "])), rem(trackPadding), rem(trackPadding), rem(size), rem(size), rem(size / 2), input.switch.transitionDurationMs, input.switch.transitionTimingFunction, checked && styled.css(_e$2 || (_e$2 = __template$i(["\n      transform: translate3d(", "px, 0, 0);\n    "])), checkedOffset), $indeterminate && styled.css(_f$2 || (_f$2 = __template$i(["\n      transform: translate3d(", "px, 0, 0);\n    "])), indeterminateOffset));
}
const Root$e = styled__default.default.span(switchBaseStyles);
const Input$2 = styled__default.default.input(switchInputStyles);
const Representation = styled__default.default.span(switchRepresentationStyles);
const Track = styled__default.default.span(switchTrackStyles);
const Thumb = styled__default.default.span(switchThumbStyles);
const Switch = react.forwardRef(function Switch2(props, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    readOnly,
    style,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  react.useEffect(() => {
    if (ref.current) {
      ref.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate, ref]);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$e, {
    className,
    "data-ui": "Switch",
    style,
    children: [/* @__PURE__ */jsxRuntime.jsx(Input$2, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      checked: indeterminate !== true && checked,
      disabled: disabled || readOnly,
      type: "checkbox",
      ref
    }), /* @__PURE__ */jsxRuntime.jsxs(Representation, {
      "aria-hidden": true,
      "data-name": "representation",
      children: [/* @__PURE__ */jsxRuntime.jsx(Track, {}), /* @__PURE__ */jsxRuntime.jsx(Thumb, {
        $checked: checked,
        $indeterminate: indeterminate
      })]
    })]
  });
});
var __freeze$h = Object.freeze;
var __defProp$h = Object.defineProperty;
var __template$h = (cooked, raw) => __freeze$h(__defProp$h(cooked, "raw", {
  value: __freeze$h(raw || cooked.slice())
}));
var _a$h;
const Root$d = styled__default.default.span(textInputRootStyle);
const InputRoot$1 = styled__default.default.span(_a$h || (_a$h = __template$h(["\n  flex: 1;\n  min-width: 0;\n  display: block;\n  position: relative;\n"])));
const Input$1 = styled__default.default.textarea(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
const Presentation$1 = styled__default.default.div(responsiveRadiusStyle, textInputRepresentationStyle);
const TextArea = react.forwardRef(function TextArea2(props, forwardedRef) {
  const {
    border = true,
    customValidity,
    disabled = false,
    fontSize = 2,
    padding = 3,
    radius = 1,
    weight,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  const rootTheme = useRootTheme();
  useCustomValidity(ref, customValidity);
  return /* @__PURE__ */jsxRuntime.jsx(Root$d, {
    "data-ui": "TextArea",
    children: /* @__PURE__ */jsxRuntime.jsxs(InputRoot$1, {
      children: [/* @__PURE__ */jsxRuntime.jsx(Input$1, {
        "data-as": "textarea",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: useArrayProp(fontSize),
        $padding: useArrayProp(padding),
        $scheme: rootTheme.scheme,
        $space: useArrayProp(0),
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        ref
      }), /* @__PURE__ */jsxRuntime.jsx(Presentation$1, {
        $radius: useArrayProp(radius),
        $scheme: rootTheme.scheme,
        $tone: rootTheme.tone,
        "data-border": border ? "" : void 0,
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone
      })]
    })
  });
});
var __freeze$g = Object.freeze;
var __defProp$g = Object.defineProperty;
var __template$g = (cooked, raw) => __freeze$g(__defProp$g(cooked, "raw", {
  value: __freeze$g(raw || cooked.slice())
}));
var _a$g, _b$a, _c$5, _d$3, _e$1, _f$1;
const CLEAR_BUTTON_BOX_STYLE = {
  zIndex: 2
};
const Root$c = styled__default.default(Card).attrs({
  forwardedAs: "span"
})(textInputRootStyle);
const InputRoot = styled__default.default.span(_a$g || (_a$g = __template$g(["\n  flex: 1;\n  min-width: 0;\n  display: block;\n  position: relative;\n"])));
const Prefix = styled__default.default(Card).attrs({
  forwardedAs: "span"
})(_b$a || (_b$a = __template$g(["\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n\n  & > span {\n    display: block;\n    margin: -1px;\n  }\n"])));
const Suffix = styled__default.default(Card).attrs({
  forwardedAs: "span"
})(_c$5 || (_c$5 = __template$g(["\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n\n  & > span {\n    display: block;\n    margin: -1px;\n  }\n"])));
const Input = styled__default.default.input(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
const Presentation = styled__default.default.span(responsiveRadiusStyle, textInputRepresentationStyle);
const LeftBox = styled__default.default(Box)(_d$3 || (_d$3 = __template$g(["\n  position: absolute;\n  top: 0;\n  left: 0;\n"])));
const RightBox = styled__default.default(Box)(_e$1 || (_e$1 = __template$g(["\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
const RightCard = styled__default.default(Card)(_f$1 || (_f$1 = __template$g(["\n  background-color: transparent;\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
const TextInputClearButton = styled__default.default(Button)({
  "&:not([hidden])": {
    display: "block"
  }
});
const TextInput = react.forwardRef(function TextInput2(props, forwardedRef) {
  const {
    border = true,
    clearButton,
    disabled = false,
    fontSize: fontSizeProp = 2,
    icon,
    iconRight,
    onClear,
    padding: paddingProp = 3,
    prefix,
    radius: radiusProp = 1,
    readOnly,
    space: spaceProp = 3,
    suffix,
    customValidity,
    type = "text",
    weight,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  const rootTheme = useRootTheme();
  const fontSize = useArrayProp(fontSizeProp);
  const padding = useArrayProp(paddingProp);
  const radius = useArrayProp(radiusProp);
  const space = useArrayProp(spaceProp);
  const $hasClearButton = Boolean(clearButton);
  const $hasIcon = Boolean(icon);
  const $hasIconRight = Boolean(iconRight);
  const $hasSuffix = Boolean(suffix);
  const $hasPrefix = Boolean(prefix);
  useCustomValidity(ref, customValidity);
  const handleClearMouseDown = react.useCallback(event => {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  const handleClearClick = react.useCallback(event => {
    var _a2;
    event.preventDefault();
    event.stopPropagation();
    if (onClear) onClear();
    (_a2 = ref.current) == null ? void 0 : _a2.focus();
  }, [onClear, ref]);
  const prefixNode = react.useMemo(() => prefix && /* @__PURE__ */jsxRuntime.jsx(Prefix, {
    borderTop: true,
    borderLeft: true,
    borderBottom: true,
    radius,
    sizing: "border",
    tone: "inherit",
    children: /* @__PURE__ */jsxRuntime.jsx("span", {
      children: prefix
    })
  }), [prefix, radius]);
  const presentationNode = react.useMemo(() => /* @__PURE__ */jsxRuntime.jsxs(Presentation, {
    $hasPrefix,
    $hasSuffix,
    $radius: radius,
    $scheme: rootTheme.scheme,
    $tone: rootTheme.tone,
    "data-border": border ? "" : void 0,
    "data-scheme": rootTheme.scheme,
    "data-tone": rootTheme.tone,
    children: [icon && /* @__PURE__ */jsxRuntime.jsx(LeftBox, {
      padding,
      children: /* @__PURE__ */jsxRuntime.jsxs(Text, {
        size: fontSize,
        children: [react.isValidElement(icon) && icon, ReactIs.isValidElementType(icon) && react.createElement(icon)]
      })
    }), !$hasClearButton && iconRight && /* @__PURE__ */jsxRuntime.jsx(RightBox, {
      padding,
      children: /* @__PURE__ */jsxRuntime.jsxs(Text, {
        size: fontSize,
        children: [react.isValidElement(iconRight) && iconRight, ReactIs.isValidElementType(iconRight) && react.createElement(iconRight)]
      })
    })]
  }), [border, fontSize, icon, iconRight, padding, radius, rootTheme, $hasClearButton, $hasPrefix, $hasSuffix]);
  const clearButtonBoxPadding = react.useMemo(() => padding.map(v => {
    if (v === 0) return 0;
    if (v === 1) return 1;
    if (v === 2) return 1;
    return v - 2;
  }), [padding]);
  const clearButtonPadding = react.useMemo(() => padding.map(v => {
    if (v === 0) return 0;
    if (v === 1) return 0;
    if (v === 2) return 1;
    return v - 1;
  }), [padding]);
  const clearButtonProps = react.useMemo(() => typeof clearButton === "object" ? clearButton : EMPTY_RECORD, [clearButton]);
  const clearButtonNode = react.useMemo(() => !disabled && !readOnly && clearButton && /* @__PURE__ */jsxRuntime.jsx(RightCard, {
    forwardedAs: "span",
    padding: clearButtonBoxPadding,
    style: CLEAR_BUTTON_BOX_STYLE,
    tone: customValidity ? "critical" : "inherit",
    children: /* @__PURE__ */jsxRuntime.jsx(TextInputClearButton, {
      "aria-label": "Clear",
      "data-qa": "clear-button",
      fontSize,
      icon: icons.CloseIcon,
      mode: "bleed",
      padding: clearButtonPadding,
      radius,
      ...clearButtonProps,
      onClick: handleClearClick,
      onMouseDown: handleClearMouseDown
    })
  }), [clearButton, clearButtonBoxPadding, clearButtonPadding, clearButtonProps, customValidity, disabled, fontSize, handleClearClick, handleClearMouseDown, radius, readOnly]);
  const suffixNode = react.useMemo(() => suffix && /* @__PURE__ */jsxRuntime.jsx(Suffix, {
    borderTop: true,
    borderRight: true,
    borderBottom: true,
    radius,
    sizing: "border",
    tone: "inherit",
    children: /* @__PURE__ */jsxRuntime.jsx("span", {
      children: suffix
    })
  }), [radius, suffix]);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$c, {
    "data-ui": "TextInput",
    tone: rootTheme.tone,
    children: [prefixNode, /* @__PURE__ */jsxRuntime.jsxs(InputRoot, {
      children: [/* @__PURE__ */jsxRuntime.jsx(Input, {
        "data-as": "input",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: fontSize,
        $iconLeft: $hasIcon,
        $iconRight: $hasIconRight || $hasClearButton,
        $padding: padding,
        $scheme: rootTheme.scheme,
        $space: space,
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        readOnly,
        ref,
        type
      }), presentationNode, clearButtonNode]
    }), suffixNode]
  });
});
function useDelayedState(initialState) {
  const [state, setState] = react.useState(initialState);
  const delayedAction = react.useRef();
  const onStateChange = react.useCallback((nextState, delay) => {
    const action = () => {
      setState(nextState);
    };
    if (delayedAction.current) {
      clearTimeout(delayedAction.current);
      delayedAction.current = void 0;
    }
    if (!delay) return action();
    delayedAction.current = setTimeout(action, delay);
  }, []);
  return [state, onStateChange];
}
const DEFAULT_FALLBACK_PLACEMENTS = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
var __freeze$f = Object.freeze;
var __defProp$f = Object.defineProperty;
var __template$f = (cooked, raw) => __freeze$f(__defProp$f(cooked, "raw", {
  value: __freeze$f(raw || cooked.slice())
}));
var _a$f, _b$9, _c$4;
const Root$b = styled__default.default.div(_a$f || (_a$f = __template$f(["\n  position: absolute;\n  pointer-events: none;\n  width: 15px;\n  height: 15px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    display: block;\n    transform-origin: 7.5px 7.5px;\n  }\n\n  /* position: absolute;\n  width: 15px;\n  height: 15px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    &:not([hidden]) {\n      display: block;\n    }\n    transform-origin: 7.5px 7.5px;\n  } */\n\n  [data-placement^='top'] > & {\n    bottom: -27px;\n  }\n\n  [data-placement^='right'] > & {\n    left: -27px;\n\n    & > svg {\n      transform: rotate(90deg);\n    }\n  }\n\n  [data-placement^='left'] > & {\n    right: -27px;\n\n    & > svg {\n      transform: rotate(-90deg);\n    }\n  }\n\n  [data-placement^='bottom'] > & {\n    top: -27px;\n\n    & > svg {\n      transform: rotate(180deg);\n    }\n  }\n"])));
const Border = styled__default.default.path(_b$9 || (_b$9 = __template$f(["\n  fill: var(--card-shadow-outline-color);\n"])));
const Shape = styled__default.default.path(_c$4 || (_c$4 = __template$f(["\n  fill: var(--card-bg-color);\n"])));
const TooltipArrow = react.forwardRef(function TooltipArrow2(props, ref) {
  const {
    ...restProps
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(Root$b, {
    "data-ui": "Tooltip__arrow",
    ...restProps,
    ref,
    children: /* @__PURE__ */jsxRuntime.jsxs("svg", {
      width: "15",
      height: "15",
      viewBox: "0 0 15 15",
      children: [/* @__PURE__ */jsxRuntime.jsx(Border, {
        d: "M11.5266 1C11.032 1.32802 10.5837 1.73105 10.1995 2.20057L9.04792 3.6081C8.24771 4.58614 6.7523 4.58614 5.95209 3.6081L4.80047 2.20057C4.41632 1.73105 3.96796 1.32802 3.47341 1H0.156727C1.65639 1 3.07687 1.67313 4.02651 2.83381L5.17813 4.24134C6.37844 5.70839 8.62156 5.70839 9.82187 4.24134L10.9735 2.83381C11.9231 1.67313 13.3436 1 14.8433 1H11.5266Z"
      }), /* @__PURE__ */jsxRuntime.jsx(Shape, {
        d: "M0.156725 0C1.95632 0 3.66089 0.80776 4.80047 2.20057L5.95209 3.6081C6.75229 4.58614 8.24771 4.58614 9.04791 3.6081L10.1995 2.20057C11.3391 0.80776 13.0437 0 14.8433 0H15H0H0.156725Z"
      })]
    })
  });
});
const key$4 = Symbol.for("@sanity/ui/context/tooltipDelayGroup");
globalScope[key$4] = globalScope[key$4] || react.createContext(null);
const TooltipDelayGroupContext = globalScope[key$4];
function useTooltipDelayGroup() {
  const value = react.useContext(TooltipDelayGroupContext);
  return value;
}
function TooltipDelayGroupProvider(props) {
  const {
    children,
    delay
  } = props;
  const [isGroupActive, setIsGroupActive] = useDelayedState(false);
  const [openTooltipId, setOpenTooltipId] = useDelayedState(null);
  const isInsideContext = useTooltipDelayGroup();
  if (isInsideContext) {
    throw new Error("TooltipDelayGroupProvider cannot be nested inside another TooltipDelayGroupProvider");
  }
  const openDelay = typeof delay === "number" ? delay : (delay == null ? void 0 : delay.open) || 0;
  const closeDelay = typeof delay === "number" ? delay : (delay == null ? void 0 : delay.close) || 0;
  const value = react.useMemo(() => ({
    isGroupActive,
    setIsGroupActive,
    openTooltipId,
    setOpenTooltipId,
    // When the group is active, we want the next tooltip to open immediately.
    openDelay: isGroupActive ? 1 : openDelay,
    closeDelay
  }), [closeDelay, isGroupActive, openDelay, openTooltipId, setIsGroupActive, setOpenTooltipId]);
  return /* @__PURE__ */jsxRuntime.jsx(TooltipDelayGroupContext.Provider, {
    value,
    children
  });
}
var __freeze$e = Object.freeze;
var __defProp$e = Object.defineProperty;
var __template$e = (cooked, raw) => __freeze$e(__defProp$e(cooked, "raw", {
  value: __freeze$e(raw || cooked.slice())
}));
var _a$e;
const Root$a = styled__default.default(Layer)(_a$e || (_a$e = __template$e(["\n  pointer-events: none;\n"])));
const Tooltip = react.forwardRef(function Tooltip2(props, ref) {
  var _a2, _b, _c, _d, _e;
  const boundaryElementContext = useBoundaryElement();
  const theme = useTheme();
  const {
    boundaryElement = boundaryElementContext == null ? void 0 : boundaryElementContext.element,
    children: childProp,
    content,
    disabled,
    fallbackPlacements: fallbackPlacementsProp = (_b = props.fallbackPlacements) != null ? _b : DEFAULT_FALLBACK_PLACEMENTS[(_a2 = props.placement) != null ? _a2 : "bottom"],
    padding,
    placement: placementProp = "bottom",
    portal,
    scheme,
    shadow = 2,
    zOffset = (_c = theme.sanity.layer) == null ? void 0 : _c.tooltip.zOffset,
    delay,
    ...restProps
  } = props;
  const fallbackPlacements = useArrayProp(fallbackPlacementsProp);
  const forwardedRef = useForwardedRef(ref);
  const [referenceElement, setReferenceElement] = react.useState(null);
  const arrowRef = react.useRef(null);
  const rootBoundary = "viewport";
  const middleware = react.useMemo(() => {
    const ret = [];
    ret.push(reactDom$1.flip({
      boundary: boundaryElement || void 0,
      fallbackPlacements,
      padding: 4,
      rootBoundary,
      mainAxis: false
    }));
    ret.push(reactDom$1.offset({
      mainAxis: 3
    }));
    ret.push(reactDom$1.size({
      apply(_ref22) {
        let {
          availableWidth,
          availableHeight,
          elements
        } = _ref22;
        Object.assign(elements.floating.style, {
          maxWidth: "".concat(availableWidth - 4 * 2, "px"),
          // the padding is `4px`
          maxHeight: "".concat(availableHeight - 4 * 2, "px")
          // the padding is `4px`
        });
      }
    }));

    ret.push(reactDom$1.shift({
      boundary: boundaryElement || void 0,
      rootBoundary,
      padding: 4
    }));
    ret.push(reactDom$1.arrow({
      element: arrowRef,
      padding: 2
    }));
    return ret;
  }, [boundaryElement, fallbackPlacements]);
  const {
    floatingStyles,
    placement,
    middlewareData,
    refs,
    update
  } = reactDom$1.useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: reactDom$1.autoUpdate
  });
  const staticSide = placement && FLOATING_STATIC_SIDES[placement.split("-")[0]];
  const arrowX = (_d = middlewareData.arrow) == null ? void 0 : _d.x;
  const arrowY = (_e = middlewareData.arrow) == null ? void 0 : _e.y;
  const arrowStyle = react.useMemo(() => {
    const style = {
      left: arrowX !== null ? arrowX : void 0,
      top: arrowY !== null ? arrowY : void 0,
      right: void 0,
      bottom: void 0
    };
    if (staticSide) style[staticSide] = -15;
    return style;
  }, [arrowX, arrowY, staticSide]);
  const tooltipId = react.useId();
  const [isOpen, setIsOpen] = useDelayedState(false);
  const delayGroupContext = useTooltipDelayGroup();
  const showTooltip = isOpen || (delayGroupContext == null ? void 0 : delayGroupContext.openTooltipId) === tooltipId;
  const isInsideGroup = delayGroupContext !== null;
  const openDelayProp = typeof delay === "number" ? delay : (delay == null ? void 0 : delay.open) || 0;
  const closeDelayProp = typeof delay === "number" ? delay : (delay == null ? void 0 : delay.close) || 0;
  const openDelay = isInsideGroup ? delayGroupContext.openDelay : openDelayProp;
  const closeDelay = isInsideGroup ? delayGroupContext.closeDelay : closeDelayProp;
  const handleIsOpenChange = react.useCallback(open => {
    if (isInsideGroup) {
      if (open) {
        delayGroupContext.setIsGroupActive(open, openDelay);
        delayGroupContext.setOpenTooltipId(tooltipId, openDelay);
      } else {
        const minimumGroupDeactivateDelay = 200;
        const groupDeactivateDelay = closeDelay > minimumGroupDeactivateDelay ? closeDelay : minimumGroupDeactivateDelay;
        delayGroupContext.setIsGroupActive(open, groupDeactivateDelay);
        delayGroupContext.setOpenTooltipId(null, closeDelay);
      }
    } else {
      setIsOpen(open, open ? openDelay : closeDelay);
    }
  }, [isInsideGroup, delayGroupContext, openDelay, tooltipId, closeDelay, setIsOpen]);
  const handleBlur = react.useCallback(() => handleIsOpenChange(false), [handleIsOpenChange]);
  const handleFocus = react.useCallback(() => handleIsOpenChange(true), [handleIsOpenChange]);
  const handleMouseEnter = react.useCallback(() => handleIsOpenChange(true), [handleIsOpenChange]);
  const handleMouseLeave = react.useCallback(() => handleIsOpenChange(false), [handleIsOpenChange]);
  react.useEffect(() => {
    if (!isOpen) return;
    function handleWindowMouseMove(event) {
      if (!referenceElement) return;
      const isHoveringReference = referenceElement === event.target || event.target instanceof Node && referenceElement.contains(event.target);
      if (!isHoveringReference) {
        handleIsOpenChange(false);
        window.removeEventListener("mousemove", handleWindowMouseMove);
      }
    }
    window.addEventListener("mousemove", handleWindowMouseMove);
    return () => {
      window.removeEventListener("mousemove", handleWindowMouseMove);
    };
  }, [isOpen, referenceElement, handleIsOpenChange]);
  react.useEffect(() => {
    if (disabled) handleIsOpenChange(false);
  }, [disabled, handleIsOpenChange]);
  react.useEffect(() => {
    if (!content) handleIsOpenChange(false);
  }, [content, handleIsOpenChange]);
  react.useEffect(() => refs.setReference(referenceElement), [referenceElement, refs]);
  const setArrow = react.useCallback(arrowEl => {
    arrowRef.current = arrowEl;
    update();
  }, [update]);
  const setFloating = react.useCallback(node => {
    forwardedRef.current = node;
    refs.setFloating(node);
  }, [forwardedRef, refs]);
  const childRef = childProp == null ? void 0 : childProp.ref;
  const setReference = react.useCallback(node => {
    if (typeof childRef === "function") {
      childRef(node);
    } else if (childRef) {
      childRef.current = node;
    }
    setReferenceElement(node);
  }, [childRef]);
  const child = react.useMemo(() => {
    if (!childProp) return null;
    return react.cloneElement(childProp, {
      onBlur: handleBlur,
      onFocus: handleFocus,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      ref: setReference
    });
  }, [childProp, handleBlur, handleFocus, handleMouseEnter, handleMouseLeave, setReference]);
  if (!child) return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {});
  if (disabled) return child;
  const root = /* @__PURE__ */jsxRuntime.jsx(Root$a, {
    "data-ui": "Tooltip",
    ...restProps,
    ref: setFloating,
    style: floatingStyles,
    zOffset,
    children: /* @__PURE__ */jsxRuntime.jsxs(Card, {
      "data-ui": "Tooltip__card",
      "data-placement": placement,
      padding,
      radius: 2,
      scheme,
      shadow,
      children: [content, /* @__PURE__ */jsxRuntime.jsx(TooltipArrow, {
        ref: setArrow,
        style: arrowStyle
      })]
    })
  });
  return /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [child, showTooltip && /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {
      children: portal ? /* @__PURE__ */jsxRuntime.jsx(Portal, {
        __unstable_name: typeof portal === "string" ? portal : void 0,
        children: root
      }) : root
    })]
  });
});
var __freeze$d = Object.freeze;
var __defProp$d = Object.defineProperty;
var __template$d = (cooked, raw) => __freeze$d(__defProp$d(cooked, "raw", {
  value: __freeze$d(raw || cooked.slice())
}));
var _a$d, _b$8, _c$3, _d$2;
const Root$9 = styled__default.default.div(_a$d || (_a$d = __template$d(["\n  line-height: 0;\n"])));
const ListBox = styled__default.default(Box)(_b$8 || (_b$8 = __template$d(["\n  & > ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n  }\n"])));
const rotate = styled.keyframes(_c$3 || (_c$3 = __template$d(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"])));
const AnimatedSpinnerIcon = styled__default.default(icons.SpinnerIcon)(_d$2 || (_d$2 = __template$d(["\n  animation: ", " 500ms linear infinite;\n"])), rotate);
function AutocompleteOption(props) {
  const {
    children,
    id,
    onSelect,
    selected,
    value
  } = props;
  const handleClick = react.useCallback(() => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, [onSelect, value]);
  const handleKeyDown = react.useCallback(event => {
    if (event.key === "Enter" && !_isEnterToClickElement(event.currentTarget)) {
      handleClick();
    }
  }, [handleClick]);
  return /* @__PURE__ */jsxRuntime.jsx("li", {
    "aria-selected": selected,
    "data-ui": "AutocompleteOption",
    id,
    role: "option",
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    children
  });
}
function autocompleteReducer(state, msg) {
  if (msg.type === "input/change") {
    return {
      ...state,
      activeValue: null,
      focused: true,
      query: msg.query
    };
  }
  if (msg.type === "input/focus") {
    return {
      ...state,
      focused: true
    };
  }
  if (msg.type === "root/blur") {
    return {
      ...state,
      focused: false,
      query: null
    };
  }
  if (msg.type === "root/clear") {
    return {
      ...state,
      activeValue: null,
      query: null,
      value: null
    };
  }
  if (msg.type === "root/escape") {
    return {
      ...state,
      focused: false,
      query: null
    };
  }
  if (msg.type === "root/open") {
    return {
      ...state,
      query: state.query || msg.query
    };
  }
  if (msg.type === "root/setActiveValue") {
    return {
      ...state,
      activeValue: msg.value,
      listFocused: msg.listFocused || state.listFocused
    };
  }
  if (msg.type === "root/setListFocused") {
    return {
      ...state,
      listFocused: msg.listFocused
    };
  }
  if (msg.type === "value/change") {
    return {
      ...state,
      activeValue: msg.value,
      query: null,
      value: msg.value
    };
  }
  return state;
}
const AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = ["Control", "Shift", "Alt", "Enter", "Home", "End", "PageUp", "PageDown", "Meta", "Tab", "CapsLock"];
const AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start";
const AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"];
const DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value;
const DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1;
const InnerAutocomplete = react.forwardRef(function InnerAutocomplete2(props, ref) {
  const {
    border = true,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize = 2,
    icon,
    id,
    listBox = EMPTY_RECORD,
    loading,
    onBlur,
    onChange,
    onFocus,
    onQueryChange,
    onSelect,
    openButton,
    options: optionsProp,
    padding: paddingProp = 3,
    popover = EMPTY_RECORD,
    prefix,
    radius = 3,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue = DEFAULT_RENDER_VALUE,
    suffix,
    value: valueProp,
    ...restProps
  } = props;
  const [state, dispatch] = react.useReducer(autocompleteReducer, {
    activeValue: valueProp || null,
    focused: false,
    listFocused: false,
    query: null,
    value: valueProp || null
  });
  const {
    activeValue,
    focused,
    listFocused,
    query,
    value
  } = state;
  const defaultRenderOption = react.useCallback(_ref23 => {
    let {
      value: value2
    } = _ref23;
    return /* @__PURE__ */jsxRuntime.jsx(Card, {
      "data-as": "button",
      padding: paddingProp,
      radius: 2,
      tone: "inherit",
      children: /* @__PURE__ */jsxRuntime.jsx(Text, {
        size: fontSize,
        textOverflow: "ellipsis",
        children: value2
      })
    });
  }, [fontSize, paddingProp]);
  const renderOption = typeof renderOptionProp === "function" ? renderOptionProp : defaultRenderOption;
  const filterOption = typeof filterOptionProp === "function" ? filterOptionProp : DEFAULT_FILTER_OPTION;
  const rootElementRef = react.useRef(null);
  const resultsPopoverElementRef = react.useRef(null);
  const inputElementRef = react.useRef(null);
  const listBoxElementRef = react.useRef(null);
  const listFocusedRef = react.useRef(false);
  const valueRef = react.useRef(value);
  const valuePropRef = react.useRef(valueProp);
  const popoverMouseWithinRef = react.useRef(false);
  const forwardedRef = useForwardedRef(ref);
  const listBoxId = "".concat(id, "-listbox");
  const options = Array.isArray(optionsProp) ? optionsProp : EMPTY_ARRAY;
  const padding = useArrayProp(paddingProp);
  const currentOption = react.useMemo(() => value !== null ? options.find(o => o.value === value) : void 0, [options, value]);
  const filteredOptions = react.useMemo(() => options.filter(option => query ? filterOption(query, option) : true), [filterOption, options, query]);
  const filteredOptionsLen = filteredOptions.length;
  const activeItemId = activeValue ? "".concat(id, "-option-").concat(activeValue) : void 0;
  const expanded = query !== null && loading || focused && query !== null;
  const handleRootBlur = react.useCallback(event => {
    setTimeout(() => {
      if (popoverMouseWithinRef.current) {
        return;
      }
      const elements = (relatedElements || []).concat(rootElementRef.current ? [rootElementRef.current] : [], resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []);
      let focusInside = false;
      if (document.activeElement) {
        for (const e of elements) {
          if (e === document.activeElement || e.contains(document.activeElement)) {
            focusInside = true;
            break;
          }
        }
      }
      if (focusInside === false) {
        dispatch({
          type: "root/blur"
        });
        popoverMouseWithinRef.current = false;
        if (onQueryChange) onQueryChange(null);
        if (onBlur) onBlur(event);
      }
    }, 0);
  }, [onBlur, onQueryChange, relatedElements]);
  const handleRootFocus = react.useCallback(event => {
    const listBoxElement = listBoxElementRef.current;
    const focusedElement = event.target instanceof HTMLElement ? event.target : null;
    const listFocused2 = (listBoxElement == null ? void 0 : listBoxElement.contains(focusedElement)) || false;
    if (listFocused2 !== listFocusedRef.current) {
      listFocusedRef.current = listFocused2;
      dispatch({
        type: "root/setListFocused",
        listFocused: listFocused2
      });
    }
  }, []);
  const handleOptionSelect = react.useCallback(v => {
    var _a;
    dispatch({
      type: "value/change",
      value: v
    });
    popoverMouseWithinRef.current = false;
    if (onSelect) onSelect(v);
    valueRef.current = v;
    if (onChange) onChange(v);
    if (onQueryChange) onQueryChange(null);
    (_a = inputElementRef.current) == null ? void 0 : _a.focus();
  }, [onChange, onSelect, onQueryChange]);
  const handleRootKeyDown = react.useCallback(event => {
    var _a, _b;
    if (event.key === "ArrowDown") {
      event.preventDefault();
      if (!filteredOptionsLen) return;
      const activeOption = filteredOptions.find(o => o.value === activeValue);
      const activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1;
      const nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
      if (nextActiveOption) {
        dispatch({
          type: "root/setActiveValue",
          value: nextActiveOption.value,
          listFocused: true
        });
      }
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      if (!filteredOptionsLen) return;
      const activeOption = filteredOptions.find(o => o.value === activeValue);
      const activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1;
      const nextActiveOption = filteredOptions[activeIndex === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex - 1) % filteredOptionsLen];
      if (nextActiveOption) {
        dispatch({
          type: "root/setActiveValue",
          value: nextActiveOption.value,
          listFocused: true
        });
      }
      return;
    }
    if (event.key === "Escape") {
      dispatch({
        type: "root/escape"
      });
      popoverMouseWithinRef.current = false;
      if (onQueryChange) onQueryChange(null);
      (_a = inputElementRef.current) == null ? void 0 : _a.focus();
      return;
    }
    const target = event.target;
    const listEl = listBoxElementRef.current;
    if ((listEl === target || (listEl == null ? void 0 : listEl.contains(target))) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event.key)) {
      (_b = inputElementRef.current) == null ? void 0 : _b.focus();
      return;
    }
  }, [activeValue, filteredOptions, filteredOptionsLen, onQueryChange]);
  const handleInputChange = react.useCallback(event => {
    const nextQuery = event.currentTarget.value;
    dispatch({
      type: "input/change",
      query: nextQuery
    });
    if (onQueryChange) onQueryChange(nextQuery);
  }, [onQueryChange]);
  const handleInputFocus = react.useCallback(event => {
    if (!focused) {
      dispatch({
        type: "input/focus"
      });
      if (onFocus) onFocus(event);
    }
  }, [focused, onFocus]);
  const handlePopoverMouseEnter = react.useCallback(() => {
    popoverMouseWithinRef.current = true;
  }, []);
  const handlePopoverMouseLeave = react.useCallback(() => {
    popoverMouseWithinRef.current = false;
  }, []);
  const handleClearButtonClick = react.useCallback(() => {
    var _a;
    dispatch({
      type: "root/clear"
    });
    valueRef.current = "";
    if (onChange) onChange("");
    if (onQueryChange) onQueryChange(null);
    (_a = inputElementRef.current) == null ? void 0 : _a.focus();
  }, [onChange, onQueryChange]);
  const handleClearButtonFocus = react.useCallback(() => {
    dispatch({
      type: "input/focus"
    });
  }, []);
  react.useEffect(() => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp;
      if (valueProp !== void 0) {
        dispatch({
          type: "value/change",
          value: valueProp
        });
        valueRef.current = valueProp;
      }
      return;
    }
    if (valueProp !== valueRef.current) {
      valueRef.current = valueProp || null;
      dispatch({
        type: "value/change",
        value: valueProp || null
      });
    }
  }, [valueProp]);
  react.useEffect(() => {
    if (!focused && valueRef.current) {
      dispatch({
        type: "root/setActiveValue",
        value: valueRef.current
      });
    }
  }, [focused]);
  react.useEffect(() => {
    const listElement = listBoxElementRef.current;
    if (!listElement) return;
    const activeOption = filteredOptions.find(o => o.value === activeValue);
    if (activeOption) {
      const activeIndex = filteredOptions.indexOf(activeOption);
      const activeItemElement = listElement.childNodes[activeIndex];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement)) {
          return;
        }
        focusFirstDescendant(activeItemElement);
      }
    }
  }, [activeValue, filteredOptions]);
  const setRef = react.useCallback(el => {
    inputElementRef.current = el;
    forwardedRef.current = el;
  }, [forwardedRef]);
  const clearButton = react.useMemo(() => {
    if (!loading && !disabled && value) {
      return {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      };
    }
    return void 0;
  }, [disabled, handleClearButtonFocus, loading, value]);
  const openButtonBoxPadding = react.useMemo(() => padding.map(v => {
    if (v === 0) return 0;
    if (v === 1) return 1;
    if (v === 2) return 1;
    return v - 2;
  }), [padding]);
  const openButtonPadding = react.useMemo(() => padding.map(v => Math.max(v - 1, 0)), [padding]);
  const openButtonProps = react.useMemo(() => typeof openButton === "object" ? openButton : EMPTY_RECORD, [openButton]);
  const handleOpenClick = react.useCallback(event => {
    dispatch({
      type: "root/open",
      query: value ? renderValue(value, currentOption) : ""
    });
    if (openButtonProps.onClick) openButtonProps.onClick(event);
    _raf(() => {
      var _a;
      return (_a = inputElementRef.current) == null ? void 0 : _a.focus();
    });
  }, [currentOption, openButtonProps, renderValue, value]);
  const openButtonNode = react.useMemo(() => !disabled && !readOnly && openButton ? /* @__PURE__ */jsxRuntime.jsx(Box, {
    "aria-hidden": expanded,
    padding: openButtonBoxPadding,
    children: /* @__PURE__ */jsxRuntime.jsx(Button, {
      "aria-label": "Open",
      disabled: expanded,
      fontSize,
      icon: icons.ChevronDownIcon,
      mode: "bleed",
      padding: openButtonPadding,
      ...openButtonProps,
      onClick: handleOpenClick
    })
  }) : void 0, [disabled, expanded, fontSize, handleOpenClick, openButton, openButtonBoxPadding, openButtonPadding, openButtonProps, readOnly]);
  const inputValue = react.useMemo(() => {
    if (query === null) {
      if (value !== null) {
        return renderValue(value, currentOption);
      }
      return "";
    }
    return query;
  }, [currentOption, query, renderValue, value]);
  const input = /* @__PURE__ */jsxRuntime.jsx(TextInput, {
    ...restProps,
    "aria-activedescendant": activeItemId,
    "aria-autocomplete": "list",
    "aria-expanded": expanded,
    "aria-owns": listBoxId,
    autoCapitalize: "off",
    autoComplete: "off",
    autoCorrect: "off",
    border,
    clearButton,
    customValidity,
    disabled,
    fontSize,
    icon,
    iconRight: loading && AnimatedSpinnerIcon,
    id,
    inputMode: "search",
    onChange: handleInputChange,
    onClear: handleClearButtonClick,
    onFocus: handleInputFocus,
    padding,
    prefix,
    radius,
    readOnly,
    ref: setRef,
    role: "combobox",
    spellCheck: false,
    suffix: suffix || openButtonNode,
    value: inputValue
  });
  const handleListBoxKeyDown = react.useCallback(event => {
    var _a;
    if (event.key === "Tab") {
      if (listFocused) (_a = inputElementRef.current) == null ? void 0 : _a.focus();
    }
  }, [listFocused]);
  const content = react.useMemo(() => {
    if (filteredOptions.length === 0) return null;
    return /* @__PURE__ */jsxRuntime.jsx(ListBox, {
      "data-ui": "AutoComplete__results",
      onKeyDown: handleListBoxKeyDown,
      padding: 1,
      ...listBox,
      tabIndex: -1,
      children: /* @__PURE__ */jsxRuntime.jsx(Stack, {
        as: "ul",
        "aria-multiselectable": false,
        "data-ui": "AutoComplete__resultsList",
        id: listBoxId,
        ref: listBoxElementRef,
        role: "listbox",
        space: 1,
        children: filteredOptions.map(option => {
          const active = activeValue !== null ? option.value === activeValue : currentOption === option;
          return /* @__PURE__ */jsxRuntime.jsx(AutocompleteOption, {
            id: "".concat(id, "-option-").concat(option.value),
            onSelect: handleOptionSelect,
            selected: active,
            value: option.value,
            children: react.cloneElement(renderOption(option), {
              disabled: loading,
              selected: active,
              tabIndex: listFocused && active ? 0 : -1
            })
          }, option.value);
        })
      })
    });
  }, [activeValue, currentOption, filteredOptions, handleOptionSelect, handleListBoxKeyDown, id, listBox, listBoxId, listFocused, loading, renderOption]);
  const results = react.useMemo(() => {
    if (renderPopover) {
      return renderPopover({
        content,
        hidden: !expanded,
        inputElement: inputElementRef.current,
        onMouseEnter: handlePopoverMouseEnter,
        onMouseLeave: handlePopoverMouseLeave
      }, resultsPopoverElementRef);
    }
    if (filteredOptionsLen === 0) {
      return null;
    }
    return /* @__PURE__ */jsxRuntime.jsx(Popover, {
      arrow: false,
      constrainSize: true,
      content,
      fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS,
      matchReferenceWidth: true,
      onMouseEnter: handlePopoverMouseEnter,
      onMouseLeave: handlePopoverMouseLeave,
      open: expanded,
      overflow: "auto",
      placement: AUTOCOMPLETE_POPOVER_PLACEMENT,
      portal: true,
      radius,
      ref: resultsPopoverElementRef,
      referenceElement: inputElementRef.current,
      ...popover
    });
  }, [content, expanded, filteredOptionsLen, handlePopoverMouseEnter, handlePopoverMouseLeave, popover, radius, renderPopover]);
  return /* @__PURE__ */jsxRuntime.jsxs(Root$9, {
    "data-ui": "Autocomplete",
    onBlur: handleRootBlur,
    onFocus: handleRootFocus,
    onKeyDown: handleRootKeyDown,
    ref: rootElementRef,
    children: [input, results]
  });
});
const Autocomplete = InnerAutocomplete;
var __freeze$c = Object.freeze;
var __defProp$c = Object.defineProperty;
var __template$c = (cooked, raw) => __freeze$c(__defProp$c(cooked, "raw", {
  value: __freeze$c(raw || cooked.slice())
}));
var _a$c, _b$7;
const Root$8 = styled__default.default.ol(_a$c || (_a$c = __template$c(["\n  margin: 0;\n  padding: 0;\n  display: flex;\n  list-style: none;\n  align-items: center;\n  white-space: nowrap;\n  line-height: 0;\n"])));
const ExpandButton = styled__default.default(Button)(_b$7 || (_b$7 = __template$c(["\n  appearance: none;\n  margin: -4px;\n"])));
const Breadcrumbs = react.forwardRef(function Breadcrumbs2(props, ref) {
  const {
    children,
    maxLength,
    separator,
    space: spaceRaw = 2,
    ...restProps
  } = props;
  const space = useArrayProp(spaceRaw);
  const [open, setOpen] = react.useState(false);
  const [expandElement, setExpandElement] = react.useState(null);
  const [popoverElement, setPopoverElement] = react.useState(null);
  const collapse = react.useCallback(() => setOpen(false), []);
  const expand = react.useCallback(() => setOpen(true), []);
  useClickOutside(collapse, [expandElement, popoverElement]);
  const rawItems = react.useMemo(() => react.Children.toArray(children).filter(child => {
    return react.isValidElement(child);
  }), [children]);
  const items = react.useMemo(() => {
    const len = rawItems.length;
    if (maxLength && len > maxLength) {
      const beforeLength = Math.ceil(maxLength / 2);
      const afterLength = Math.floor(maxLength / 2);
      return [...rawItems.slice(0, beforeLength - 1), /* @__PURE__ */jsxRuntime.jsx(Popover, {
        constrainSize: true,
        content: /* @__PURE__ */jsxRuntime.jsx(Stack, {
          as: "ol",
          overflow: "auto",
          padding: space,
          space,
          children: rawItems.slice(beforeLength - 1, len - afterLength)
        }),
        open,
        placement: "top",
        portal: true,
        ref: setPopoverElement,
        children: /* @__PURE__ */jsxRuntime.jsx(ExpandButton, {
          fontSize: 1,
          mode: "bleed",
          onClick: open ? collapse : expand,
          padding: 1,
          ref: setExpandElement,
          selected: open,
          text: "\u2026"
        })
      }, "button"), ...rawItems.slice(len - afterLength)];
    }
    return rawItems;
  }, [collapse, expand, maxLength, open, rawItems, space]);
  return /* @__PURE__ */jsxRuntime.jsx(Root$8, {
    "data-ui": "Breadcrumbs",
    ...restProps,
    ref,
    children: items.map((item, itemIndex) => /* @__PURE__ */jsxRuntime.jsxs(react.Fragment, {
      children: [itemIndex > 0 && /* @__PURE__ */jsxRuntime.jsx(Box, {
        "aria-hidden": true,
        as: "li",
        paddingX: space,
        children: separator || /* @__PURE__ */jsxRuntime.jsx(Text, {
          muted: true,
          children: "/"
        })
      }), /* @__PURE__ */jsxRuntime.jsx(Box, {
        as: "li",
        children: item
      })]
    }, itemIndex))
  });
});
function dialogStyle(_ref24) {
  let {
    theme
  } = _ref24;
  const color = theme.sanity.color.base;
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color.shadow.umbra
  };
}
function responsiveDialogPositionStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$position, position => ({
    "&&": {
      position
    }
  }));
}
const key$3 = Symbol.for("@sanity/ui/context/dialog");
globalScope[key$3] = globalScope[key$3] || react.createContext({
  version: 0
});
const DialogContext = globalScope[key$3];
function useDialog() {
  return react.useContext(DialogContext);
}
var __freeze$b = Object.freeze;
var __defProp$b = Object.defineProperty;
var __template$b = (cooked, raw) => __freeze$b(__defProp$b(cooked, "raw", {
  value: __freeze$b(raw || cooked.slice())
}));
var _a$b, _b$6, _c$2, _d$1, _e, _f;
function isTargetWithinScope(boundaryElement, portalElement, target) {
  if (!boundaryElement || !portalElement) return true;
  return containsOrEqualsElement(boundaryElement, target) || containsOrEqualsElement(portalElement, target);
}
const Root$7 = styled__default.default(Layer)(responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle);
const DialogContainer = styled__default.default(Container)(_a$b || (_a$b = __template$b(["\n  &:not([hidden]) {\n    display: flex;\n  }\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n"])));
const DialogCardRoot = styled__default.default(Card)(_b$6 || (_b$6 = __template$b(["\n  &:not([hidden]) {\n    display: flex;\n  }\n  width: 100%;\n  min-height: 0;\n  max-height: 100%;\n  overflow: hidden;\n  overflow: clip;\n"])));
const DialogLayout = styled__default.default(Flex)(_c$2 || (_c$2 = __template$b(["\n  flex: 1;\n  min-height: 0;\n  width: 100%;\n"])));
const DialogHeader = styled__default.default(Card)(_d$1 || (_d$1 = __template$b(["\n  position: relative;\n  z-index: 2;\n\n  &:after {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: -1px;\n    border-bottom: 1px solid var(--card-hairline-soft-color);\n  }\n"])));
const DialogContent = styled__default.default(Box)(_e || (_e = __template$b(["\n  position: relative;\n  z-index: 1;\n  overflow: auto;\n  outline: none;\n"])));
const DialogFooter = styled__default.default(Box)(_f || (_f = __template$b(["\n  position: relative;\n  z-index: 3;\n  border-top: 1px solid var(--card-hairline-soft-color);\n"])));
const DialogCard = react.forwardRef(function DialogCard2(props, ref) {
  var _a2;
  const {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef,
    footer,
    header,
    id,
    onClickOutside,
    onClose,
    portal: portalProp,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props;
  const portal = usePortal();
  const portalElement = portalProp ? ((_a2 = portal.elements) == null ? void 0 : _a2[portalProp]) || null : portal.element;
  const boundaryElement = useBoundaryElement().element;
  const radius = useArrayProp(radiusProp);
  const shadow = useArrayProp(shadowProp);
  const width = useArrayProp(widthProp);
  const forwardedRef = useForwardedRef(ref);
  const [rootElement, setRootElement] = react.useState(null);
  const localContentRef = react.useRef(null);
  const layer = useLayer();
  const {
    isTopLayer
  } = layer;
  const labelId = "".concat(id, "_label");
  const showCloseButton = Boolean(onClose) && hideCloseButton === false;
  const showHeader = Boolean(header) || showCloseButton;
  react.useEffect(() => {
    if (!autoFocus) return;
    if (forwardedRef.current) {
      focusFirstDescendant(forwardedRef.current);
    }
  }, [autoFocus, forwardedRef]);
  useGlobalKeyDown(react.useCallback(event => {
    if (!isTopLayer || !onClose) return;
    const target = document.activeElement;
    if (target && !isTargetWithinScope(boundaryElement, portalElement, target)) {
      return;
    }
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      onClose();
    }
  }, [boundaryElement, isTopLayer, onClose, portalElement]));
  useClickOutside(react.useCallback(event => {
    if (!isTopLayer || !onClickOutside) return;
    const target = event.target;
    if (target && !isTargetWithinScope(boundaryElement, portalElement, target)) {
      return;
    }
    onClickOutside();
  }, [boundaryElement, isTopLayer, onClickOutside, portalElement]), [rootElement]);
  const setRef = react.useCallback(el => {
    setRootElement(el);
    forwardedRef.current = el;
  }, [forwardedRef]);
  const setContentRef = react.useCallback(el => {
    localContentRef.current = el;
    if (typeof contentRef === "function") contentRef(el);else if (contentRef) contentRef.current = el;
  }, [contentRef]);
  return /* @__PURE__ */jsxRuntime.jsx(DialogContainer, {
    "data-ui": "DialogCard",
    width,
    children: /* @__PURE__ */jsxRuntime.jsx(DialogCardRoot, {
      radius,
      ref: setRef,
      scheme,
      shadow,
      children: /* @__PURE__ */jsxRuntime.jsxs(DialogLayout, {
        direction: "column",
        children: [showHeader && /* @__PURE__ */jsxRuntime.jsx(DialogHeader, {
          children: /* @__PURE__ */jsxRuntime.jsxs(Flex, {
            children: [/* @__PURE__ */jsxRuntime.jsx(Box, {
              flex: 1,
              padding: 4,
              children: header && /* @__PURE__ */jsxRuntime.jsx(Text, {
                id: labelId,
                weight: "semibold",
                children: header
              })
            }), showCloseButton && /* @__PURE__ */jsxRuntime.jsx(Box, {
              padding: 2,
              children: /* @__PURE__ */jsxRuntime.jsx(Button, {
                "aria-label": "Close dialog",
                disabled: !onClose,
                icon: icons.CloseIcon,
                mode: "bleed",
                onClick: onClose,
                padding: 3
              })
            })]
          })
        }), /* @__PURE__ */jsxRuntime.jsx(DialogContent, {
          flex: 1,
          ref: setContentRef,
          tabIndex: -1,
          children
        }), footer && /* @__PURE__ */jsxRuntime.jsx(DialogFooter, {
          children: footer
        })]
      })
    })
  });
});
const Dialog = react.forwardRef(function Dialog2(props, ref) {
  var _a2, _b2;
  const dialog = useDialog();
  const theme = useTheme();
  const {
    __unstable_autoFocus: autoFocus = true,
    __unstable_hideCloseButton: hideCloseButton = false,
    cardRadius: cardRadiusProp = 3,
    cardShadow = 4,
    children,
    contentRef,
    footer,
    header,
    id,
    onActivate,
    onClickOutside,
    onClose,
    onFocus,
    padding: paddingProp = 4,
    portal: portalProp,
    position: positionProp = dialog.position || "fixed",
    scheme,
    width: widthProp = 0,
    zOffset: zOffsetProp = dialog.zOffset || ((_a2 = theme.sanity.layer) == null ? void 0 : _a2.dialog.zOffset),
    ...restProps
  } = props;
  const portal = usePortal();
  const portalElement = portalProp ? ((_b2 = portal.elements) == null ? void 0 : _b2[portalProp]) || null : portal.element;
  const boundaryElement = useBoundaryElement().element;
  const cardRadius = useArrayProp(cardRadiusProp);
  const padding = useArrayProp(paddingProp);
  const position = useArrayProp(positionProp);
  const width = useArrayProp(widthProp);
  const zOffset = useArrayProp(zOffsetProp);
  const preDivRef = react.useRef(null);
  const postDivRef = react.useRef(null);
  const cardRef = react.useRef(null);
  const focusedElementRef = react.useRef(null);
  const handleFocus = react.useCallback(event => {
    onFocus == null ? void 0 : onFocus(event);
    const target = event.target;
    const cardElement = cardRef.current;
    if (cardElement && target === preDivRef.current) {
      focusLastDescendant(cardElement);
      return;
    }
    if (cardElement && target === postDivRef.current) {
      focusFirstDescendant(cardElement);
      return;
    }
    if (isHTMLElement(event.target)) {
      focusedElementRef.current = event.target;
    }
  }, [onFocus]);
  const labelId = "".concat(id, "_label");
  const rootClickTimeoutRef = react.useRef();
  const handleRootClick = react.useCallback(() => {
    if (rootClickTimeoutRef.current) {
      clearTimeout(rootClickTimeoutRef.current);
    }
    rootClickTimeoutRef.current = setTimeout(() => {
      const activeElement = document.activeElement;
      if (activeElement && !isTargetWithinScope(boundaryElement, portalElement, activeElement)) {
        const target = focusedElementRef.current;
        if (!target || !document.body.contains(target)) {
          const cardElement = cardRef.current;
          if (cardElement) focusFirstDescendant(cardElement);
          return;
        }
        target.focus();
      }
    }, 0);
  }, [boundaryElement, portalElement]);
  return /* @__PURE__ */jsxRuntime.jsx(Portal, {
    __unstable_name: portalProp,
    children: /* @__PURE__ */jsxRuntime.jsxs(Root$7, {
      ...restProps,
      $padding: padding,
      $position: position,
      "aria-labelledby": labelId,
      "aria-modal": true,
      "data-ui": "Dialog",
      id,
      onActivate,
      onClick: handleRootClick,
      onFocus: handleFocus,
      ref,
      role: "dialog",
      zOffset,
      children: [/* @__PURE__ */jsxRuntime.jsx("div", {
        ref: preDivRef,
        tabIndex: 0
      }), /* @__PURE__ */jsxRuntime.jsx(DialogCard, {
        __unstable_autoFocus: autoFocus,
        __unstable_hideCloseButton: hideCloseButton,
        contentRef,
        footer,
        header,
        id,
        onClickOutside,
        onClose,
        portal: portalProp,
        radius: cardRadius,
        ref: cardRef,
        scheme,
        shadow: cardShadow,
        width,
        children
      }), /* @__PURE__ */jsxRuntime.jsx("div", {
        ref: postDivRef,
        tabIndex: 0
      })]
    })
  });
});
function DialogProvider(props) {
  const {
    children,
    position,
    zOffset
  } = props;
  const contextValue = react.useMemo(() => ({
    version: 0,
    position,
    zOffset
  }), [position, zOffset]);
  return /* @__PURE__ */jsxRuntime.jsx(DialogContext.Provider, {
    value: contextValue,
    children
  });
}
var __freeze$a = Object.freeze;
var __defProp$a = Object.defineProperty;
var __template$a = (cooked, raw) => __freeze$a(__defProp$a(cooked, "raw", {
  value: __freeze$a(raw || cooked.slice())
}));
var _a$a, _b$5;
const Root$6 = styled__default.default.kbd(_a$a || (_a$a = __template$a(["\n  &:not([hidden]) {\n    display: block;\n  }\n  font: inherit;\n"])));
const Key = styled__default.default(KBD)(_b$5 || (_b$5 = __template$a(["\n  &:not([hidden]) {\n    display: block;\n  }\n"])));
const Hotkeys = react.forwardRef(function Hotkeys2(props, ref) {
  const {
    fontSize,
    keys,
    padding,
    radius,
    space: spaceProp = 1,
    ...restProps
  } = props;
  const space = useArrayProp(spaceProp);
  if (!keys || keys.length === 0) {
    return /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {});
  }
  return /* @__PURE__ */jsxRuntime.jsx(Root$6, {
    "data-ui": "Hotkeys",
    ...restProps,
    ref,
    children: /* @__PURE__ */jsxRuntime.jsx(Inline, {
      as: "span",
      space,
      children: keys.map((key, i) => /* @__PURE__ */jsxRuntime.jsx(Key, {
        fontSize,
        padding,
        radius,
        children: key
      }, i))
    })
  });
});
const key$2 = Symbol.for("@sanity/ui/context/menu");
globalScope[key$2] = globalScope[key$2] || react.createContext(null);
const MenuContext = globalScope[key$2];
function _isFocusable(element) {
  return isHTMLAnchorElement(element) && element.getAttribute("data-disabled") !== "true" || isHTMLButtonElement(element) && !element.disabled;
}
function _getFocusableElements(elements) {
  return elements.filter(_isFocusable);
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  while (e !== rootElement) {
    const parentElement = e.parentElement;
    if (!parentElement) return path;
    const children = Array.from(parentElement.childNodes);
    const index = children.indexOf(e);
    path.unshift(index);
    if (parentElement === rootElement) {
      return path;
    }
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  if (!rootElement) return;
  const map = /* @__PURE__ */new WeakMap();
  for (const el of elements) {
    map.set(el, _getDOMPath(rootElement, el));
  }
  const _sort = (a, b) => {
    const _a = map.get(a) || EMPTY_PATH;
    const _b = map.get(b) || EMPTY_PATH;
    const len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1;
      const bIndex = _b[i] || -1;
      if (aIndex !== bIndex) {
        return aIndex - bIndex;
      }
    }
    return 0;
  };
  elements.sort(_sort);
}
function useMenuController(props) {
  const {
    onKeyDown,
    originElement,
    shouldFocus
  } = props;
  const elementsRef = react.useRef([]);
  const [rootElement, setRootElement] = react.useState(null);
  const [activeIndex, _setActiveIndex] = react.useState(-1);
  const activeIndexRef = react.useRef(activeIndex);
  const activeElement = elementsRef.current[activeIndex] || null;
  const mounted = Boolean(rootElement);
  const setActiveIndex = react.useCallback(nextActiveIndex => {
    _setActiveIndex(nextActiveIndex);
    activeIndexRef.current = nextActiveIndex;
  }, []);
  const mount = react.useCallback((element, selected) => {
    if (!element) return () => void 0;
    if (elementsRef.current.indexOf(element) === -1) {
      elementsRef.current.push(element);
      _sortElements(rootElement, elementsRef.current);
    }
    if (selected) {
      const selectedIndex = elementsRef.current.indexOf(element);
      setActiveIndex(selectedIndex);
    }
    return () => {
      const idx = elementsRef.current.indexOf(element);
      if (idx > -1) {
        elementsRef.current.splice(idx, 1);
      }
    };
  }, [rootElement, setActiveIndex]);
  const handleKeyDown = react.useCallback(event => {
    if (event.key === "Tab") {
      if (originElement) {
        originElement.focus();
      }
      return;
    }
    if (event.key === "Home") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const el = focusableElements[0];
      if (!el) return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "End") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const el = focusableElements[focusableElements.length - 1];
      if (!el) return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const focusableLen = focusableElements.length;
      if (focusableLen === 0) return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements.indexOf(focusedElement);
      focusedIndex = (focusedIndex - 1 + focusableLen) % focusableLen;
      const el = focusableElements[focusedIndex];
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const focusableLen = focusableElements.length;
      if (focusableLen === 0) return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements.indexOf(focusedElement);
      focusedIndex = (focusedIndex + 1) % focusableLen;
      const el = focusableElements[focusedIndex];
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [onKeyDown, originElement, setActiveIndex]);
  const handleItemMouseEnter = react.useCallback(event => {
    const element = event.currentTarget;
    const currentIndex = elementsRef.current.indexOf(element);
    setActiveIndex(currentIndex);
  }, [setActiveIndex]);
  const handleItemMouseLeave = react.useCallback(() => {
    setActiveIndex(-2);
    rootElement == null ? void 0 : rootElement.focus();
  }, [setActiveIndex, rootElement]);
  react.useEffect(() => {
    if (!mounted) return;
    const rafId = window.requestAnimationFrame(() => {
      const _activeIndex = activeIndexRef.current;
      if (_activeIndex === -1) {
        if (shouldFocus === "first") {
          const focusableElements = _getFocusableElements(elementsRef.current);
          const el = focusableElements[0];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex);
            activeIndexRef.current = currentIndex;
          }
        }
        if (shouldFocus === "last") {
          const focusableElements = _getFocusableElements(elementsRef.current);
          const el = focusableElements[focusableElements.length - 1];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex);
            activeIndexRef.current = currentIndex;
          }
        }
        return;
      }
      const element = elementsRef.current[_activeIndex] || null;
      element == null ? void 0 : element.focus();
    });
    return () => {
      window.cancelAnimationFrame(rafId);
    };
  }, [activeIndex, mounted, setActiveIndex, shouldFocus]);
  return {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  };
}
var __freeze$9 = Object.freeze;
var __defProp$9 = Object.defineProperty;
var __template$9 = (cooked, raw) => __freeze$9(__defProp$9(cooked, "raw", {
  value: __freeze$9(raw || cooked.slice())
}));
var _a$9;
const Root$5 = styled__default.default(Box)(_a$9 || (_a$9 = __template$9(["\n  outline: none;\n  overflow: auto;\n"])));
const Menu = react.forwardRef(function Menu2(props, ref) {
  const {
    children,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusFirst,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusLast,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemSelect,
    onKeyDown,
    originElement,
    padding = 1,
    registerElement,
    shouldFocus = props.focusFirst && "first" || props.focusLast && "last" || null,
    space = 1,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const {
    isTopLayer
  } = useLayer();
  const {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  } = useMenuController({
    onKeyDown,
    originElement,
    shouldFocus
  });
  const handleRefChange = react.useCallback(el => {
    setRootElement(el);
    forwardedRef.current = el;
  }, [forwardedRef, setRootElement]);
  react.useEffect(() => {
    if (onItemSelect) onItemSelect(activeIndex);
  }, [activeIndex, onItemSelect]);
  useClickOutside(react.useCallback(event => isTopLayer && onClickOutside && onClickOutside(event), [isTopLayer, onClickOutside]), [rootElement]);
  useGlobalKeyDown(react.useCallback(event => {
    if (!isTopLayer) return;
    if (event.key === "Escape") {
      event.stopPropagation();
      if (onEscape) onEscape();
    }
  }, [isTopLayer, onEscape]));
  react.useEffect(() => {
    if (!rootElement || !registerElement) return;
    return registerElement(rootElement);
  }, [registerElement, rootElement]);
  const value = react.useMemo(() => ({
    version: 0,
    activeElement,
    activeIndex,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter: handleItemMouseEnter,
    onItemMouseLeave: handleItemMouseLeave,
    registerElement,
    // deprecated
    onMouseEnter: handleItemMouseEnter,
    onMouseLeave: handleItemMouseLeave
  }), [activeElement, activeIndex, mount, handleItemMouseEnter, handleItemMouseLeave, onClickOutside, onEscape, onItemClick, registerElement]);
  return /* @__PURE__ */jsxRuntime.jsx(MenuContext.Provider, {
    value,
    children: /* @__PURE__ */jsxRuntime.jsx(Root$5, {
      "data-ui": "Menu",
      ...restProps,
      onKeyDown: handleKeyDown,
      padding,
      ref: handleRefChange,
      role: "menu",
      tabIndex: -1,
      children: /* @__PURE__ */jsxRuntime.jsx(Stack, {
        space,
        children
      })
    })
  });
});
const MenuButton = react.forwardRef(function MenuButton2(props, ref) {
  const {
    __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose = false,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id,
    menu: menuProp,
    onClose,
    onOpen,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: deprecated_portal = true,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props;
  const [open, setOpen] = react.useState(false);
  const [shouldFocus, setShouldFocus] = react.useState(null);
  const [buttonElement, setButtonElement] = react.useState(null);
  const [menuElements, setChildMenuElements] = react.useState([]);
  const openRef = react.useRef(open);
  react.useEffect(() => {
    if (onOpen && open && !openRef.current) {
      onOpen();
    }
  }, [onOpen, open]);
  react.useEffect(() => {
    if (onClose && !open && openRef.current) {
      onClose();
    }
  }, [onClose, open]);
  react.useEffect(() => {
    openRef.current = open;
  }, [open]);
  const handleButtonClick = react.useCallback(() => {
    setOpen(v => !v);
    setShouldFocus(null);
  }, []);
  const handleButtonKeyDown = react.useCallback(event => {
    if (event.key === "ArrowDown" || event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      setOpen(true);
      setShouldFocus("first");
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      setOpen(true);
      setShouldFocus("last");
      return;
    }
  }, []);
  const handleMenuClickOutside = react.useCallback(event => {
    const target = event.target;
    if (!(target instanceof Node)) {
      return;
    }
    if (buttonElement && (target === buttonElement || buttonElement.contains(target))) {
      return;
    }
    for (const el of menuElements) {
      if (target === el || el.contains(target)) {
        return;
      }
    }
    setOpen(false);
  }, [buttonElement, menuElements]);
  const handleMenuEscape = react.useCallback(() => {
    setOpen(false);
    if (disableRestoreFocusOnClose) return;
    if (buttonElement) buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]);
  const handleBlur = react.useCallback(event => {
    const target = event.relatedTarget;
    if (!(target instanceof Node)) {
      return;
    }
    for (const el of menuElements) {
      if (el === target || el.contains(target)) {
        return;
      }
    }
    setOpen(false);
  }, [menuElements]);
  const handleItemClick = react.useCallback(() => {
    setOpen(false);
    if (disableRestoreFocusOnClose) return;
    if (buttonElement) buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]);
  const registerElement = react.useCallback(el => {
    setChildMenuElements(els => els.concat([el]));
    return () => {
      setChildMenuElements(els => {
        return els.filter(_el => _el !== el);
      });
    };
  }, []);
  const menuProps = react.useMemo(() => ({
    "aria-labelledby": id,
    onBlurCapture: handleBlur,
    onClickOutside: handleMenuClickOutside,
    onEscape: handleMenuEscape,
    onItemClick: handleItemClick,
    originElement: buttonElement,
    registerElement,
    shouldFocus
  }), [buttonElement, handleMenuClickOutside, handleMenuEscape, handleItemClick, id, handleBlur, registerElement, shouldFocus]);
  const menu = ReactIs.isElement(menuProp) ? react.cloneElement(menuProp, menuProps) : null;
  const setButtonRef = react.useCallback(el => {
    if (typeof ref === "function") {
      ref(el);
    } else if (ref) {
      ref.current = el;
    }
    setButtonElement(el);
  }, [ref]);
  const button = react.useMemo(() => ReactIs.isElement(buttonProp) ? react.cloneElement(buttonProp, {
    "data-ui": "MenuButton",
    id,
    onClick: handleButtonClick,
    onKeyDown: handleButtonKeyDown,
    "aria-haspopup": true,
    "aria-expanded": open,
    ref: setButtonRef,
    selected: open
  }) : null, [buttonProp, handleButtonClick, handleButtonKeyDown, id, open, setButtonRef]);
  const popoverProps = react.useMemo(() => ({
    boundaryElement: deprecated_boundaryElement,
    overflow: "auto",
    placement: deprecated_placement,
    portal: deprecated_portal,
    preventOverflow: deprecated_preventOverflow,
    radius: deprecated_popoverRadius,
    scheme: deprecated_popoverScheme,
    ...(popover || {})
  }), [deprecated_boundaryElement, deprecated_placement, deprecated_popoverRadius, deprecated_popoverScheme, deprecated_portal, deprecated_preventOverflow, popover]);
  return /* @__PURE__ */jsxRuntime.jsx(Popover, {
    "data-ui": "MenuButton__popover",
    ...popoverProps,
    content: menu,
    open,
    children: button || /* @__PURE__ */jsxRuntime.jsx(jsxRuntime.Fragment, {})
  });
});
var __freeze$8 = Object.freeze;
var __defProp$8 = Object.defineProperty;
var __template$8 = (cooked, raw) => __freeze$8(__defProp$8(cooked, "raw", {
  value: __freeze$8(raw || cooked.slice())
}));
var _a$8;
const MenuDivider = styled__default.default.hr(_a$8 || (_a$8 = __template$8(["\n  height: 1px;\n  border: 0;\n  background: var(--card-hairline-soft-color);\n  margin: 0;\n"])));
var __freeze$7 = Object.freeze;
var __defProp$7 = Object.defineProperty;
var __template$7 = (cooked, raw) => __freeze$7(__defProp$7(cooked, "raw", {
  value: __freeze$7(raw || cooked.slice())
}));
var _a$7, _b$4;
function selectableBaseStyle() {
  return styled.css(_a$7 || (_a$7 = __template$7(["\n    background-color: inherit;\n    color: inherit;\n\n    &[data-as='button'] {\n      -webkit-font-smoothing: inherit;\n      appearance: none;\n      outline: none;\n      font: inherit;\n      text-align: inherit;\n      border: 0;\n      width: -webkit-fill-available;\n      width: stretch;\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      text-decoration: none;\n    }\n  "])));
}
function selectableColorStyle(props) {
  var _a2, _b2;
  const {
    $tone,
    theme
  } = props;
  const {
    base,
    muted,
    selectable
  } = theme.sanity.color;
  const tone = selectable ? selectable[$tone] || selectable.default : muted[$tone] || muted.default;
  return styled.css(_b$4 || (_b$4 = __template$7(["\n    ", "\n\n    background-color: var(--card-bg-color);\n    color: var(--card-fg-color);\n    outline: none;\n\n    /* &:is(button) */\n    &[data-as='button'] {\n      &:disabled {\n        ", "\n      }\n\n      &:not(:disabled) {\n        &[aria-pressed='true'] {\n          ", "\n        }\n\n        &[data-selected],\n        &[aria-selected='true'] > & {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n      }\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      &[data-disabled] {\n        ", "\n      }\n\n      &:not([data-disabled]) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-selected]) {\n            &[data-hovered],\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n      }\n    }\n\n    ", "\n  "])), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.disabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.disabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.pressed), (_b2 = (_a2 = theme.sanity.styles) == null ? void 0 : _a2.card) == null ? void 0 : _b2.root);
}
const Selectable = styled__default.default(Box)(responsiveRadiusStyle, selectableBaseStyle, selectableColorStyle);
function useMenu() {
  const value = react.useContext(MenuContext);
  if (!value) {
    throw new Error("useMenu(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("useMenu(): the context value is not compatible");
  }
  return value;
}
function MenuGroup(props) {
  const {
    as = "button",
    children,
    fontSize,
    icon,
    onClick,
    padding = 3,
    popover,
    radius = 2,
    space = 3,
    text,
    tone = "default",
    ...restProps
  } = props;
  const menu = useMenu();
  const {
    activeElement,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    registerElement
  } = menu;
  const [rootElement, setRootElement] = react.useState(null);
  const [open, setOpen] = react.useState(false);
  const shouldFocusRef = react.useRef(null);
  const active = Boolean(activeElement) && activeElement === rootElement;
  const [withinMenu, setWithinMenu] = react.useState(false);
  const handleMouseEnter = react.useCallback(event => {
    setWithinMenu(false);
    onItemMouseEnter(event);
    setOpen(true);
  }, [onItemMouseEnter]);
  const handleMenuKeyDown = react.useCallback(event => {
    if (event.key === "ArrowLeft") {
      event.stopPropagation();
      setOpen(false);
      requestAnimationFrame(() => {
        rootElement == null ? void 0 : rootElement.focus();
      });
    }
  }, [rootElement]);
  const handleClick = react.useCallback(event => {
    if (onClick) onClick(event);
    shouldFocusRef.current = "first";
    setOpen(true);
    requestAnimationFrame(() => {
      shouldFocusRef.current = null;
    });
  }, [onClick]);
  const handleChildItemClick = react.useCallback(() => {
    setOpen(false);
    if (onItemClick) onItemClick();
  }, [onItemClick]);
  const handleMenuMouseEnter = react.useCallback(() => setWithinMenu(true), []);
  react.useEffect(() => mount(rootElement), [mount, rootElement]);
  react.useEffect(() => {
    if (!active) setOpen(false);
  }, [active]);
  react.useEffect(() => {
    if (!open) setWithinMenu(false);
  }, [open]);
  const childMenu = /* @__PURE__ */jsxRuntime.jsx(Menu, {
    onClickOutside,
    onEscape,
    onItemClick: handleChildItemClick,
    onKeyDown: handleMenuKeyDown,
    onMouseEnter: handleMenuMouseEnter,
    registerElement,
    shouldFocus: shouldFocusRef.current,
    children
  });
  const handleKeyDown = react.useCallback(event => {
    const target = event.currentTarget;
    if (document.activeElement !== target) {
      return;
    }
    if (event.key === "ArrowRight") {
      shouldFocusRef.current = "first";
      setOpen(true);
      setWithinMenu(true);
      requestAnimationFrame(() => {
        shouldFocusRef.current = null;
      });
      return;
    }
  }, []);
  return /* @__PURE__ */jsxRuntime.jsx(Popover, {
    ...popover,
    content: childMenu,
    "data-ui": "MenuGroup__popover",
    open,
    children: /* @__PURE__ */jsxRuntime.jsx(Selectable, {
      "data-as": as,
      "data-ui": "MenuGroup",
      forwardedAs: as,
      ...restProps,
      "aria-pressed": as === "button" ? withinMenu : void 0,
      "data-pressed": as !== "button" ? withinMenu : void 0,
      "data-selected": !withinMenu && active ? "" : void 0,
      $radius: useArrayProp(radius),
      $tone: tone,
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      onMouseEnter: handleMouseEnter,
      ref: setRootElement,
      tabIndex: -1,
      type: as === "button" ? "button" : void 0,
      children: /* @__PURE__ */jsxRuntime.jsx(Box, {
        padding,
        children: /* @__PURE__ */jsxRuntime.jsxs(Flex, {
          children: [icon && /* @__PURE__ */jsxRuntime.jsxs(Text, {
            size: fontSize,
            children: [react.isValidElement(icon) && icon, ReactIs.isValidElementType(icon) && react.createElement(icon)]
          }), /* @__PURE__ */jsxRuntime.jsx(Box, {
            flex: 1,
            marginLeft: icon ? space : void 0,
            children: /* @__PURE__ */jsxRuntime.jsx(Text, {
              size: fontSize,
              textOverflow: "ellipsis",
              children: text
            })
          }), /* @__PURE__ */jsxRuntime.jsx(Box, {
            marginLeft: space,
            children: /* @__PURE__ */jsxRuntime.jsx(Text, {
              size: fontSize,
              children: /* @__PURE__ */jsxRuntime.jsx(icons.ChevronRightIcon, {})
            })
          })]
        })
      })
    })
  });
}
const MenuItem = react.forwardRef(function MenuItem2(props, forwardedRef) {
  const {
    as = "button",
    children,
    disabled,
    fontSize = 2,
    hotkeys,
    icon,
    iconRight,
    onClick,
    padding = 3,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    pressed,
    radius = 2,
    selected: selectedProp,
    space = 3,
    text,
    tone = "default",
    ...restProps
  } = props;
  const menu = useMenu();
  const {
    activeElement,
    mount,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    onItemMouseLeave = menu.onMouseLeave
  } = menu;
  const [rootElement, setRootElement] = react.useState(null);
  const active = Boolean(activeElement) && activeElement === rootElement;
  react.useEffect(() => mount(rootElement, selectedProp), [mount, rootElement, selectedProp]);
  const ref = useForwardedRef(forwardedRef);
  const handleClick = react.useCallback(event => {
    if (disabled) return;
    if (onClick) onClick(event);
    if (onItemClick) onItemClick();
  }, [disabled, onClick, onItemClick]);
  const paddingProps = react.useMemo(() => ({
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft
  }), [padding, paddingX, paddingY, paddingTop, paddingRight, paddingBottom, paddingLeft]);
  const setRef = react.useCallback(el => {
    ref.current = el;
    setRootElement(el);
  }, [ref]);
  return /* @__PURE__ */jsxRuntime.jsxs(Selectable, {
    "data-ui": "MenuItem",
    ...restProps,
    "aria-pressed": as === "button" && pressed,
    "data-pressed": as !== "button" && pressed ? "" : void 0,
    "data-selected": active ? "" : void 0,
    "data-disabled": disabled ? "" : void 0,
    forwardedAs: as,
    $radius: useArrayProp(radius),
    $padding: useArrayProp(0),
    $tone: tone,
    disabled,
    onClick: handleClick,
    onMouseEnter: onItemMouseEnter,
    onMouseLeave: onItemMouseLeave,
    ref: setRef,
    role: "menuitem",
    tabIndex: -1,
    type: as === "button" ? "button" : void 0,
    children: [(icon || text || iconRight) && /* @__PURE__ */jsxRuntime.jsx(Box, {
      as: "span",
      ...paddingProps,
      children: /* @__PURE__ */jsxRuntime.jsxs(Flex, {
        as: "span",
        children: [icon && /* @__PURE__ */jsxRuntime.jsxs(Text, {
          size: fontSize,
          children: [react.isValidElement(icon) && icon, ReactIs.isValidElementType(icon) && react.createElement(icon)]
        }), text && /* @__PURE__ */jsxRuntime.jsx(Box, {
          flex: 1,
          marginLeft: icon ? space : void 0,
          marginRight: iconRight ? space : void 0,
          children: /* @__PURE__ */jsxRuntime.jsx(Text, {
            size: fontSize,
            textOverflow: "ellipsis",
            children: text
          })
        }), hotkeys && /* @__PURE__ */jsxRuntime.jsx(Box, {
          marginLeft: space,
          style: {
            marginTop: -4,
            marginBottom: -4
          },
          children: /* @__PURE__ */jsxRuntime.jsx(Hotkeys, {
            fontSize,
            keys: hotkeys
          })
        }), iconRight && /* @__PURE__ */jsxRuntime.jsxs(Text, {
          size: fontSize,
          children: [react.isValidElement(iconRight) && iconRight, ReactIs.isValidElementType(iconRight) && react.createElement(iconRight)]
        })]
      })
    }), children && /* @__PURE__ */jsxRuntime.jsx(Box, {
      as: "span",
      ...paddingProps,
      children
    })]
  });
});
var __freeze$6 = Object.freeze;
var __defProp$6 = Object.defineProperty;
var __template$6 = (cooked, raw) => __freeze$6(__defProp$6(cooked, "raw", {
  value: __freeze$6(raw || cooked.slice())
}));
var _a$6, _b$3, _c$1, _d;
const keyframe = styled.keyframes(_a$6 || (_a$6 = __template$6(["\n  0% {\n    background-position: 100%;\n  }\n  100% {\n    background-position: -100%;\n  }\n"])));
const animation = styled.css(_b$3 || (_b$3 = __template$6(["\n  background-image: linear-gradient(\n    to right,\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-to),\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-from)\n  );\n  background-position: 100%;\n  background-size: 200% 100%;\n  background-attachment: fixed;\n  animation-name: ", ";\n  animation-timing-function: ease-in-out;\n  animation-iteration-count: infinite;\n  animation-duration: 2000ms;\n"])), keyframe);
const skeletonStyle = styled.css(_d || (_d = __template$6(["\n  opacity: ", ";\n  transition: opacity 200ms ease-in;\n\n  @media screen and (prefers-reduced-motion: no-preference) {\n    ", "\n  }\n\n  @media screen and (prefers-reduced-motion: reduce) {\n    background-color: var(--card-skeleton-color-from);\n  }\n"])), _ref25 => {
  let {
    $visible
  } = _ref25;
  return $visible ? 1 : 0;
}, _ref26 => {
  let {
    $animated
  } = _ref26;
  return $animated ? animation : styled.css(_c$1 || (_c$1 = __template$6(["\n            background-color: var(--card-skeleton-color-from);\n          "])));
});
const Root$4 = styled__default.default(Box)(responsiveRadiusStyle, skeletonStyle);
const Skeleton = react.forwardRef(function Skeleton2(props, ref) {
  const {
    animated = false,
    delay,
    radius,
    ...restProps
  } = props;
  const [visible, setVisible] = react.useState(delay ? false : true);
  react.useEffect(() => {
    if (!delay) {
      return setVisible(true);
    }
    const timeout = setTimeout(() => {
      setVisible(true);
    }, delay);
    return () => {
      clearTimeout(timeout);
    };
  }, [delay]);
  return /* @__PURE__ */jsxRuntime.jsx(Root$4, {
    ...restProps,
    $animated: animated,
    $radius: useArrayProp(radius),
    $visible: visible,
    ref
  });
});
const Root$3 = styled__default.default(Skeleton)(_ref27 => {
  let {
    $size,
    $style,
    theme
  } = _ref27;
  const {
    media
  } = theme.sanity;
  const font = theme.sanity.fonts[$style];
  const styles = _responsive(media, $size, sizeIndex => {
    const fontSize = font.sizes[sizeIndex];
    const capHeight = fontSize.lineHeight - fontSize.ascenderHeight - fontSize.descenderHeight;
    return {
      height: capHeight
    };
  });
  return styles;
});
const TextSkeleton = react.forwardRef(function TextSkeleton2(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsxRuntime.jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "text"
  });
});
const LabelSkeleton = react.forwardRef(function TextSkeleton3(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsxRuntime.jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "label"
  });
});
const HeadingSkeleton = react.forwardRef(function TextSkeleton4(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsxRuntime.jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "heading"
  });
});
const CodeSkeleton = react.forwardRef(function TextSkeleton5(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsxRuntime.jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "code"
  });
});
var __freeze$5 = Object.freeze;
var __defProp$5 = Object.defineProperty;
var __template$5 = (cooked, raw) => __freeze$5(__defProp$5(cooked, "raw", {
  value: __freeze$5(raw || cooked.slice())
}));
var _a$5;
const CustomButton = styled__default.default(Button)(_a$5 || (_a$5 = __template$5(["\n  max-width: 100%;\n"])));
const Tab = react.forwardRef(function Tab2(props, forwardedRef) {
  const {
    icon,
    id,
    focused,
    fontSize,
    label,
    onClick,
    onFocus,
    padding = 2,
    selected,
    ...restProps
  } = props;
  const elementRef = react.useRef(null);
  const focusedRef = react.useRef(false);
  const handleBlur = react.useCallback(() => {
    focusedRef.current = false;
  }, []);
  const handleFocus = react.useCallback(event => {
    focusedRef.current = true;
    if (onFocus) onFocus(event);
  }, [onFocus]);
  const ref = useForwardedRef(forwardedRef);
  react.useEffect(() => {
    if (focused && !focusedRef.current) {
      if (elementRef.current) elementRef.current.focus();
      focusedRef.current = true;
    }
  }, [focused]);
  const setRef = el => {
    elementRef.current = el;
    ref.current = el;
  };
  return /* @__PURE__ */jsxRuntime.jsx(CustomButton, {
    "data-ui": "Tab",
    ...restProps,
    "aria-selected": selected ? "true" : "false",
    fontSize,
    icon,
    id,
    mode: "bleed",
    onClick,
    onBlur: handleBlur,
    onFocus: handleFocus,
    padding,
    ref: setRef,
    role: "tab",
    selected,
    tabIndex: selected ? 0 : -1,
    text: label,
    type: "button"
  });
});
var __freeze$4 = Object.freeze;
var __defProp$4 = Object.defineProperty;
var __template$4 = (cooked, raw) => __freeze$4(__defProp$4(cooked, "raw", {
  value: __freeze$4(raw || cooked.slice())
}));
var _a$4;
function _isReactElement(node) {
  return Boolean(node);
}
const CustomInline = styled__default.default(Inline)(_a$4 || (_a$4 = __template$4(["\n  & > div {\n    display: inline-block;\n    vertical-align: middle;\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n"])));
const TabList = react.forwardRef(function TabList2(props, ref) {
  const {
    children: childrenProp,
    ...restProps
  } = props;
  const [focusedIndex, setFocusedIndex] = react.useState(-1);
  const children = react.useMemo(() => childrenProp.filter(_isReactElement), [childrenProp]);
  const tabs = children.map((child, childIndex) => react.cloneElement(child, {
    focused: focusedIndex === childIndex,
    key: childIndex,
    onFocus: () => handleTabFocus(childIndex)
  }));
  const numTabs = tabs.length;
  const handleTabFocus = react.useCallback(tabIdx => {
    setFocusedIndex(tabIdx);
  }, []);
  const handleKeyDown = react.useCallback(event => {
    if (event.key === "ArrowLeft") {
      setFocusedIndex(prevIndex => (prevIndex + numTabs - 1) % numTabs);
    }
    if (event.key === "ArrowRight") {
      setFocusedIndex(prevIndex => (prevIndex + 1) % numTabs);
    }
  }, [numTabs]);
  return /* @__PURE__ */jsxRuntime.jsx(CustomInline, {
    "data-ui": "TabList",
    ...restProps,
    onKeyDown: handleKeyDown,
    ref,
    role: "tablist",
    children: tabs
  });
});
const TabPanel = react.forwardRef(function TabPanel2(props, ref) {
  const {
    flex,
    ...restProps
  } = props;
  return /* @__PURE__ */jsxRuntime.jsx(Box, {
    "data-ui": "TabPanel",
    ...restProps,
    flex,
    ref,
    role: "tabpanel",
    tabIndex: props.tabIndex === void 0 ? 0 : props.tabIndex,
    children: props.children
  });
});
var __freeze$3 = Object.freeze;
var __defProp$3 = Object.defineProperty;
var __template$3 = (cooked, raw) => __freeze$3(__defProp$3(cooked, "raw", {
  value: __freeze$3(raw || cooked.slice())
}));
var _a$3, _b$2;
const STATUS_CARD_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "primary"
};
const ROLES = {
  error: "alert",
  warning: "alert",
  success: "alert",
  info: "alert"
};
const Root$2 = styled__default.default(Card)(_a$3 || (_a$3 = __template$3(["\n  pointer-events: all;\n"])));
const TextBox = styled__default.default(Flex)(_b$2 || (_b$2 = __template$3(["\n  overflow-x: auto;\n"])));
function Toast(props) {
  const {
    closable,
    description,
    onClose,
    title,
    status,
    ...restProps
  } = props;
  const cardTone = status ? STATUS_CARD_TONE[status] : "default";
  const role = status ? ROLES[status] : "status";
  return /* @__PURE__ */jsxRuntime.jsx(Root$2, {
    "data-ui": "Toast",
    role,
    ...restProps,
    marginTop: 3,
    radius: 2,
    shadow: 2,
    tone: cardTone,
    children: /* @__PURE__ */jsxRuntime.jsxs(Flex, {
      align: "flex-start",
      children: [/* @__PURE__ */jsxRuntime.jsx(TextBox, {
        flex: 1,
        padding: 3,
        children: /* @__PURE__ */jsxRuntime.jsxs(Stack, {
          space: 3,
          children: [title && /* @__PURE__ */jsxRuntime.jsx(Text, {
            weight: "semibold",
            children: title
          }), description && /* @__PURE__ */jsxRuntime.jsx(Text, {
            muted: true,
            size: 1,
            children: description
          })]
        })
      }), closable && /* @__PURE__ */jsxRuntime.jsx(Box, {
        padding: 1,
        children: /* @__PURE__ */jsxRuntime.jsx(Button, {
          as: "button",
          icon: icons.CloseIcon,
          mode: "bleed",
          padding: 2,
          onClick: onClose,
          style: {
            verticalAlign: "top"
          }
        })
      })]
    })
  });
}
function useMounted() {
  const [mounted, mount] = react.useReducer(() => true, false);
  react.useEffect(mount, [mount]);
  return mounted;
}
const key$1 = Symbol.for("@sanity/ui/context/toast");
globalScope[key$1] = globalScope[key$1] || react.createContext(null);
const ToastContext = globalScope[key$1];
var __freeze$2 = Object.freeze;
var __defProp$2 = Object.defineProperty;
var __template$2 = (cooked, raw) => __freeze$2(__defProp$2(cooked, "raw", {
  value: __freeze$2(raw || cooked.slice())
}));
var _a$2, _b$1;
const Root$1 = styled__default.default(Layer)(_a$2 || (_a$2 = __template$2(["\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n"])));
const ToastContainer = styled__default.default.div(_b$1 || (_b$1 = __template$2(["\n  box-sizing: border-box;\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  max-width: 420px;\n  width: 100%;\n"])));
let toastId = 0;
function ToastProvider(props) {
  const {
    children,
    padding = 4,
    paddingX,
    paddingY,
    zOffset
  } = props;
  const [state, _setState] = react.useState([]);
  const toastsRef = react.useRef({});
  const push = react.useCallback(params => {
    const setState = state2 => react.startTransition(() => _setState(state2));
    const id = params.id || String(toastId++);
    const duration = params.duration || 5e3;
    const dismiss = () => {
      var _a2;
      const timeoutId = (_a2 = toastsRef.current[id]) == null ? void 0 : _a2.timeoutId;
      setState(prevState => {
        const idx = prevState.findIndex(t => t.id === id);
        if (idx > -1) {
          const toasts = prevState.slice(0);
          toasts.splice(idx, 1);
          return toasts;
        }
        return prevState;
      });
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
        delete toastsRef.current[id];
      }
    };
    setState(prevState => {
      return prevState.filter(t => t.id !== id).concat([{
        dismiss,
        id,
        params: {
          ...params,
          duration
        }
      }]);
    });
    if (toastsRef.current[id]) {
      clearTimeout(toastsRef.current[id].timeoutId);
      delete toastsRef.current[id];
    }
    toastsRef.current[id] = {
      timeoutId: setTimeout(dismiss, duration)
    };
    return id;
  }, []);
  react.useEffect(() => () => {
    for (const {
      timeoutId
    } of Object.values(toastsRef.current)) {
      clearTimeout(timeoutId);
    }
    toastsRef.current = {};
  }, []);
  const value = react.useMemo(() => ({
    version: 0,
    push
  }), [push]);
  const mounted = useMounted();
  return /* @__PURE__ */jsxRuntime.jsxs(ToastContext.Provider, {
    value,
    children: [children, mounted && /* @__PURE__ */jsxRuntime.jsx(Root$1, {
      "data-ui": "ToastProvider",
      zOffset,
      children: /* @__PURE__ */jsxRuntime.jsx(ToastContainer, {
        children: /* @__PURE__ */jsxRuntime.jsx(Box, {
          padding,
          paddingX,
          paddingY,
          children: /* @__PURE__ */jsxRuntime.jsx(framerMotion.AnimatePresence, {
            initial: false,
            children: state.map(_ref28 => {
              let {
                dismiss,
                id,
                params
              } = _ref28;
              return /* @__PURE__ */jsxRuntime.jsx(framerMotion.motion.div, {
                animate: {
                  opacity: 1,
                  y: 0,
                  scale: 1
                },
                exit: {
                  opacity: 0,
                  scale: 0.5,
                  transition: {
                    duration: 0.2
                  }
                },
                initial: {
                  opacity: 0,
                  y: 32,
                  scale: 0.25
                },
                layout: "position",
                transition: {
                  type: "spring",
                  damping: 30,
                  stiffness: 400
                },
                children: /* @__PURE__ */jsxRuntime.jsx(Toast, {
                  closable: params.closable,
                  description: params.description,
                  onClose: dismiss,
                  status: params.status,
                  title: params.title
                })
              }, id);
            })
          })
        })
      })
    })]
  });
}
function useToast() {
  const value = react.useContext(ToastContext);
  if (!value) {
    throw new Error("useToast(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("useToast(): the context value is not compatible");
  }
  return value;
}
function _findPrevItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement);
  const els = itemElements.slice(0, idx);
  const len = els.length;
  for (let i = len - 1; i >= 0; i -= 1) {
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey) {
      continue;
    }
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = true;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a = state[k]) == null ? void 0 : _a.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded) {
      return els[i];
    }
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement);
  const els = itemElements.slice(idx);
  const len = itemElements.length;
  for (let i = 1; i < len; i += 1) {
    if (!els[i]) {
      continue;
    }
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey) {
      continue;
    }
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = true;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a = state[k]) == null ? void 0 : _a.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded) {
      return els[i];
    }
  }
  return null;
}
function _focusItemElement(el) {
  if (el.getAttribute("role") === "treeitem") {
    el.focus();
  }
  if (el.getAttribute("role") === "none") {
    const firstChild = el.firstChild;
    if (firstChild && firstChild instanceof HTMLElement) {
      firstChild.focus();
    }
  }
}
const key = Symbol.for("@sanity/ui/context/tree");
globalScope[key] = globalScope[key] || react.createContext(null);
const TreeContext = globalScope[key];
const Tree = react.memo(react.forwardRef(function Tree2(props, ref) {
  const {
    children,
    space = 1,
    onFocus,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const [focusedElement, setFocusedElement] = react.useState(null);
  const focusedElementRef = react.useRef(focusedElement);
  const path = react.useMemo(() => [], []);
  const [itemElements, setItemElements] = react.useState([]);
  const [state, setState] = react.useState({});
  const stateRef = react.useRef(state);
  react.useEffect(() => {
    focusedElementRef.current = focusedElement;
  }, [focusedElement]);
  react.useEffect(() => {
    stateRef.current = state;
  }, [state]);
  const registerItem = react.useCallback((element, path2, expanded, selected) => {
    setState(s => ({
      ...s,
      [path2]: {
        element,
        expanded
      }
    }));
    if (selected) {
      setFocusedElement(element);
    }
    return () => {
      setState(s => {
        const newState = {
          ...s
        };
        delete newState[path2];
        return newState;
      });
    };
  }, []);
  const setExpanded = react.useCallback((path2, expanded) => {
    setState(s => {
      const itemState = s[path2];
      if (!itemState) return s;
      return {
        ...s,
        [path2]: {
          ...itemState,
          expanded
        }
      };
    });
  }, []);
  const contextValue = react.useMemo(() => ({
    version: 0,
    focusedElement: focusedElement || itemElements[0] || null,
    level: 0,
    path,
    registerItem,
    setExpanded,
    setFocusedElement,
    space,
    state
  }), [focusedElement, itemElements, path, registerItem, setExpanded, space, state]);
  const handleKeyDown = react.useCallback(event => {
    var _a;
    if (!focusedElementRef.current) return;
    if (event.key === "ArrowDown") {
      event.preventDefault();
      const nextEl = _findNextItemElement(stateRef.current, itemElements, focusedElementRef.current);
      if (nextEl) {
        _focusItemElement(nextEl);
        setFocusedElement(nextEl);
      }
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      const prevEl = _findPrevItemElement(stateRef.current, itemElements, focusedElementRef.current);
      if (prevEl) {
        _focusItemElement(prevEl);
        setFocusedElement(prevEl);
      }
      return;
    }
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
      if (!itemKey) return;
      const itemState = stateRef.current[itemKey];
      if (!itemState) return;
      if (itemState.expanded) {
        setState(s => {
          const itemState2 = s[itemKey];
          if (!itemState2) return s;
          return {
            ...s,
            [itemKey]: {
              ...itemState2,
              expanded: false
            }
          };
        });
      } else {
        const itemPath = itemKey.split("/");
        itemPath.pop();
        const parentKey = itemPath.join("/");
        const parentState = parentKey && stateRef.current[parentKey];
        if (parentState) {
          parentState.element.focus();
          setFocusedElement(parentState.element);
        }
      }
      return;
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
      if (!focusedKey) return;
      if (!((_a = stateRef.current[focusedKey]) == null ? void 0 : _a.expanded)) {
        setState(s => {
          const itemState = s[focusedKey];
          if (!itemState) return s;
          return {
            ...s,
            [focusedKey]: {
              ...itemState,
              expanded: true
            }
          };
        });
      }
      return;
    }
  }, [itemElements]);
  const handleFocus = react.useCallback(event => {
    setFocusedElement(event.target);
    onFocus == null ? void 0 : onFocus(event);
  }, [onFocus]);
  react.useEffect(() => {
    if (!forwardedRef.current) return;
    const _itemElements = Array.from(forwardedRef.current.querySelectorAll('[data-ui="TreeItem"]'));
    setItemElements(_itemElements);
  }, [children, forwardedRef]);
  return /* @__PURE__ */jsxRuntime.jsx(TreeContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */jsxRuntime.jsx(Stack, {
      as: "ul",
      "data-ui": "Tree",
      ...restProps,
      onFocus: handleFocus,
      onKeyDown: handleKeyDown,
      ref: forwardedRef,
      role: "tree",
      space,
      children
    })
  });
}));
Tree.displayName = "Tree";
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1, _b, _c;
function treeItemRootStyle() {
  return styled.css(_a$1 || (_a$1 = __template$1(["\n    &[role='none'] > [role='treeitem'] {\n      outline: none;\n      cursor: default;\n      border-radius: 3px;\n\n      &:focus {\n        position: relative;\n      }\n    }\n\n    &[role='treeitem'] {\n      outline: none;\n\n      & > div {\n        cursor: default;\n        border-radius: 3px;\n      }\n\n      &:focus > div {\n        position: relative;\n      }\n    }\n  "])));
}
function treeItemRootColorStyle(props) {
  const {
    theme
  } = props;
  const $tone = "default";
  const {
    base,
    muted,
    selectable
  } = theme.sanity.color;
  const tone = selectable ? selectable[$tone] || selectable.default : muted[$tone] || muted.default;
  return styled.css(_b || (_b = __template$1(['\n    /* <div role="none"><a data-ui="TreeItem__box" role="treeitem" tabIndex="0"></div> */\n    &[role=\'none\'] {\n      & > [role=\'treeitem\'] {\n        ', "\n\n        background-color: var(--card-bg-color);\n        color: var(--treeitem-fg-color);\n      }\n\n      &[data-selected] > [role='treeitem'] {\n        ", "\n      }\n\n      @media (hover: hover) {\n        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {\n          ", "\n        }\n\n        & > [role='treeitem']:focus {\n          ", '\n        }\n      }\n    }\n\n    /* <div role="treeitem" tabIndex="0"><div data-ui="TreeItem__box"></div> */\n    &[role=\'treeitem\'] {\n      & > [data-ui=\'TreeItem__box\'] {\n        ', "\n\n        background-color: var(--card-bg-color);\n        color: var(--card-fg-color);\n      }\n\n      &[data-selected] > [data-ui='TreeItem__box'] {\n        ", "\n      }\n\n      @media (hover: hover) {\n        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {\n          ", "\n        }\n\n        &:focus > [data-ui='TreeItem__box'] {\n          ", "\n        }\n      }\n    }\n  "])), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.selected));
}
function treeItemBoxStyle(props) {
  const {
    $level,
    theme
  } = props;
  const {
    space
  } = theme.sanity;
  return styled.css(_c || (_c = __template$1(["\n    padding-left: ", ";\n\n    &[data-as='a'] {\n      text-decoration: none;\n    }\n  "])), rem(space[2] * $level));
}
function useTree() {
  const tree = react.useContext(TreeContext);
  if (!tree) {
    throw new Error("Tree: missing context value");
  }
  return tree;
}
const TreeGroup = react.memo(function TreeGroup2(props) {
  const {
    children,
    expanded = false,
    ...restProps
  } = props;
  const tree = useTree();
  return /* @__PURE__ */jsxRuntime.jsx(Stack, {
    as: "ul",
    "data-ui": "TreeGroup",
    ...restProps,
    hidden: !expanded,
    marginTop: tree.space,
    role: "group",
    space: tree.space,
    children
  });
});
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a;
const Root = react.memo(styled__default.default.li(treeItemRootStyle, treeItemRootColorStyle));
const TreeItemBox = styled__default.default(Box).attrs({
  forwardedAs: "a"
})(treeItemBoxStyle);
const ToggleArrowText = styled__default.default(Text)(_a || (_a = __template(["\n  & > svg {\n    transition: transform 100ms;\n  }\n"])));
const TreeItem = react.memo(function TreeItem2(props) {
  const {
    children,
    expanded: expandedProp = false,
    fontSize,
    href,
    icon,
    id: idProp,
    linkAs,
    muted,
    onClick,
    padding = 3,
    selected = false,
    space = 2,
    text,
    weight,
    ...restProps
  } = props;
  const rootRef = react.useRef(null);
  const treeitemRef = react.useRef(null);
  const tree = useTree();
  const {
    path,
    registerItem,
    setExpanded,
    setFocusedElement
  } = tree;
  const _id = react.useId();
  const id = idProp || _id;
  const itemPath = react.useMemo(() => path.concat([id || ""]), [id, path]);
  const itemKey = itemPath.join("/");
  const itemState = tree.state[itemKey];
  const focused = tree.focusedElement === rootRef.current;
  const expanded = (itemState == null ? void 0 : itemState.expanded) === void 0 ? expandedProp : (itemState == null ? void 0 : itemState.expanded) || false;
  const tabIndex = tree.focusedElement && tree.focusedElement === rootRef.current ? 0 : -1;
  const contextValue = react.useMemo(() => ({
    ...tree,
    level: tree.level + 1,
    path: itemPath
  }), [itemPath, tree]);
  const handleClick = react.useCallback(event => {
    if (onClick) onClick(event);
    const target = event.target;
    if (target instanceof HTMLElement && (target.getAttribute("data-ui") === "TreeItem" || target.closest('[data-ui="TreeItem__box"]'))) {
      event.stopPropagation();
      setExpanded(itemKey, !expanded);
      setFocusedElement(rootRef.current);
    }
  }, [expanded, itemKey, onClick, setExpanded, setFocusedElement]);
  const handleKeyDown = react.useCallback(event => {
    if (focused && event.key === "Enter") {
      const el = treeitemRef.current || rootRef.current;
      el == null ? void 0 : el.click();
    }
  }, [focused]);
  react.useEffect(() => {
    if (!rootRef.current) return;
    return registerItem(rootRef.current, itemPath.join("/"), expanded, selected);
  }, [expanded, itemPath, registerItem, selected]);
  const content = /* @__PURE__ */jsxRuntime.jsxs(Flex, {
    padding,
    children: [/* @__PURE__ */jsxRuntime.jsxs(Box, {
      marginRight: space,
      style: {
        visibility: icon || children ? "visible" : "hidden",
        pointerEvents: "none"
      },
      children: [icon && /* @__PURE__ */jsxRuntime.jsx(Text, {
        muted,
        size: fontSize,
        weight,
        children: react.createElement(icon)
      }), !icon && /* @__PURE__ */jsxRuntime.jsx(ToggleArrowText, {
        muted,
        size: fontSize,
        weight,
        children: /* @__PURE__ */jsxRuntime.jsx(icons.ToggleArrowRightIcon, {
          style: {
            transform: expanded ? "rotate(90deg)" : void 0
          }
        })
      })]
    }), /* @__PURE__ */jsxRuntime.jsx(Box, {
      flex: 1,
      children: /* @__PURE__ */jsxRuntime.jsx(Text, {
        muted,
        size: fontSize,
        textOverflow: "ellipsis",
        weight,
        children: text
      })
    })]
  });
  if (href) {
    return /* @__PURE__ */jsxRuntime.jsxs(Root, {
      "data-selected": selected ? "" : void 0,
      "data-tree-id": id,
      "data-tree-key": itemKey,
      "data-ui": "TreeItem",
      ...restProps,
      onClick: handleClick,
      ref: rootRef,
      role: "none",
      children: [/* @__PURE__ */jsxRuntime.jsx(TreeItemBox, {
        $level: tree.level,
        "aria-expanded": expanded,
        as: linkAs,
        "data-ui": "TreeItem__box",
        href,
        ref: treeitemRef,
        role: "treeitem",
        tabIndex,
        children: content
      }), /* @__PURE__ */jsxRuntime.jsx(TreeContext.Provider, {
        value: contextValue,
        children: children && /* @__PURE__ */jsxRuntime.jsx(TreeGroup, {
          hidden: !expanded,
          children
        })
      })]
    });
  }
  return /* @__PURE__ */jsxRuntime.jsxs(Root, {
    "data-selected": selected ? "" : void 0,
    "data-ui": "TreeItem",
    "data-tree-id": id,
    "data-tree-key": itemKey,
    ...restProps,
    "aria-expanded": expanded,
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    ref: rootRef,
    role: "treeitem",
    tabIndex,
    children: [/* @__PURE__ */jsxRuntime.jsx(TreeItemBox, {
      $level: tree.level,
      as: "div",
      "data-ui": "TreeItem__box",
      children: content
    }), /* @__PURE__ */jsxRuntime.jsx(TreeContext.Provider, {
      value: contextValue,
      children: children && /* @__PURE__ */jsxRuntime.jsx(TreeGroup, {
        expanded,
        children
      })
    })]
  });
});
exports.Autocomplete = Autocomplete;
exports.Avatar = Avatar;
exports.AvatarCounter = AvatarCounter;
exports.AvatarStack = AvatarStack;
exports.Badge = Badge;
exports.BoundaryElementProvider = BoundaryElementProvider;
exports.Box = Box;
exports.Breadcrumbs = Breadcrumbs;
exports.Button = Button;
exports.Card = Card;
exports.Checkbox = Checkbox;
exports.Code = Code;
exports.CodeSkeleton = CodeSkeleton;
exports.Container = Container;
exports.Dialog = Dialog;
exports.DialogContext = DialogContext;
exports.DialogProvider = DialogProvider;
exports.ElementQuery = ElementQuery;
exports.ErrorBoundary = ErrorBoundary;
exports.Flex = Flex;
exports.Grid = Grid;
exports.Heading = Heading;
exports.HeadingSkeleton = HeadingSkeleton;
exports.Hotkeys = Hotkeys;
exports.Inline = Inline;
exports.KBD = KBD;
exports.Label = Label;
exports.LabelSkeleton = LabelSkeleton;
exports.Layer = Layer;
exports.LayerProvider = LayerProvider;
exports.Menu = Menu;
exports.MenuButton = MenuButton;
exports.MenuDivider = MenuDivider;
exports.MenuGroup = MenuGroup;
exports.MenuItem = MenuItem;
exports.Popover = Popover;
exports.Portal = Portal;
exports.PortalProvider = PortalProvider;
exports.Radio = Radio;
exports.Select = Select;
exports.Skeleton = Skeleton;
exports.Spinner = Spinner;
exports.SrOnly = SrOnly;
exports.Stack = Stack;
exports.Switch = Switch;
exports.Tab = Tab;
exports.TabList = TabList;
exports.TabPanel = TabPanel;
exports.Text = Text;
exports.TextArea = TextArea;
exports.TextInput = TextInput;
exports.TextSkeleton = TextSkeleton;
exports.ThemeColorProvider = ThemeColorProvider;
exports.ThemeProvider = ThemeProvider;
exports.Toast = Toast;
exports.ToastProvider = ToastProvider;
exports.Tooltip = Tooltip;
exports.TooltipDelayGroupContext = TooltipDelayGroupContext;
exports.TooltipDelayGroupProvider = TooltipDelayGroupProvider;
exports.Tree = Tree;
exports.TreeItem = TreeItem;
exports.VirtualList = VirtualList;
exports._ResizeObserver = _ResizeObserver;
exports._elementSizeObserver = _elementSizeObserver;
exports._fillCSSObject = _fillCSSObject;
exports._getArrayProp = _getArrayProp;
exports._getResponsiveSpace = _getResponsiveSpace;
exports._hasFocus = _hasFocus;
exports._isEnterToClickElement = _isEnterToClickElement;
exports._isScrollable = _isScrollable;
exports._raf = _raf;
exports._raf2 = _raf2;
exports._responsive = _responsive;
exports.attemptFocus = attemptFocus;
exports.containsOrEqualsElement = containsOrEqualsElement;
exports.createColorTheme = createColorTheme;
exports.focusFirstDescendant = focusFirstDescendant;
exports.focusLastDescendant = focusLastDescendant;
exports.hexToRgb = hexToRgb;
exports.hslToRgb = hslToRgb;
exports.isFocusable = isFocusable;
exports.isHTMLAnchorElement = isHTMLAnchorElement;
exports.isHTMLButtonElement = isHTMLButtonElement;
exports.isHTMLElement = isHTMLElement;
exports.isHTMLInputElement = isHTMLInputElement;
exports.isHTMLSelectElement = isHTMLSelectElement;
exports.isHTMLTextAreaElement = isHTMLTextAreaElement;
exports.multiply = multiply$1;
exports.parseColor = parseColor;
exports.rem = rem;
exports.responsiveCodeFontStyle = responsiveCodeFontStyle;
exports.responsiveHeadingFont = responsiveHeadingFont;
exports.responsiveLabelFont = responsiveLabelFont;
exports.responsiveTextAlignStyle = responsiveTextAlignStyle;
exports.responsiveTextFont = responsiveTextFont;
exports.rgbToHex = rgbToHex;
exports.rgbToHsl = rgbToHsl;
exports.rgba = rgba;
exports.screen = screen$1;
exports.studioTheme = studioTheme;
exports.useArrayProp = useArrayProp;
exports.useBoundaryElement = useBoundaryElement;
exports.useClickOutside = useClickOutside;
exports.useCustomValidity = useCustomValidity;
exports.useDialog = useDialog;
exports.useElementRect = useElementRect;
exports.useElementSize = useElementSize;
exports.useForwardedRef = useForwardedRef;
exports.useGlobalKeyDown = useGlobalKeyDown;
exports.useLayer = useLayer;
exports.useMediaIndex = useMediaIndex;
exports.usePortal = usePortal;
exports.usePrefersDark = usePrefersDark;
exports.usePrefersReducedMotion = usePrefersReducedMotion;
exports.useRootTheme = useRootTheme;
exports.useTheme = useTheme;
exports.useToast = useToast;
exports.useTooltipDelayGroup = useTooltipDelayGroup;
exports.useTree = useTree;
//# sourceMappingURL=index.js.map
