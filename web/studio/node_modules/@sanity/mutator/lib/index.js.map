{"version":3,"file":"index.js","sources":["../src/jsonpath/tokenize.ts","../src/jsonpath/parse.ts","../src/jsonpath/descend.ts","../src/jsonpath/toPath.ts","../src/jsonpath/Expression.ts","../src/jsonpath/Descender.ts","../src/jsonpath/Matcher.ts","../src/util.ts","../src/jsonpath/PlainProbe.ts","../src/jsonpath/extractAccessors.ts","../src/jsonpath/extract.ts","../src/jsonpath/extractWithPath.ts","../src/jsonpath/arrayToJSONMatchPath.ts","../src/patch/SetPatch.ts","../src/patch/IncPatch.ts","../src/patch/util.ts","../src/patch/InsertPatch.ts","../src/patch/SetIfMissingPatch.ts","../src/patch/UnsetPatch.ts","../src/patch/DiffMatchPatch.ts","../src/patch/parse.ts","../src/patch/ImmutableAccessor.ts","../src/patch/Patcher.ts","../src/document/luid.ts","../src/document/debug.ts","../src/document/Mutation.ts","../src/document/Document.ts","../src/document/SquashingBuffer.ts","../src/document/BufferedDocument.ts"],"sourcesContent":["import type {\n  IdentifierToken,\n  NumberToken,\n  QuotedToken,\n  SymbolClass,\n  SymbolToken,\n  Token,\n} from './types'\n\n// TODO: Support '*'\n\nconst digitChar = /[0-9]/\nconst attributeCharMatcher = /^[a-zA-Z0-9_]$/\nconst attributeFirstCharMatcher = /^[a-zA-Z_]$/\n\nconst symbols: Record<SymbolClass, string[]> = {\n  // NOTE: These are compared against in order of definition,\n  // thus '==' must come before '=', '>=' before '>', etc.\n  operator: ['..', '.', ',', ':', '?'],\n  comparator: ['>=', '<=', '<', '>', '==', '!='],\n  keyword: ['$', '@'],\n  boolean: ['true', 'false'],\n  paren: ['[', ']'],\n}\n\nconst symbolClasses = Object.keys(symbols) as SymbolClass[]\n\ntype TokenizerFn = () => Token | null\n\n/**\n * Tokenizes a jsonpath2 expression\n */\nclass Tokenizer {\n  source: string\n  i: number\n  length: number\n  tokenizers: TokenizerFn[]\n\n  constructor(path: string) {\n    this.source = path\n    this.length = path.length\n    this.i = 0\n    this.tokenizers = [\n      this.tokenizeSymbol,\n      this.tokenizeIdentifier,\n      this.tokenizeNumber,\n      this.tokenizeQuoted,\n    ].map((fn) => fn.bind(this))\n  }\n\n  tokenize(): Token[] {\n    const result: Token[] = []\n    while (!this.EOF()) {\n      this.chompWhitespace()\n      let token: Token | null = null\n      // @todo refactor into a simpler `.find()`?\n      const found = this.tokenizers.some((tokenizer) => {\n        token = tokenizer()\n        return Boolean(token)\n      })\n      if (!found || !token) {\n        throw new Error(`Invalid tokens in jsonpath '${this.source}' @ ${this.i}`)\n      }\n      result.push(token)\n    }\n    return result\n  }\n\n  takeWhile(fn: (character: string) => string | null): string | null {\n    const start = this.i\n    let result = ''\n    while (!this.EOF()) {\n      const nextChar = fn(this.source[this.i])\n      if (nextChar === null) {\n        break\n      }\n      result += nextChar\n      this.i++\n    }\n    if (this.i === start) {\n      return null\n    }\n    return result\n  }\n\n  EOF(): boolean {\n    return this.i >= this.length\n  }\n\n  peek(): string | null {\n    if (this.EOF()) {\n      return null\n    }\n    return this.source[this.i]\n  }\n\n  consume(str: string) {\n    if (this.i + str.length > this.length) {\n      throw new Error(`Expected ${str} at end of jsonpath`)\n    }\n    if (str === this.source.slice(this.i, this.i + str.length)) {\n      this.i += str.length\n    } else {\n      throw new Error(`Expected \"${str}\", but source contained \"${this.source.slice()}`)\n    }\n  }\n\n  // Tries to match the upcoming bit of string with the provided string. If it matches, returns\n  // the string, then advances the read pointer to the next bit. If not, returns null and nothing\n  // happens.\n  tryConsume(str: string) {\n    if (this.i + str.length > this.length) {\n      return null\n    }\n    if (str === this.source.slice(this.i, this.i + str.length)) {\n      this.i += str.length\n      return str\n    }\n    return null\n  }\n\n  chompWhitespace(): void {\n    this.takeWhile((char): string | null => {\n      return char === ' ' ? '' : null\n    })\n  }\n\n  tokenizeQuoted(): QuotedToken | null {\n    const quote = this.peek()\n    if (quote === \"'\" || quote === '\"') {\n      this.consume(quote)\n      let escape = false\n      const inner = this.takeWhile((char) => {\n        if (escape) {\n          escape = false\n          return char\n        }\n        if (char === '\\\\') {\n          escape = true\n          return ''\n        }\n        if (char != quote) {\n          return char\n        }\n        return null\n      })\n      this.consume(quote)\n      return {\n        type: 'quoted',\n        value: inner,\n        quote: quote === '\"' ? 'double' : 'single',\n      }\n    }\n    return null\n  }\n\n  tokenizeIdentifier(): IdentifierToken | null {\n    let first = true\n    const identifier = this.takeWhile((char) => {\n      if (first) {\n        first = false\n        return char.match(attributeFirstCharMatcher) ? char : null\n      }\n      return char.match(attributeCharMatcher) ? char : null\n    })\n    if (identifier !== null) {\n      return {\n        type: 'identifier',\n        name: identifier,\n      }\n    }\n    return null\n  }\n\n  tokenizeNumber(): NumberToken | null {\n    const start = this.i\n    let dotSeen = false\n    let digitSeen = false\n    let negative = false\n    if (this.peek() === '-') {\n      negative = true\n      this.consume('-')\n    }\n    const number = this.takeWhile((char) => {\n      if (char === '.' && !dotSeen && digitSeen) {\n        dotSeen = true\n        return char\n      }\n      digitSeen = true\n      return char.match(digitChar) ? char : null\n    })\n    if (number !== null) {\n      return {\n        type: 'number',\n        value: negative ? -number : +number,\n        raw: negative ? `-${number}` : number,\n      }\n    }\n    // No number, rewind\n    this.i = start\n    return null\n  }\n\n  tokenizeSymbol(): SymbolToken | null {\n    for (const symbolClass of symbolClasses) {\n      const patterns = symbols[symbolClass]\n      const symbol = patterns.find((pattern) => this.tryConsume(pattern))\n      if (symbol) {\n        return {\n          type: symbolClass,\n          symbol,\n        }\n      }\n    }\n\n    return null\n  }\n}\n\nexport function tokenize(jsonpath: string): Token[] {\n  return new Tokenizer(jsonpath).tokenize()\n}\n","// Converts a string into an abstract syntax tree representation\n\nimport {tokenize} from './tokenize'\nimport type {\n  AliasExpr,\n  AttributeExpr,\n  BooleanExpr,\n  ConstraintExpr,\n  IndexExpr,\n  NumberExpr,\n  PathExpr,\n  RangeExpr,\n  RecursiveExpr,\n  StringExpr,\n  Token,\n  UnionExpr,\n} from './types'\n\n// TODO: Support '*'\n\nclass Parser {\n  tokens: Token[]\n  length: number\n  i: number\n\n  constructor(path: string) {\n    this.tokens = tokenize(path)\n    this.length = this.tokens.length\n    this.i = 0\n  }\n\n  parse() {\n    return this.parsePath()\n  }\n\n  EOF() {\n    return this.i >= this.length\n  }\n\n  // Look at upcoming token\n  peek() {\n    if (this.EOF()) {\n      return null\n    }\n    return this.tokens[this.i]\n  }\n\n  consume() {\n    const result = this.peek()\n    this.i += 1\n    return result\n  }\n\n  // Return next token if it matches the pattern\n  probe(pattern: Record<string, unknown>): Token | null {\n    const token = this.peek()\n    if (!token) {\n      return null\n    }\n\n    const record = token as unknown as Record<string, unknown>\n    const match = Object.keys(pattern).every((key) => {\n      return key in token && pattern[key] === record[key]\n    })\n\n    return match ? token : null\n  }\n\n  // Return and consume next token if it matches the pattern\n  match(pattern: Partial<Token>): Token | null {\n    return this.probe(pattern) ? this.consume() : null\n  }\n\n  parseAttribute(): AttributeExpr | null {\n    const token = this.match({type: 'identifier'})\n    if (token && token.type === 'identifier') {\n      return {\n        type: 'attribute',\n        name: token.name,\n      }\n    }\n    const quoted = this.match({type: 'quoted', quote: 'single'})\n    if (quoted && quoted.type === 'quoted') {\n      return {\n        type: 'attribute',\n        name: quoted.value || '',\n      }\n    }\n    return null\n  }\n\n  parseAlias(): AliasExpr | null {\n    if (this.match({type: 'keyword', symbol: '@'}) || this.match({type: 'keyword', symbol: '$'})) {\n      return {\n        type: 'alias',\n        target: 'self',\n      }\n    }\n    return null\n  }\n\n  parseNumber(): NumberExpr | null {\n    const token = this.match({type: 'number'})\n    if (token && token.type === 'number') {\n      return {\n        type: 'number',\n        value: token.value,\n      }\n    }\n    return null\n  }\n\n  parseNumberValue(): number | null {\n    const expr = this.parseNumber()\n    if (expr) {\n      return expr.value\n    }\n    return null\n  }\n\n  parseSliceSelector(): RangeExpr | IndexExpr | null {\n    const start = this.i\n    const rangeStart = this.parseNumberValue()\n\n    const colon1 = this.match({type: 'operator', symbol: ':'})\n    if (!colon1) {\n      if (rangeStart === null) {\n        // Rewind, this was actually nothing\n        this.i = start\n        return null\n      }\n\n      // Unwrap, this was just a single index not followed by colon\n      return {type: 'index', value: rangeStart}\n    }\n\n    const result: RangeExpr = {\n      type: 'range',\n      start: rangeStart,\n      end: this.parseNumberValue(),\n    }\n\n    const colon2 = this.match({type: 'operator', symbol: ':'})\n    if (colon2) {\n      result.step = this.parseNumberValue()\n    }\n\n    if (result.start === null && result.end === null) {\n      // rewind, this wasnt' a slice selector\n      this.i = start\n      return null\n    }\n\n    return result\n  }\n\n  parseValueReference(): AttributeExpr | RangeExpr | IndexExpr | null {\n    return this.parseAttribute() || this.parseSliceSelector()\n  }\n\n  parseLiteralValue(): StringExpr | BooleanExpr | NumberExpr | null {\n    const literalString = this.match({type: 'quoted', quote: 'double'})\n    if (literalString && literalString.type === 'quoted') {\n      return {\n        type: 'string',\n        value: literalString.value || '',\n      }\n    }\n    const literalBoolean = this.match({type: 'boolean'})\n    if (literalBoolean && literalBoolean.type === 'boolean') {\n      return {\n        type: 'boolean',\n        value: literalBoolean.symbol === 'true',\n      }\n    }\n    return this.parseNumber()\n  }\n\n  // TODO: Reorder constraints so that literal value is always on rhs, and variable is always\n  // on lhs.\n  parseFilterExpression(): ConstraintExpr | null {\n    const start = this.i\n    const expr = this.parseAttribute() || this.parseAlias()\n    if (!expr) {\n      return null\n    }\n\n    if (this.match({type: 'operator', symbol: '?'})) {\n      return {\n        type: 'constraint',\n        operator: '?',\n        lhs: expr,\n      }\n    }\n\n    const binOp = this.match({type: 'comparator'})\n    if (!binOp || binOp.type !== 'comparator') {\n      // No expression, rewind!\n      this.i = start\n      return null\n    }\n\n    const lhs = expr\n    const rhs = this.parseLiteralValue()\n    if (!rhs) {\n      throw new Error(`Operator ${binOp.symbol} needs a literal value at the right hand side`)\n    }\n\n    return {\n      type: 'constraint',\n      operator: binOp.symbol,\n      lhs: lhs,\n      rhs: rhs,\n    }\n  }\n\n  parseExpression(): ConstraintExpr | AttributeExpr | RangeExpr | IndexExpr | null {\n    return this.parseFilterExpression() || this.parseValueReference()\n  }\n\n  parseUnion(): UnionExpr | null {\n    if (!this.match({type: 'paren', symbol: '['})) {\n      return null\n    }\n\n    const terms = []\n    let expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference()\n    while (expr) {\n      terms.push(expr)\n      // End of union?\n      if (this.match({type: 'paren', symbol: ']'})) {\n        break\n      }\n\n      if (!this.match({type: 'operator', symbol: ','})) {\n        throw new Error('Expected ]')\n      }\n\n      expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference()\n      if (!expr) {\n        throw new Error(\"Expected expression following ','\")\n      }\n    }\n\n    return {\n      type: 'union',\n      nodes: terms,\n    }\n  }\n\n  parseRecursive(): RecursiveExpr | null {\n    if (!this.match({type: 'operator', symbol: '..'})) {\n      return null\n    }\n\n    const subpath = this.parsePath()\n    if (!subpath) {\n      throw new Error(\"Expected path following '..' operator\")\n    }\n\n    return {\n      type: 'recursive',\n      term: subpath,\n    }\n  }\n\n  parsePath(): PathExpr | AttributeExpr | UnionExpr | RecursiveExpr | null {\n    const nodes: (AttributeExpr | UnionExpr | RecursiveExpr)[] = []\n    const expr = this.parseAttribute() || this.parseUnion() || this.parseRecursive()\n    if (!expr) {\n      return null\n    }\n\n    nodes.push(expr)\n    while (!this.EOF()) {\n      if (this.match({type: 'operator', symbol: '.'})) {\n        const attr = this.parseAttribute()\n        if (!attr) {\n          throw new Error(\"Expected attribute name following '.\")\n        }\n        nodes.push(attr)\n        continue\n      } else if (this.probe({type: 'paren', symbol: '['})) {\n        const union = this.parseUnion()\n        if (!union) {\n          throw new Error(\"Expected union following '['\")\n        }\n        nodes.push(union)\n      } else {\n        const recursive = this.parseRecursive()\n        if (recursive) {\n          nodes.push(recursive)\n        }\n        break\n      }\n    }\n\n    if (nodes.length === 1) {\n      return nodes[0]\n    }\n\n    return {\n      type: 'path',\n      nodes: nodes,\n    }\n  }\n}\n\nexport function parseJsonPath(path: string): PathExpr | AttributeExpr | UnionExpr | RecursiveExpr {\n  const parsed = new Parser(path).parse()\n  if (!parsed) {\n    throw new Error(`Failed to parse JSON path \"${path}\"`)\n  }\n  return parsed\n}\n","import type {Expr, PathExpr} from './types'\n\n/**\n * Splits an expression into a set of heads, tails. A head is the next leaf node to\n * check for matches, and a tail is everything that follows it. Matching is done by\n * matching heads, then proceedint to the matching value, splitting the tail into\n * heads and tails and checking the heads against the new value, and so on.\n */\nexport function descend(tail: Expr): [Expr | null, PathExpr | null][] {\n  const [head, newTail] = splitIfPath(tail)\n  if (!head) {\n    throw new Error('Head cannot be null')\n  }\n\n  return spreadIfUnionHead(head, newTail)\n}\n\n// Split path in [head, tail]\nfunction splitIfPath(tail: Expr): [Expr | null, PathExpr | null] {\n  if (tail.type !== 'path') {\n    return [tail, null]\n  }\n\n  const nodes = tail.nodes\n  if (nodes.length === 0) {\n    return [null, null]\n  }\n\n  if (nodes.length === 1) {\n    return [nodes[0], null]\n  }\n\n  return [nodes[0], {type: 'path', nodes: nodes.slice(1)}]\n}\n\nfunction concatPaths(path1: PathExpr | null, path2: PathExpr | null): PathExpr | null {\n  if (!path1 && !path2) {\n    return null\n  }\n\n  const nodes1 = path1 ? path1.nodes : []\n  const nodes2 = path2 ? path2.nodes : []\n  return {\n    type: 'path',\n    nodes: nodes1.concat(nodes2),\n  }\n}\n\n// Spreads a union head into several heads/tails\nfunction spreadIfUnionHead(head: Expr, tail: PathExpr | null): [Expr | null, PathExpr | null][] {\n  if (head.type !== 'union') {\n    return [[head, tail]]\n  }\n\n  return head.nodes.map((node) => {\n    if (node.type === 'path') {\n      const [subHead, subTail] = splitIfPath(node)\n      return [subHead, concatPaths(subTail, tail)]\n    }\n\n    return [node, tail]\n  })\n}\n","import type {Expr} from './types'\n\n/**\n * Converts a parsed expression back into jsonpath2, roughly -\n * mostly for use with tests.\n *\n * @param expr - Expression to convert to path\n * @returns a string representation of the path\n * @internal\n */\nexport function toPath(expr: Expr): string {\n  return toPathInner(expr, false)\n}\n\nfunction toPathInner(expr: Expr, inUnion: boolean): string {\n  switch (expr.type) {\n    case 'attribute':\n      return expr.name\n    case 'alias':\n      return expr.target === 'self' ? '@' : '$'\n    case 'number':\n      return `${expr.value}`\n    case 'range': {\n      const result = []\n      if (!inUnion) {\n        result.push('[')\n      }\n      if (expr.start) {\n        result.push(`${expr.start}`)\n      }\n      result.push(':')\n      if (expr.end) {\n        result.push(`${expr.end}`)\n      }\n      if (expr.step) {\n        result.push(`:${expr.step}`)\n      }\n      if (!inUnion) {\n        result.push(']')\n      }\n      return result.join('')\n    }\n    case 'index':\n      if (inUnion) {\n        return `${expr.value}`\n      }\n\n      return `[${expr.value}]`\n    case 'constraint': {\n      const rhs = expr.rhs ? ` ${toPathInner(expr.rhs, false)}` : ''\n      const inner = `${toPathInner(expr.lhs, false)} ${expr.operator}${rhs}`\n\n      if (inUnion) {\n        return inner\n      }\n\n      return `[${inner}]`\n    }\n    case 'string':\n      return JSON.stringify(expr.value)\n    case 'path': {\n      const result = []\n      const nodes = expr.nodes.slice()\n      while (nodes.length > 0) {\n        const node = nodes.shift()\n        if (node) {\n          result.push(toPath(node))\n        }\n\n        const upcoming = nodes[0]\n        if (upcoming && toPathInner(upcoming, false)[0] !== '[') {\n          result.push('.')\n        }\n      }\n      return result.join('')\n    }\n    case 'union':\n      return `[${expr.nodes.map((e) => toPathInner(e, true)).join(',')}]`\n    default:\n      throw new Error(`Unknown node type ${expr.type}`)\n    case 'recursive':\n      return `..${toPathInner(expr.term, false)}`\n  }\n}\n","// A utility wrapper class to process parsed jsonpath expressions\n\nimport type {Expr, HeadTail} from './types'\nimport type {Probe} from './Probe'\nimport {descend} from './descend'\nimport {toPath} from './toPath'\nimport {parseJsonPath} from './parse'\n\nexport interface Range {\n  start: number\n  end: number\n  step: number\n}\n\nexport class Expression {\n  expr: Expr\n\n  constructor(expr: Expr | Expression | null) {\n    if (!expr) {\n      throw new Error('Attempted to create Expression from null-value')\n    }\n\n    // This is a wrapped expr\n    if ('expr' in expr) {\n      this.expr = expr.expr\n    } else {\n      this.expr = expr\n    }\n\n    if (!('type' in this.expr)) {\n      throw new Error('Attempt to create Expression for expression with no type')\n    }\n  }\n\n  isPath(): boolean {\n    return this.expr.type === 'path'\n  }\n\n  isUnion(): boolean {\n    return this.expr.type === 'union'\n  }\n\n  isCollection(): boolean {\n    return this.isPath() || this.isUnion()\n  }\n\n  isConstraint(): boolean {\n    return this.expr.type === 'constraint'\n  }\n\n  isRecursive(): boolean {\n    return this.expr.type === 'recursive'\n  }\n\n  isExistenceConstraint(): boolean {\n    return this.expr.type === 'constraint' && this.expr.operator === '?'\n  }\n\n  isIndex(): boolean {\n    return this.expr.type === 'index'\n  }\n\n  isRange(): boolean {\n    return this.expr.type === 'range'\n  }\n\n  expandRange(probe?: Probe): Range {\n    const probeLength = () => {\n      if (!probe) {\n        throw new Error('expandRange() required a probe that was not passed')\n      }\n\n      return probe.length()\n    }\n\n    let start = 'start' in this.expr ? this.expr.start || 0 : 0\n    start = interpretNegativeIndex(start, probe)\n    let end = 'end' in this.expr ? this.expr.end || probeLength() : probeLength()\n    end = interpretNegativeIndex(end, probe)\n    const step = 'step' in this.expr ? this.expr.step || 1 : 1\n    return {start, end, step}\n  }\n\n  isAttributeReference(): boolean {\n    return this.expr.type === 'attribute'\n  }\n\n  // Is a range or index -> something referencing indexes\n  isIndexReference(): boolean {\n    return this.isIndex() || this.isRange()\n  }\n\n  name(): string {\n    return 'name' in this.expr ? this.expr.name : ''\n  }\n\n  isSelfReference(): boolean {\n    return this.expr.type === 'alias' && this.expr.target === 'self'\n  }\n\n  constraintTargetIsSelf(): boolean {\n    return (\n      this.expr.type === 'constraint' &&\n      this.expr.lhs.type === 'alias' &&\n      this.expr.lhs.target === 'self'\n    )\n  }\n\n  constraintTargetIsAttribute(): boolean {\n    return this.expr.type === 'constraint' && this.expr.lhs.type === 'attribute'\n  }\n\n  testConstraint(probe: Probe): boolean {\n    const expr = this.expr\n\n    if (expr.type === 'constraint' && expr.lhs.type === 'alias' && expr.lhs.target === 'self') {\n      if (probe.containerType() !== 'primitive') {\n        return false\n      }\n\n      if (expr.type === 'constraint' && expr.operator === '?') {\n        return true\n      }\n\n      const lhs = probe.get()\n      const rhs = expr.rhs && 'value' in expr.rhs ? expr.rhs.value : undefined\n      return testBinaryOperator(lhs, expr.operator, rhs)\n    }\n\n    if (expr.type !== 'constraint') {\n      return false\n    }\n\n    const lhs = expr.lhs\n    if (!lhs) {\n      throw new Error('No LHS of expression')\n    }\n\n    if (lhs.type !== 'attribute') {\n      throw new Error(`Constraint target ${lhs.type} not supported`)\n    }\n\n    if (probe.containerType() !== 'object') {\n      return false\n    }\n\n    const lhsValue = probe.getAttribute(lhs.name)\n    if (lhsValue === undefined || lhsValue === null || lhsValue.containerType() !== 'primitive') {\n      // LHS is void and empty, or it is a collection\n      return false\n    }\n\n    if (this.isExistenceConstraint()) {\n      // There is no rhs, and if we're here the key did exist\n      return true\n    }\n\n    const rhs = expr.rhs && 'value' in expr.rhs ? expr.rhs.value : undefined\n    return testBinaryOperator(lhsValue.get(), expr.operator, rhs)\n  }\n\n  pathNodes(): Expr[] {\n    return this.expr.type === 'path' ? this.expr.nodes : [this.expr]\n  }\n\n  prepend(node: Expression): Expression {\n    if (!node) {\n      return this\n    }\n\n    return new Expression({\n      type: 'path',\n      nodes: node.pathNodes().concat(this.pathNodes()),\n    })\n  }\n\n  concat(other: Expression | null): Expression {\n    return other ? other.prepend(this) : this\n  }\n\n  descend(): HeadTail[] {\n    return descend(this.expr).map((headTail) => {\n      const [head, tail] = headTail\n      return {\n        head: head ? new Expression(head) : null,\n        tail: tail ? new Expression(tail) : null,\n      }\n    })\n  }\n\n  unwrapRecursive(): Expression {\n    if (this.expr.type !== 'recursive') {\n      throw new Error(`Attempt to unwrap recursive on type ${this.expr.type}`)\n    }\n\n    return new Expression(this.expr.term)\n  }\n\n  toIndicies(probe?: Probe): number[] {\n    if (this.expr.type !== 'index' && this.expr.type !== 'range') {\n      throw new Error('Node cannot be converted to indexes')\n    }\n\n    if (this.expr.type === 'index') {\n      return [interpretNegativeIndex(this.expr.value, probe)]\n    }\n\n    const result: number[] = []\n    const range = this.expandRange(probe)\n    let {start, end} = range\n    if (range.step < 0) {\n      ;[start, end] = [end, start]\n    }\n\n    for (let i = start; i < end; i++) {\n      result.push(i)\n    }\n\n    return result\n  }\n\n  toFieldReferences(): number[] | string[] {\n    if (this.isIndexReference()) {\n      return this.toIndicies()\n    }\n    if (this.expr.type === 'attribute') {\n      return [this.expr.name]\n    }\n    throw new Error(`Can't convert ${this.expr.type} to field references`)\n  }\n\n  toString(): string {\n    return toPath(this.expr)\n  }\n\n  static fromPath(path: string): Expression {\n    const parsed = parseJsonPath(path)\n    if (!parsed) {\n      throw new Error(`Failed to parse path \"${path}\"`)\n    }\n\n    return new Expression(parsed)\n  }\n\n  static attributeReference(name: string): Expression {\n    return new Expression({\n      type: 'attribute',\n      name: name,\n    })\n  }\n\n  static indexReference(i: number): Expression {\n    return new Expression({\n      type: 'index',\n      value: i,\n    })\n  }\n}\n\n// Tests an operator on two given primitive values\nfunction testBinaryOperator(lhsValue: any, operator: string, rhsValue: any) {\n  switch (operator) {\n    case '>':\n      return lhsValue > rhsValue\n    case '>=':\n      return lhsValue >= rhsValue\n    case '<':\n      return lhsValue < rhsValue\n    case '<=':\n      return lhsValue <= rhsValue\n    case '==':\n      return lhsValue === rhsValue\n    case '!=':\n      return lhsValue !== rhsValue\n    default:\n      throw new Error(`Unsupported binary operator ${operator}`)\n  }\n}\n\nfunction interpretNegativeIndex(index: number, probe?: Probe): number {\n  if (index >= 0) {\n    return index\n  }\n\n  if (!probe) {\n    throw new Error('interpretNegativeIndex() must have a probe when < 0')\n  }\n\n  return index + probe.length()\n}\n","import {flatten} from 'lodash'\nimport {Expression} from './Expression'\nimport type {Probe} from './Probe'\n\n/**\n * Descender models the state of one partial jsonpath evaluation. Head is the\n * next thing to match, tail is the upcoming things once the head is matched.\n */\nexport class Descender {\n  head: Expression | null\n  tail: Expression | null\n\n  constructor(head: Expression | null, tail: Expression | null) {\n    this.head = head\n    this.tail = tail\n  }\n\n  // Iterate this descender once processing any constraints that are\n  // resolvable on the current value. Returns an array of new descenders\n  // that are guaranteed to be without constraints in the head\n  iterate(probe: Probe): Descender[] {\n    let result: Descender[] = [this]\n    if (this.head && this.head.isConstraint()) {\n      let anyConstraints = true\n      // Keep rewriting constraints until there are none left\n      while (anyConstraints) {\n        result = flatten(\n          result.map((descender) => {\n            return descender.iterateConstraints(probe)\n          }),\n        )\n        anyConstraints = result.some((descender) => {\n          return descender.head && descender.head.isConstraint()\n        })\n      }\n    }\n    return result\n  }\n\n  isRecursive(): boolean {\n    return Boolean(this.head && this.head.isRecursive())\n  }\n\n  hasArrived(): boolean {\n    return this.head === null && this.tail === null\n  }\n\n  extractRecursives(): Descender[] {\n    if (this.head && this.head.isRecursive()) {\n      const term = this.head.unwrapRecursive()\n      return new Descender(null, term.concat(this.tail)).descend()\n    }\n    return []\n  }\n\n  iterateConstraints(probe: Probe): Descender[] {\n    const head = this.head\n    if (head === null || !head.isConstraint()) {\n      // Not a constraint, no rewrite\n      return [this]\n    }\n\n    const result: Descender[] = []\n\n    if (probe.containerType() === 'primitive' && head.constraintTargetIsSelf()) {\n      if (head.testConstraint(probe)) {\n        result.push(...this.descend())\n      }\n      return result\n    }\n\n    // The value is an array\n    if (probe.containerType() === 'array') {\n      const length = probe.length()\n      for (let i = 0; i < length; i++) {\n        // Push new descenders with constraint translated to literal indices\n        // where they match\n        const constraint = probe.getIndex(i)\n        if (constraint && head.testConstraint(constraint)) {\n          result.push(new Descender(new Expression({type: 'index', value: i}), this.tail))\n        }\n      }\n      return result\n    }\n\n    // The value is an object\n    if (probe.containerType() === 'object') {\n      if (head.constraintTargetIsSelf()) {\n        // There are no matches for target self ('@') on a plain object\n        return []\n      }\n\n      if (head.testConstraint(probe)) {\n        return this.descend()\n      }\n\n      return result\n    }\n\n    return result\n  }\n\n  descend(): Descender[] {\n    if (!this.tail) {\n      return [new Descender(null, null)]\n    }\n\n    return this.tail.descend().map((ht) => {\n      return new Descender(ht.head, ht.tail)\n    })\n  }\n\n  toString(): string {\n    const result = ['<']\n    if (this.head) {\n      result.push(this.head.toString())\n    }\n    result.push('|')\n    if (this.tail) {\n      result.push(this.tail.toString())\n    }\n    result.push('>')\n    return result.join('')\n  }\n}\n","import {parseJsonPath} from './parse'\nimport {Descender} from './Descender'\nimport {Expression} from './Expression'\nimport type {Probe} from './Probe'\n\ninterface Result<P = unknown> {\n  leads: {\n    target: Expression\n    matcher: Matcher\n  }[]\n\n  delivery?: {\n    targets: Expression[]\n    payload: P\n  }\n}\n\n/**\n * @internal\n */\nexport class Matcher {\n  active: Descender[]\n  recursives: Descender[]\n  payload: unknown\n\n  constructor(active: Descender[], parent?: Matcher) {\n    this.active = active || []\n    if (parent) {\n      this.recursives = parent.recursives\n      this.payload = parent.payload\n    } else {\n      this.recursives = []\n    }\n    this.extractRecursives()\n  }\n\n  setPayload(payload: unknown): this {\n    this.payload = payload\n    return this\n  }\n\n  // Moves any recursive descenders onto the recursive track, removing them from\n  // the active set\n  extractRecursives(): void {\n    this.active = this.active.filter((descender) => {\n      if (descender.isRecursive()) {\n        this.recursives.push(...descender.extractRecursives())\n        return false\n      }\n      return true\n    })\n  }\n\n  // Find recursives that are relevant now and should be considered part of the active set\n  activeRecursives(probe: Probe): Descender[] {\n    return this.recursives.filter((descender) => {\n      const head = descender.head\n      if (!head) {\n        return false\n      }\n\n      // Constraints are always relevant\n      if (head.isConstraint()) {\n        return true\n      }\n\n      // Index references are only relevant for indexable values\n      if (probe.containerType() === 'array' && head.isIndexReference()) {\n        return true\n      }\n\n      // Attribute references are relevant for plain objects\n      if (probe.containerType() === 'object') {\n        return head.isAttributeReference() && probe.hasAttribute(head.name())\n      }\n\n      return false\n    })\n  }\n\n  match(probe: Probe): Result {\n    return this.iterate(probe).extractMatches(probe)\n  }\n\n  iterate(probe: Probe): Matcher {\n    const newActiveSet: Descender[] = []\n    this.active.concat(this.activeRecursives(probe)).forEach((descender) => {\n      newActiveSet.push(...descender.iterate(probe))\n    })\n    return new Matcher(newActiveSet, this)\n  }\n\n  // Returns true if any of the descenders in the active or recursive set\n  // consider the current state a final destination\n  isDestination(): boolean {\n    return this.active.some((descender) => descender.hasArrived())\n  }\n\n  hasRecursives(): boolean {\n    return this.recursives.length > 0\n  }\n\n  // Returns any payload delivieries and leads that needs to be followed to complete\n  // the process.\n  extractMatches(probe: Probe): Result {\n    const leads: {target: Expression; matcher: Matcher}[] = []\n    const targets: Expression[] = []\n    this.active.forEach((descender) => {\n      if (descender.hasArrived()) {\n        // This was already arrived, so matches this value, not descenders\n        targets.push(\n          new Expression({\n            type: 'alias',\n            target: 'self',\n          }),\n        )\n        return\n      }\n\n      const descenderHead = descender.head\n      if (!descenderHead) {\n        return\n      }\n\n      if (probe.containerType() === 'array' && !descenderHead.isIndexReference()) {\n        // This descender does not match an indexable value\n        return\n      }\n\n      if (probe.containerType() === 'object' && !descenderHead.isAttributeReference()) {\n        // This descender never match a plain object\n        return\n      }\n\n      if (descender.tail) {\n        // Not arrived yet\n        const matcher = new Matcher(descender.descend(), this)\n        descenderHead.toFieldReferences().forEach(() => {\n          leads.push({\n            target: descenderHead,\n            matcher: matcher,\n          })\n        })\n      } else {\n        // arrived\n        targets.push(descenderHead)\n      }\n    })\n\n    // If there are recursive terms, we need to add a lead for every descendant ...\n    if (this.hasRecursives()) {\n      // The recustives matcher will have no active set, only inherit recursives from this\n      const recursivesMatcher = new Matcher([], this)\n      if (probe.containerType() === 'array') {\n        const length = probe.length()\n        for (let i = 0; i < length; i++) {\n          leads.push({\n            target: Expression.indexReference(i),\n            matcher: recursivesMatcher,\n          })\n        }\n      } else if (probe.containerType() === 'object') {\n        probe.attributeKeys().forEach((name) => {\n          leads.push({\n            target: Expression.attributeReference(name),\n            matcher: recursivesMatcher,\n          })\n        })\n      }\n    }\n\n    return targets.length > 0\n      ? {leads: leads, delivery: {targets, payload: this.payload}}\n      : {leads: leads}\n  }\n\n  static fromPath(jsonpath: string): Matcher {\n    const path = parseJsonPath(jsonpath)\n    if (!path) {\n      throw new Error(`Failed to parse path from \"${jsonpath}\"`)\n    }\n\n    const descender = new Descender(null, new Expression(path))\n    return new Matcher(descender.descend())\n  }\n}\n","export function isRecord(value: unknown): value is {[key: string]: unknown} {\n  return value !== null && typeof value === 'object'\n}\n","import {isRecord} from '../util'\nimport type {Probe} from './Probe'\n\n// A default implementation of a probe for vanilla JS _values\nexport class PlainProbe implements Probe {\n  _value: unknown\n  path: (string | number)[]\n\n  constructor(value: unknown, path?: (string | number)[]) {\n    this._value = value\n    this.path = path || []\n  }\n\n  containerType(): 'array' | 'object' | 'primitive' {\n    if (Array.isArray(this._value)) {\n      return 'array'\n    } else if (this._value !== null && typeof this._value === 'object') {\n      return 'object'\n    }\n    return 'primitive'\n  }\n\n  length(): number {\n    if (!Array.isArray(this._value)) {\n      throw new Error(\"Won't return length of non-indexable _value\")\n    }\n\n    return this._value.length\n  }\n\n  getIndex(i: number): false | null | PlainProbe {\n    if (!Array.isArray(this._value)) {\n      return false\n    }\n\n    if (i >= this.length()) {\n      return null\n    }\n\n    return new PlainProbe(this._value[i], this.path.concat(i))\n  }\n\n  hasAttribute(key: string): boolean {\n    if (!isRecord(this._value)) {\n      return false\n    }\n\n    return this._value.hasOwnProperty(key)\n  }\n\n  attributeKeys(): string[] {\n    return isRecord(this._value) ? Object.keys(this._value) : []\n  }\n\n  getAttribute(key: string): null | PlainProbe {\n    if (!isRecord(this._value)) {\n      throw new Error('getAttribute only applies to plain objects')\n    }\n\n    if (!this.hasAttribute(key)) {\n      return null\n    }\n\n    return new PlainProbe(this._value[key], this.path.concat(key))\n  }\n\n  get(): unknown {\n    return this._value\n  }\n}\n","import {compact} from 'lodash'\nimport {Expression} from './Expression'\nimport {Matcher} from './Matcher'\nimport {PlainProbe} from './PlainProbe'\nimport {Probe} from './Probe'\n\nexport function extractAccessors(path: string, value: unknown): Probe[] {\n  const result: Probe[] = []\n  const matcher = Matcher.fromPath(path).setPayload(function appendResult(values: Probe[]) {\n    result.push(...values)\n  })\n  const accessor = new PlainProbe(value)\n  descend(matcher, accessor)\n  return result\n}\n\nfunction descend(matcher: Matcher, accessor: Probe) {\n  const {leads, delivery} = matcher.match(accessor)\n\n  leads.forEach((lead) => {\n    accessorsFromTarget(lead.target, accessor).forEach((childAccessor) => {\n      descend(lead.matcher, childAccessor)\n    })\n  })\n\n  if (delivery) {\n    delivery.targets.forEach((target) => {\n      if (typeof delivery.payload === 'function') {\n        delivery.payload(accessorsFromTarget(target, accessor))\n      }\n    })\n  }\n}\n\nfunction accessorsFromTarget(target: Expression, accessor: Probe) {\n  const result = []\n  if (target.isIndexReference()) {\n    target.toIndicies(accessor).forEach((i) => {\n      result.push(accessor.getIndex(i))\n    })\n  } else if (target.isAttributeReference()) {\n    result.push(accessor.getAttribute(target.name()))\n  } else if (target.isSelfReference()) {\n    result.push(accessor)\n  } else {\n    throw new Error(`Unable to derive accessor for target ${target.toString()}`)\n  }\n  return compact(result)\n}\n","import {extractAccessors} from './extractAccessors'\n\n/**\n * Extracts values matching the given JsonPath\n *\n * @param path - Path to extract\n * @param value - Value to extract from\n * @returns An array of values matching the given path\n * @public\n */\nexport function extract(path: string, value: unknown): unknown[] {\n  const accessors = extractAccessors(path, value)\n  return accessors.map((acc) => acc.get())\n}\n","import {extractAccessors} from './extractAccessors'\n\n/**\n * Extracts a value for the given JsonPath, and includes the specific path of where it was found\n *\n * @param path - Path to extract\n * @param value - Value to extract from\n * @returns An array of objects with `path` and `value` keys\n * @internal\n */\nexport function extractWithPath(\n  path: string,\n  value: unknown,\n): {path: (string | number)[]; value: unknown}[] {\n  const accessors = extractAccessors(path, value)\n  return accessors.map((acc) => ({path: acc.path, value: acc.get()}))\n}\n","import type {Path, PathSegment} from '@sanity/types'\nimport {isRecord} from '../util'\n\nconst IS_DOTTABLE = /^[a-z_$]+/\n\n/**\n * Converts a path in array form to a JSONPath string\n *\n * @param pathArray - Array of path segments\n * @returns String representation of the path\n * @internal\n */\nexport function arrayToJSONMatchPath(pathArray: Path): string {\n  let path = ''\n  pathArray.forEach((segment, index) => {\n    path += stringifySegment(segment, index === 0)\n  })\n  return path\n}\n\n// Converts an array of simple values (strings, numbers only) to a jsonmatch path string.\nfunction stringifySegment(\n  segment: PathSegment | Record<string, unknown>,\n  hasLeading: boolean,\n): string {\n  if (typeof segment === 'number') {\n    return `[${segment}]`\n  }\n\n  if (isRecord(segment)) {\n    const seg = segment as Record<string, unknown>\n    return Object.keys(segment)\n      .map((key) => (isPrimitiveValue(seg[key]) ? `[${key}==\"${seg[key]}\"]` : ''))\n      .join('')\n  }\n\n  if (typeof segment === 'string' && IS_DOTTABLE.test(segment)) {\n    return hasLeading ? segment : `.${segment}`\n  }\n\n  return `['${segment}']`\n}\n\nfunction isPrimitiveValue(val: unknown): val is string | number | boolean {\n  switch (typeof val) {\n    case 'number':\n    case 'string':\n    case 'boolean':\n      return true\n    default:\n      return false\n  }\n}\n","import type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\n\nexport class SetPatch {\n  id: string\n  path: string\n  value: unknown\n\n  constructor(id: string, path: string, value: unknown) {\n    this.id = id\n    this.path = path\n    this.value = value\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    targets.forEach((target) => {\n      if (target.isSelfReference()) {\n        result = result.set(this.value)\n      } else if (target.isIndexReference()) {\n        target.toIndicies(accessor).forEach((i) => {\n          result = result.setIndex(i, this.value)\n        })\n      } else if (target.isAttributeReference()) {\n        // setting a subproperty on a primitive value overwrites it, eg\n        // `{set: {'address.street': 'California St'}}` on `{address: 'Fiction St'}` will result in\n        // `{address: {street: 'California St'}}`\n        if (result.containerType() === 'primitive') {\n          result = result.set({[target.name()]: this.value})\n        } else {\n          result = result.setAttribute(target.name(), this.value)\n        }\n      } else {\n        throw new Error(`Unable to apply to target ${target.toString()}`)\n      }\n    })\n    return result\n  }\n}\n","import type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\n\nfunction performIncrement(previousValue: unknown, delta: number): number {\n  if (typeof previousValue !== 'number' || !Number.isFinite(previousValue)) {\n    return previousValue as number\n  }\n\n  return previousValue + delta\n}\n\nexport class IncPatch {\n  path: string\n  value: number\n  id: string\n\n  constructor(id: string, path: string, value: number) {\n    this.path = path\n    this.value = value\n    this.id = id\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n\n    // The target must be a container type\n    if (result.containerType() === 'primitive') {\n      return result\n    }\n\n    for (const target of targets) {\n      if (target.isIndexReference()) {\n        for (const index of target.toIndicies(accessor)) {\n          // Skip patching unless the index actually currently exists\n          const item = result.getIndex(index)\n          if (!item) {\n            continue\n          }\n\n          const previousValue = item.get()\n          result = result.setIndex(index, performIncrement(previousValue, this.value))\n        }\n\n        continue\n      }\n\n      if (target.isAttributeReference()) {\n        const attribute = result.getAttribute(target.name())\n        if (!attribute) {\n          continue\n        }\n\n        const previousValue = attribute.get()\n        result = result.setAttribute(target.name(), performIncrement(previousValue, this.value))\n        continue\n      }\n\n      throw new Error(`Unable to apply to target ${target.toString()}`)\n    }\n\n    return result\n  }\n}\n","import type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\n\nexport function targetsToIndicies(targets: Expression[], accessor: ImmutableAccessor): number[] {\n  const result: number[] = []\n  targets.forEach((target) => {\n    if (target.isIndexReference()) {\n      result.push(...target.toIndicies(accessor))\n    }\n  })\n  return result.sort()\n}\n","import {min, max} from 'lodash'\nimport type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\nimport {targetsToIndicies} from './util'\n\nexport class InsertPatch {\n  location: string\n  path: string\n  items: unknown[]\n  id: string\n\n  constructor(id: string, location: string, path: string, items: unknown[]) {\n    this.id = id\n    this.location = location\n    this.path = path\n    this.items = items\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    if (accessor.containerType() !== 'array') {\n      throw new Error('Attempt to apply insert patch to non-array value')\n    }\n\n    switch (this.location) {\n      case 'before': {\n        const pos = minIndex(targets, accessor)\n        result = result.insertItemsAt(pos, this.items)\n        break\n      }\n      case 'after': {\n        const pos = maxIndex(targets, accessor)\n        result = result.insertItemsAt(pos + 1, this.items)\n        break\n      }\n      case 'replace': {\n        // TODO: Properly implement ranges in compliance with content lake\n        // This will only properly support single contiguous ranges\n        const indicies = targetsToIndicies(targets, accessor)\n        result = result.unsetIndices(indicies)\n        result = result.insertItemsAt(indicies[0], this.items)\n        break\n      }\n      default: {\n        throw new Error(`Unsupported location atm: ${this.location}`)\n      }\n    }\n    return result\n  }\n}\n\nfunction minIndex(targets: Expression[], accessor: ImmutableAccessor): number {\n  let result = min(targetsToIndicies(targets, accessor)) || 0\n\n  // Ranges may be zero-length and not turn up in indices\n  targets.forEach((target) => {\n    if (target.isRange()) {\n      const {start} = target.expandRange()\n      if (start < result) {\n        result = start\n      }\n    }\n  })\n  return result\n}\n\nfunction maxIndex(targets: Expression[], accessor: ImmutableAccessor): number {\n  let result = max(targetsToIndicies(targets, accessor)) || 0\n\n  // Ranges may be zero-length and not turn up in indices\n  targets.forEach((target) => {\n    if (target.isRange()) {\n      const {end} = target.expandRange()\n      if (end > result) {\n        result = end\n      }\n    }\n  })\n  return result\n}\n","import type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\n\nexport class SetIfMissingPatch {\n  id: string\n  path: string\n  value: unknown\n\n  constructor(id: string, path: string, value: unknown) {\n    this.id = id\n    this.path = path\n    this.value = value\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    targets.forEach((target) => {\n      if (target.isIndexReference()) {\n        // setIfMissing do not apply to arrays, since Content Lake will reject nulls in arrays\n      } else if (target.isAttributeReference()) {\n        // setting a subproperty on a primitive value overwrites it, eg\n        // `{setIfMissing: {'address.street': 'California St'}}` on `{address: 'Fiction St'}` will\n        // result in `{address: {street: 'California St'}}`\n        if (result.containerType() === 'primitive') {\n          result = result.set({[target.name()]: this.value})\n        } else if (!result.hasAttribute(target.name())) {\n          result = accessor.setAttribute(target.name(), this.value)\n        }\n      } else {\n        throw new Error(`Unable to apply to target ${target.toString()}`)\n      }\n    })\n    return result\n  }\n}\n","import type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\nimport {targetsToIndicies} from './util'\n\nexport class UnsetPatch {\n  id: string\n  path: string\n  value: unknown\n\n  constructor(id: string, path: string) {\n    this.id = id\n    this.path = path\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    switch (accessor.containerType()) {\n      case 'array':\n        result = result.unsetIndices(targetsToIndicies(targets, accessor))\n        break\n      case 'object':\n        targets.forEach((target) => {\n          result = result.unsetAttribute(target.name())\n        })\n        break\n      default:\n        throw new Error(\n          'Target value is neither indexable or an object. This error should potentially just be silently ignored?',\n        )\n    }\n    return result\n  }\n}\n","import {applyPatches, parsePatch, type Patch} from '@sanity/diff-match-patch'\nimport {Expression} from '../jsonpath'\nimport {ImmutableAccessor} from './ImmutableAccessor'\n\nfunction applyPatch(patch: Patch[], oldValue: unknown) {\n  // Silently avoid patching if the value type is not string\n  if (typeof oldValue !== 'string') return oldValue\n  const [result] = applyPatches(patch, oldValue, {allowExceedingIndices: true})\n  return result\n}\n\nexport class DiffMatchPatch {\n  path: string\n  dmpPatch: Patch[]\n  id: string\n\n  constructor(id: string, path: string, dmpPatchSrc: string) {\n    this.id = id\n    this.path = path\n    this.dmpPatch = parsePatch(dmpPatchSrc)\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n\n    // The target must be a container type\n    if (result.containerType() === 'primitive') {\n      return result\n    }\n\n    for (const target of targets) {\n      if (target.isIndexReference()) {\n        for (const index of target.toIndicies(accessor)) {\n          // Skip patching unless the index actually currently exists\n          const item = result.getIndex(index)\n          if (!item) {\n            continue\n          }\n\n          const oldValue = item.get()\n          const nextValue = applyPatch(this.dmpPatch, oldValue)\n          result = result.setIndex(index, nextValue)\n        }\n\n        continue\n      }\n\n      if (target.isAttributeReference() && result.hasAttribute(target.name())) {\n        const attribute = result.getAttribute(target.name())\n        if (!attribute) {\n          continue\n        }\n\n        const oldValue = attribute.get()\n        const nextValue = applyPatch(this.dmpPatch, oldValue)\n        result = result.setAttribute(target.name(), nextValue)\n        continue\n      }\n\n      throw new Error(`Unable to apply diffMatchPatch to target ${target.toString()}`)\n    }\n\n    return result\n  }\n}\n","import {SetPatch} from './SetPatch'\nimport {IncPatch} from './IncPatch'\nimport {InsertPatch} from './InsertPatch'\nimport {SetIfMissingPatch} from './SetIfMissingPatch'\nimport {UnsetPatch} from './UnsetPatch'\nimport {DiffMatchPatch} from './DiffMatchPatch'\nimport type {PatchTypes, SingleDocumentPatch} from './types'\n\n// Parses a content lake patch into our own personal patch implementations\nexport function parsePatch(patch: SingleDocumentPatch | SingleDocumentPatch[]): PatchTypes[] {\n  const result: PatchTypes[] = []\n  if (Array.isArray(patch)) {\n    return patch.reduce((r, p) => r.concat(parsePatch(p)), result)\n  }\n\n  const {set, setIfMissing, unset, diffMatchPatch, inc, dec, insert} = patch\n  if (setIfMissing) {\n    Object.keys(setIfMissing).forEach((path) => {\n      result.push(new SetIfMissingPatch(patch.id, path, setIfMissing[path]))\n    })\n  }\n\n  if (set) {\n    Object.keys(set).forEach((path) => {\n      result.push(new SetPatch(patch.id, path, set[path]))\n    })\n  }\n\n  if (unset) {\n    unset.forEach((path) => {\n      result.push(new UnsetPatch(patch.id, path))\n    })\n  }\n\n  if (diffMatchPatch) {\n    Object.keys(diffMatchPatch).forEach((path) => {\n      result.push(new DiffMatchPatch(patch.id, path, diffMatchPatch[path]))\n    })\n  }\n\n  if (inc) {\n    Object.keys(inc).forEach((path) => {\n      result.push(new IncPatch(patch.id, path, inc[path]))\n    })\n  }\n\n  if (dec) {\n    Object.keys(dec).forEach((path) => {\n      result.push(new IncPatch(patch.id, path, -dec[path]))\n    })\n  }\n\n  if (insert) {\n    let location: string\n    let path: string\n    const spec = insert\n    if ('before' in spec) {\n      location = 'before'\n      path = spec.before\n    } else if ('after' in spec) {\n      location = 'after'\n      path = spec.after\n    } else if ('replace' in spec) {\n      location = 'replace'\n      path = spec.replace\n    } else {\n      throw new Error('Invalid insert patch')\n    }\n\n    result.push(new InsertPatch(patch.id, location, path, spec.items))\n  }\n\n  return result\n}\n","import type {Probe} from '../jsonpath/Probe'\n\n/**\n * An immutable probe/writer for plain JS objects that will never mutate\n * the provided _value in place. Each setter returns a new (wrapped) version\n * of the value.\n */\nexport class ImmutableAccessor implements Probe {\n  _value: unknown\n  path: (string | number)[]\n\n  constructor(value: unknown, path?: (string | number)[]) {\n    this._value = value\n    this.path = path || []\n  }\n\n  containerType(): 'array' | 'object' | 'primitive' {\n    if (Array.isArray(this._value)) {\n      return 'array'\n    } else if (this._value !== null && typeof this._value === 'object') {\n      return 'object'\n    }\n    return 'primitive'\n  }\n\n  // Common reader, supported by all containers\n  get(): unknown {\n    return this._value\n  }\n\n  // Array reader\n  length(): number {\n    if (!Array.isArray(this._value)) {\n      throw new Error(\"Won't return length of non-indexable _value\")\n    }\n\n    return this._value.length\n  }\n\n  getIndex(i: number): ImmutableAccessor | false | null {\n    if (!Array.isArray(this._value)) {\n      return false\n    }\n\n    if (i >= this.length()) {\n      return null\n    }\n\n    return new ImmutableAccessor(this._value[i], this.path.concat(i))\n  }\n\n  // Object reader\n  hasAttribute(key: string): boolean {\n    return isRecord(this._value) ? this._value.hasOwnProperty(key) : false\n  }\n\n  attributeKeys(): string[] {\n    return isRecord(this._value) ? Object.keys(this._value) : []\n  }\n\n  getAttribute(key: string): ImmutableAccessor | null {\n    if (!isRecord(this._value)) {\n      throw new Error('getAttribute only applies to plain objects')\n    }\n\n    if (!this.hasAttribute(key)) {\n      return null\n    }\n\n    return new ImmutableAccessor(this._value[key], this.path.concat(key))\n  }\n\n  // Common writer, supported by all containers\n  set(value: unknown): ImmutableAccessor {\n    return value === this._value ? this : new ImmutableAccessor(value, this.path)\n  }\n\n  // array writer interface\n  setIndex(i: number, value: unknown): ImmutableAccessor {\n    if (!Array.isArray(this._value)) {\n      throw new Error('setIndex only applies to arrays')\n    }\n\n    if (Object.is(value, this._value[i])) {\n      return this\n    }\n\n    const nextValue = this._value.slice()\n    nextValue[i] = value\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  setIndexAccessor(i: number, accessor: ImmutableAccessor): ImmutableAccessor {\n    return this.setIndex(i, accessor.get())\n  }\n\n  unsetIndices(indices: number[]): ImmutableAccessor {\n    if (!Array.isArray(this._value)) {\n      throw new Error('unsetIndices only applies to arrays')\n    }\n\n    const length = this._value.length\n    const nextValue = []\n    // Copy every _value _not_ in the indices array over to the newValue\n    for (let i = 0; i < length; i++) {\n      if (indices.indexOf(i) === -1) {\n        nextValue.push(this._value[i])\n      }\n    }\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  insertItemsAt(pos: number, items: unknown[]): ImmutableAccessor {\n    if (!Array.isArray(this._value)) {\n      throw new Error('insertItemsAt only applies to arrays')\n    }\n\n    let nextValue\n    if (this._value.length === 0 && pos === 0) {\n      nextValue = items\n    } else {\n      nextValue = this._value.slice(0, pos).concat(items).concat(this._value.slice(pos))\n    }\n\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  // Object writer interface\n  setAttribute(key: string, value: unknown): ImmutableAccessor {\n    if (!isRecord(this._value)) {\n      throw new Error('Unable to set attribute of non-object container')\n    }\n\n    if (Object.is(value, this._value[key])) {\n      return this\n    }\n\n    const nextValue = Object.assign({}, this._value, {[key]: value})\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  setAttributeAccessor(key: string, accessor: ImmutableAccessor): ImmutableAccessor {\n    return this.setAttribute(key, accessor.get())\n  }\n\n  unsetAttribute(key: string): ImmutableAccessor {\n    if (!isRecord(this._value)) {\n      throw new Error('Unable to unset attribute of non-object container')\n    }\n\n    const nextValue = Object.assign({}, this._value)\n    delete nextValue[key]\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n}\n\nfunction isRecord(value: unknown): value is {[key: string]: unknown} {\n  return value !== null && typeof value === 'object'\n}\n","import type {Doc} from '../document/types'\nimport {Matcher} from '../jsonpath'\nimport {parsePatch} from './parse'\nimport {ImmutableAccessor} from './ImmutableAccessor'\nimport {PatchTypes, SingleDocumentPatch} from './types'\nimport {SetPatch} from './SetPatch'\nimport {SetIfMissingPatch} from './SetIfMissingPatch'\n\nexport interface Patch {\n  id: string\n  path: string\n}\n\nexport class Patcher {\n  patches: PatchTypes[]\n\n  constructor(patch: SingleDocumentPatch | SingleDocumentPatch[]) {\n    this.patches = parsePatch(patch)\n  }\n\n  apply(value: Doc | null): unknown {\n    // Apply just makes a root accessor around the provided\n    // value, then applies the patches. Due to the use of\n    // ImmutableAccessor it is guaranteed to return either the\n    // exact same object it was provided (in the case of no changes),\n    // or a completely new object. It will never mutate the object in place.\n    const accessor = new ImmutableAccessor(value)\n    return this.applyViaAccessor(accessor).get()\n  }\n\n  // If you want to use your own accessor implementation, you can use this method\n  // to invoke the patcher. Since all subsequent accessors for children of this accessor\n  // are obtained through the methods in the accessors, you retain full control of the\n  // implementation throguhgout the application. Have a look in ImmutableAccessor\n  // to see an example of how accessors are implemented.\n  applyViaAccessor(accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    const idAccessor = accessor.getAttribute('_id')\n    if (!idAccessor) {\n      throw new Error('Cannot apply patch to document with no _id')\n    }\n\n    const id = idAccessor.get()\n    for (const patch of this.patches) {\n      if (patch.id !== id) {\n        // Ignore patches that are not targetted at this document\n        continue\n      }\n\n      const matcher = Matcher.fromPath(patch.path).setPayload(patch)\n      result = process(matcher, result)\n    }\n\n    return result\n  }\n}\n\n// Recursively (depth first) follows any leads generated by the matcher, expecting\n// a patch to be the payload. When matchers report a delivery, the\n// apply(targets, accessor) is called on the patch\nfunction process(matcher: Matcher, accessor: ImmutableAccessor) {\n  const isSetPatch =\n    matcher.payload instanceof SetPatch || matcher.payload instanceof SetIfMissingPatch\n\n  let result = accessor\n  // Every time we execute the matcher a new set of leads is generated. Each lead\n  // is a target (being an index, an attribute name or a range) in the form of an\n  // Expression instance. For each lead target there is also a matcher. Our job is to obtain\n  // accessor(s) for each target (there might be more than one, since the targets may\n  // be ranges) and run the provided matcher on those accessors.\n  const {leads, delivery} = matcher.match(accessor)\n  leads.forEach((lead) => {\n    if (lead.target.isIndexReference()) {\n      lead.target.toIndicies().forEach((i) => {\n        const item = result.getIndex(i)\n        if (!item) {\n          throw new Error('Index out of bounds')\n        }\n\n        result = result.setIndexAccessor(i, process(lead.matcher, item))\n      })\n    } else if (lead.target.isAttributeReference()) {\n      // `set`/`setIfMissing` on a primitive value overwrites it\n      if (isSetPatch && result.containerType() === 'primitive') {\n        result = result.set({})\n      }\n\n      let oldValueAccessor = result.getAttribute(lead.target.name())\n\n      // If the patch is a set/setIfMissing patch, we allow deeply setting properties,\n      // creating missing segments as we go.\n      if (!oldValueAccessor && isSetPatch) {\n        result = result.setAttribute(lead.target.name(), {})\n        oldValueAccessor = result.getAttribute(lead.target.name())\n      }\n\n      if (!oldValueAccessor) {\n        // Don't follow lead, no such attribute\n        return\n      }\n\n      const newValueAccessor = process(lead.matcher, oldValueAccessor)\n      if (oldValueAccessor !== newValueAccessor) {\n        result = result.setAttributeAccessor(lead.target.name(), newValueAccessor)\n      }\n    } else {\n      throw new Error(`Unable to handle target ${lead.target.toString()}`)\n    }\n  })\n\n  // Each time we run the matcher, we might also get a delivery. This means that a\n  // term in the jsonpath terminated here and the patch should be applied. The delivery\n  // arrives in the form of an array of targets and a payload (which in this application\n  // is the patch). Conveniently the patches accept an array of targets and an accessor\n  // to do its work, so here we just pass those to the patch and we're done.\n  if (delivery && isPatcher(delivery.payload)) {\n    const patch = delivery.payload\n    result = patch.apply(delivery.targets, result)\n  }\n\n  return result\n}\n\nfunction isPatcher(payload: unknown): payload is PatchTypes {\n  return Boolean(\n    payload &&\n      typeof payload === 'object' &&\n      payload !== null &&\n      'apply' in payload &&\n      typeof (payload as PatchTypes).apply === 'function',\n  )\n}\n","import {uuid} from '@sanity/uuid'\n\n/**\n * Locally unique id's. We use this to generate transaction ids, and they don't have to be\n * cryptographically unique, as the worst that can happen is that they get rejected because\n * of a collision, and then we should just retry with a new id.\n */\nexport const luid = uuid\n","import debugIt from 'debug'\n\nexport const debug = debugIt('mutator-document')\n","import {Patcher} from '../patch'\nimport {luid} from './luid'\nimport {debug} from './debug'\nimport type {Doc, Mut} from './types'\n\n/**\n * Parameters attached to the mutation\n *\n * @internal\n */\nexport interface MutationParams {\n  transactionId?: string\n  transition?: string\n  identity?: string\n  previousRev?: string\n  resultRev?: string\n  mutations: Mut[]\n  timestamp?: string\n  effects?: {apply: unknown; revert: unknown}\n}\n\n/**\n * A mutation describing a number of operations on a single document.\n * This should be considered an immutable structure. Mutations are compiled\n * on first application, and any changes in properties will not effectively\n * change its behavior after that.\n *\n * @internal\n */\nexport class Mutation {\n  params: MutationParams\n\n  compiled?: (doc: Doc | null) => Doc | null\n\n  _appliesToMissingDocument: boolean | undefined\n\n  constructor(options: MutationParams) {\n    this.params = options\n  }\n\n  get transactionId(): string | undefined {\n    return this.params.transactionId\n  }\n\n  get transition(): string | undefined {\n    return this.params.transition\n  }\n\n  get identity(): string | undefined {\n    return this.params.identity\n  }\n\n  get previousRev(): string | undefined {\n    return this.params.previousRev\n  }\n\n  get resultRev(): string | undefined {\n    return this.params.resultRev\n  }\n\n  get mutations(): Mut[] {\n    return this.params.mutations\n  }\n\n  get timestamp(): Date | undefined {\n    if (typeof this.params.timestamp === 'string') {\n      return new Date(this.params.timestamp)\n    }\n\n    return undefined\n  }\n\n  get effects():\n    | {\n        apply: unknown\n        revert: unknown\n      }\n    | undefined {\n    return this.params.effects\n  }\n\n  assignRandomTransactionId(): void {\n    this.params.transactionId = luid()\n    this.params.resultRev = this.params.transactionId\n  }\n\n  appliesToMissingDocument(): boolean {\n    if (typeof this._appliesToMissingDocument !== 'undefined') {\n      return this._appliesToMissingDocument\n    }\n\n    // Only mutations starting with a create operation apply to documents that do not exist ...\n    const firstMut = this.mutations[0]\n    if (firstMut) {\n      this._appliesToMissingDocument = Boolean(\n        firstMut.create || firstMut.createIfNotExists || firstMut.createOrReplace,\n      )\n    } else {\n      this._appliesToMissingDocument = true\n    }\n\n    return this._appliesToMissingDocument\n  }\n\n  // Compiles all mutations into a handy function\n  compile(): void {\n    const operations: ((doc: Doc | null) => Doc | null)[] = []\n\n    this.mutations.forEach((mutation) => {\n      if (mutation.create) {\n        // TODO: Fail entire patch if document did exist\n        const create = mutation.create || {}\n        operations.push((doc): Doc => {\n          if (doc) {\n            return doc\n          }\n\n          return Object.assign(create as Doc, {\n            _createdAt: create._createdAt || this.params.timestamp,\n          })\n        })\n        return\n      }\n\n      if (mutation.createIfNotExists) {\n        const createIfNotExists = mutation.createIfNotExists || {}\n        operations.push((doc) =>\n          doc === null\n            ? Object.assign(createIfNotExists, {\n                _createdAt: createIfNotExists._createdAt || this.params.timestamp,\n              })\n            : doc,\n        )\n        return\n      }\n\n      if (mutation.createOrReplace) {\n        const createOrReplace = mutation.createOrReplace || {}\n        operations.push(() =>\n          Object.assign(createOrReplace, {\n            _createdAt: createOrReplace._createdAt || this.params.timestamp,\n          }),\n        )\n        return\n      }\n\n      if (mutation.delete) {\n        operations.push(() => null)\n        return\n      }\n\n      if (mutation.patch) {\n        if ('query' in mutation.patch) {\n          // @todo Warn/throw? Investigate if this can ever happen\n          return\n        }\n\n        const patch = new Patcher(mutation.patch)\n        operations.push((doc) => patch.apply(doc) as Doc | null)\n        return\n      }\n\n      throw new Error(`Unsupported mutation ${JSON.stringify(mutation, null, 2)}`)\n    })\n\n    // Assign `_updatedAt` to the timestamp of the mutation if set\n    if (typeof this.params.timestamp === 'string') {\n      operations.push((doc) => {\n        return doc ? Object.assign(doc, {_updatedAt: this.params.timestamp}) : null\n      })\n    }\n\n    const prevRev = this.previousRev\n    const rev = this.resultRev || this.transactionId\n    this.compiled = (doc: Doc | null) => {\n      if (prevRev && doc && prevRev !== doc._rev) {\n        throw new Error(\n          `Previous revision for this mutation was ${prevRev}, but the document revision is ${doc._rev}`,\n        )\n      }\n\n      let result: Doc | null = doc\n      for (const operation of operations) {\n        result = operation(result)\n      }\n\n      // Should update _rev?\n      if (result && rev) {\n        // Ensure that result is a unique object, even if the operation was a no-op\n        if (result === doc) {\n          result = Object.assign({}, doc)\n        }\n        result._rev = rev\n      }\n\n      return result\n    }\n  }\n\n  apply(document: Doc | null): Doc | null {\n    debug('Applying mutation %O to document %O', this.mutations, document)\n    if (!this.compiled) {\n      this.compile()\n    }\n\n    const result = this.compiled!(document)\n    debug('  => %O', result)\n    return result\n  }\n\n  static applyAll(document: Doc | null, mutations: Mutation[]): Doc | null {\n    return mutations.reduce((doc, mutation) => mutation.apply(doc), document)\n  }\n\n  // Given a number of yet-to-be-committed mutation objects, collects them into one big mutation\n  // any metadata like transactionId is ignored and must be submitted by the client. It is assumed\n  // that all mutations are on the same document.\n  // TOOO: Optimize mutations, eliminating mutations that overwrite themselves!\n  static squash(document: Doc | null, mutations: Mutation[]): Mutation {\n    const squashed = mutations.reduce(\n      (result, mutation) => result.concat(...mutation.mutations),\n      [] as Mut[],\n    )\n    return new Mutation({mutations: squashed})\n  }\n}\n","// TODO: When we have timestamps on mutation notifications, we can reject incoming mutations that are older\n// than the document we are seeing.\n\nimport {isEqual} from 'lodash'\nimport {Mutation} from './Mutation'\nimport {debug} from './debug'\nimport type {Doc} from './types'\n\n/**\n * @internal\n */\nexport interface SubmissionResponder {\n  success: () => void\n  failure: () => void\n}\n\n/**\n * Models a document as it is changed by our own local patches and remote patches coming in from\n * the server. Consolidates incoming patches with our own submitted patches and maintains two\n * versions of the document. EDGE is the optimistic document that the user sees that will always\n * immediately reflect whatever she is doing to it, and HEAD which is the confirmed version of the\n * document consistent with the mutations we have received from the server. As long as nothing out of\n * the ordinary happens, we can track all changes by hooking into the onMutation callback, but we\n * must also respect onRebase events that fire when we have to backtrack because one of our optimistically\n * applied patches were rejected, or some bastard was able to slip a mutation in between ours own.\n *\n * @internal\n */\nexport class Document {\n  /**\n   * Incoming patches from the server waiting to be applied to HEAD\n   */\n  incoming: Mutation[] = []\n\n  /**\n   * Patches we know has been subitted to the server, but has not been seen yet in the return channel\n   * so we can't be sure about the ordering yet (someone else might have slipped something between them)\n   */\n  submitted: Mutation[] = []\n\n  /**\n   * Pending mutations\n   */\n  pending: Mutation[] = []\n\n  /**\n   * Our model of the document according to the incoming patches from the server\n   */\n  HEAD: Doc | null\n\n  /**\n   * Our optimistic model of what the document will probably look like as soon as all our patches\n   * have been processed. Updated every time we stage a new mutation, but also might revert back\n   * to previous states if our mutations fail, or could change if unexpected mutations arrive\n   * between our own. The `onRebase` callback will be called when EDGE changes in this manner.\n   */\n  EDGE: Doc | null\n\n  /**\n   * Called with the EDGE document when that document changes for a reason other than us staging\n   * a new patch or receiving a mutation from the server while our EDGE is in sync with HEAD:\n   * I.e. when EDGE changes because the order of mutations has changed in relation to our\n   * optimistic predictions.\n   */\n  onRebase?: (edge: Doc | null, incomingMutations: Mutation[], pendingMutations: Mutation[]) => void\n\n  /**\n   * Called when we receive a patch in the normal order of things, but the mutation is not ours\n   */\n  onMutation?: (msg: {mutation: Mutation; document: Doc | null; remote: boolean}) => void\n\n  /**\n   * Called when consistency state changes with the boolean value of the current consistency state\n   */\n  onConsistencyChanged?: (isConsistent: boolean) => void\n\n  /**\n   * Called whenever a new incoming mutation comes in. These are always ordered correctly.\n   */\n  onRemoteMutation?: (mut: Mutation) => void\n\n  /**\n   * We are consistent when there are no unresolved mutations of our own, and no un-applicable\n   * incoming mutations. When this has been going on for too long, and there has been a while\n   * since we staged a new mutation, it is time to reset your state.\n   */\n  inconsistentAt: Date | null = null\n\n  /**\n   * The last time we staged a patch of our own. If we have been inconsistent for a while, but it\n   * hasn't been long since we staged a new mutation, the reason is probably just because the user\n   * is typing or something.\n   *\n   * Should be used as a guard against resetting state for inconsistency reasons.\n   */\n  lastStagedAt: Date | null = null\n\n  constructor(doc: Doc | null) {\n    this.reset(doc)\n    this.HEAD = doc\n    this.EDGE = doc\n  }\n\n  // Reset the state of the Document, used to recover from unsavory states by reloading the document\n  reset(doc: Doc | null): void {\n    this.incoming = []\n    this.submitted = []\n    this.pending = []\n    this.inconsistentAt = null\n    this.HEAD = doc\n    this.EDGE = doc\n    this.considerIncoming()\n    this.updateConsistencyFlag()\n  }\n\n  // Call when a mutation arrives from Sanity\n  arrive(mutation: Mutation): void {\n    this.incoming.push(mutation)\n    this.considerIncoming()\n    this.updateConsistencyFlag()\n  }\n\n  // Call to signal that we are submitting a mutation. Returns a callback object with a\n  // success and failure handler that must be called according to the outcome of our\n  // submission.\n  stage(mutation: Mutation, silent?: boolean): SubmissionResponder {\n    if (!mutation.transactionId) {\n      throw new Error('Mutations _must_ have transactionId when submitted')\n    }\n    this.lastStagedAt = new Date()\n\n    debug('Staging mutation %s (pushed to pending)', mutation.transactionId)\n    this.pending.push(mutation)\n    this.EDGE = mutation.apply(this.EDGE)\n\n    if (this.onMutation && !silent) {\n      this.onMutation({\n        mutation,\n        document: this.EDGE,\n        remote: false,\n      })\n    }\n\n    const txnId = mutation.transactionId\n\n    this.updateConsistencyFlag()\n\n    return {\n      success: () => {\n        this.pendingSuccessfullySubmitted(txnId)\n        this.updateConsistencyFlag()\n      },\n      failure: () => {\n        this.pendingFailed(txnId)\n        this.updateConsistencyFlag()\n      },\n    }\n  }\n\n  // Call to check if everything is nice and quiet and there are no unresolved mutations.\n  // Means this model thinks both HEAD and EDGE is up to date with what the server sees.\n  isConsistent(): boolean {\n    return !this.inconsistentAt\n  }\n\n  // Private\n\n  // Attempts to apply any resolvable incoming patches to HEAD. Will keep patching as long as there\n  // are applicable patches to be applied\n  considerIncoming(): void {\n    let mustRebase = false\n    let nextMut: Mutation | undefined\n    const rebaseMutations: Mutation[] = []\n\n    // Filter mutations that are older than the document\n    if (this.HEAD && this.HEAD._updatedAt) {\n      const updatedAt = new Date(this.HEAD._updatedAt)\n      if (this.incoming.find((mut) => mut.timestamp && mut.timestamp < updatedAt)) {\n        this.incoming = this.incoming.filter((mut) => mut.timestamp && mut.timestamp < updatedAt)\n      }\n    }\n\n    // Keep applying mutations as long as any apply\n    let protect = 0\n    do {\n      // Find next mutation that can be applied to HEAD (if any)\n      if (this.HEAD) {\n        const HEAD = this.HEAD\n        nextMut = HEAD._rev ? this.incoming.find((mut) => mut.previousRev === HEAD._rev) : undefined\n      } else {\n        // When HEAD is null, that means the document is currently deleted. Only mutations that start with a create\n        // operation will be considered.\n        nextMut = this.incoming.find((mut) => mut.appliesToMissingDocument())\n      }\n\n      if (nextMut) {\n        const applied = this.applyIncoming(nextMut)\n        mustRebase = mustRebase || applied\n        if (mustRebase) {\n          rebaseMutations.push(nextMut)\n        }\n\n        if (protect++ > 10) {\n          throw new Error(\n            `Mutator stuck flushing incoming mutations. Probably stuck here: ${JSON.stringify(\n              nextMut,\n            )}`,\n          )\n        }\n      }\n    } while (nextMut)\n\n    if (this.incoming.length > 0 && debug.enabled) {\n      debug(\n        'Unable to apply mutations %s',\n        this.incoming.map((mut) => mut.transactionId).join(', '),\n      )\n    }\n\n    if (mustRebase) {\n      this.rebase(rebaseMutations)\n    }\n  }\n\n  // check current consistency state, update flag and invoke callback if needed\n  updateConsistencyFlag(): void {\n    const wasConsistent = this.isConsistent()\n    const isConsistent =\n      this.pending.length === 0 && this.submitted.length === 0 && this.incoming.length === 0\n    // Update the consistency state, taking care not to update the timestamp if we were inconsistent and still are\n    if (isConsistent) {\n      this.inconsistentAt = null\n    } else if (!this.inconsistentAt) {\n      this.inconsistentAt = new Date()\n    }\n    // Handle onConsistencyChanged callback\n    if (wasConsistent != isConsistent && this.onConsistencyChanged) {\n      if (isConsistent) {\n        debug('Buffered document is inconsistent')\n      } else {\n        debug('Buffered document is consistent')\n      }\n      this.onConsistencyChanged(isConsistent)\n    }\n  }\n\n  // apply an incoming patch that has been prequalified as the next in line for this document\n  applyIncoming(mut: Mutation | undefined): boolean {\n    if (!mut) {\n      return false\n    }\n\n    if (!mut.transactionId) {\n      throw new Error('Received incoming mutation without a transaction ID')\n    }\n\n    debug(\n      'Applying mutation %s -> %s to rev %s',\n      mut.previousRev,\n      mut.resultRev,\n      this.HEAD && this.HEAD._rev,\n    )\n\n    this.HEAD = mut.apply(this.HEAD)\n\n    if (this.onRemoteMutation) {\n      this.onRemoteMutation(mut)\n    }\n\n    // Eliminate from incoming set\n    this.incoming = this.incoming.filter((m) => m.transactionId !== mut.transactionId)\n\n    if (this.hasUnresolvedMutations()) {\n      const needRebase = this.consumeUnresolved(mut.transactionId)\n      if (debug.enabled) {\n        debug(\n          `Incoming mutation ${mut.transactionId} appeared while there were pending or submitted local mutations`,\n        )\n        debug(`Submitted txnIds: ${this.submitted.map((m) => m.transactionId).join(', ')}`)\n        debug(`Pending txnIds: ${this.pending.map((m) => m.transactionId).join(', ')}`)\n        debug(`needRebase === %s`, needRebase)\n      }\n      return needRebase\n    }\n    debug(\n      `Remote mutation %s arrived w/o any pending or submitted local mutations`,\n      mut.transactionId,\n    )\n    this.EDGE = this.HEAD\n    if (this.onMutation) {\n      this.onMutation({\n        mutation: mut,\n        document: this.EDGE,\n        remote: true,\n      })\n    }\n    return false\n  }\n\n  /**\n   * Returns true if there are unresolved mutations between HEAD and EDGE, meaning we have\n   * mutations that are still waiting to be either submitted, or to be confirmed by the server.\n   *\n   * @returns true if there are unresolved mutations between HEAD and EDGE, false otherwise\n   */\n  hasUnresolvedMutations(): boolean {\n    return this.submitted.length > 0 || this.pending.length > 0\n  }\n\n  /**\n   * When an incoming mutation is applied to HEAD, this is called to remove the mutation from\n   * the unresolved state. If the newly applied patch is the next upcoming unresolved mutation,\n   * no rebase is needed, but we might have the wrong idea about the ordering of mutations, so in\n   * that case we are given the flag `needRebase` to tell us that this mutation arrived out of\n   * order in terms of our optimistic version, so a rebase is needed.\n   *\n   * @param txnId - Transaction ID of the remote mutation\n   * @returns true if rebase is needed, false otherwise\n   */\n  consumeUnresolved(txnId: string): boolean {\n    // If we have nothing queued up, we are in sync and can apply patch with no\n    // rebasing\n    if (this.submitted.length === 0 && this.pending.length === 0) {\n      return false\n    }\n\n    // If we can consume the directly upcoming mutation, we won't have to rebase\n    if (this.submitted.length !== 0) {\n      if (this.submitted[0].transactionId === txnId) {\n        debug(\n          `Remote mutation %s matches upcoming submitted mutation, consumed from 'submitted' buffer`,\n          txnId,\n        )\n        this.submitted.shift()\n        return false\n      }\n    } else if (this.pending.length > 0 && this.pending[0].transactionId === txnId) {\n      // There are no submitted, but some are pending so let's check the upcoming pending\n      debug(\n        `Remote mutation %s matches upcoming pending mutation, consumed from 'pending' buffer`,\n        txnId,\n      )\n      this.pending.shift()\n      return false\n    }\n\n    debug(\n      'The mutation was not the upcoming mutation, scrubbing. Pending: %d, Submitted: %d',\n      this.pending.length,\n      this.submitted.length,\n    )\n\n    // The mutation was not the upcoming mutation, so we'll have to check everything to\n    // see if we have an out of order situation\n    this.submitted = this.submitted.filter((mut) => mut.transactionId !== txnId)\n    this.pending = this.pending.filter((mut) => mut.transactionId !== txnId)\n    debug(`After scrubbing: Pending: %d, Submitted: %d`, this.pending.length, this.submitted.length)\n\n    // Whether we had it or not we have either a reordering, or an unexpected mutation\n    // so must rebase\n    return true\n  }\n\n  pendingSuccessfullySubmitted(pendingTxnId: string): void {\n    if (this.pending.length === 0) {\n      // If there are no pending, it has probably arrived allready\n      return\n    }\n\n    const first = this.pending[0]\n    if (first.transactionId === pendingTxnId) {\n      // Nice, the pending transaction arrived in order\n      this.pending.shift()\n      this.submitted.push(first)\n      return\n    }\n\n    // Oh, no. Submitted out of order.\n    let justSubmitted: Mutation | undefined\n    const stillPending: Mutation[] = []\n    this.pending.forEach((mutation) => {\n      if (mutation.transactionId === pendingTxnId) {\n        justSubmitted = mutation\n        return\n      }\n\n      stillPending.push(mutation)\n    })\n\n    // Not found? Hopefully it has already arrived. Might have been forgotten by now\n    if (justSubmitted) {\n      this.submitted.push(justSubmitted)\n    }\n\n    this.pending = stillPending\n\n    // Must rebase since mutation order has changed\n    this.rebase([])\n  }\n\n  pendingFailed(pendingTxnId: string): void {\n    this.pending = this.pending.filter((mutation) => mutation.transactionId !== pendingTxnId)\n\n    // Rebase to revert document to what it looked like before the failed mutation\n    this.rebase([])\n  }\n\n  rebase(incomingMutations: Mutation[]): void {\n    const oldEdge = this.EDGE\n    this.EDGE = Mutation.applyAll(this.HEAD, this.submitted.concat(this.pending))\n\n    // Copy over rev, since we don't care if it changed, we only care about the content\n    if (oldEdge !== null && this.EDGE !== null) {\n      oldEdge._rev = this.EDGE._rev\n    }\n\n    const changed = !isEqual(this.EDGE, oldEdge)\n    if (changed && this.onRebase) {\n      this.onRebase(this.EDGE, incomingMutations, this.pending)\n    }\n  }\n}\n","import {makePatches, stringifyPatches} from '@sanity/diff-match-patch'\nimport {extractWithPath} from '../jsonpath/extractWithPath'\nimport {arrayToJSONMatchPath} from '../jsonpath/arrayToJSONMatchPath'\nimport {Mutation} from './Mutation'\nimport {debug} from './debug'\nimport type {Doc, Mut} from './types'\n\n/**\n * Implements a buffer for mutations that incrementally optimises the mutations by\n * eliminating set-operations that overwrite earlier set-operations, and rewrite\n * set-operations that change strings into other strings into diffMatchPatch operations.\n *\n * @internal\n */\nexport class SquashingBuffer {\n  /**\n   * The document forming the basis of this squash\n   */\n  BASIS: Doc | null\n\n  /**\n   * The document after the out-Mutation has been applied, but before the staged\n   * operations are committed.\n   */\n  PRESTAGE: Doc | null\n\n  /**\n   * setOperations contain the latest set operation by path. If the set-operations are\n   * updating strings to new strings, they are rewritten as diffMatchPatch operations,\n   * any new set operations on the same paths overwrites any older set operations.\n   * Only set-operations assigning plain values to plain values gets optimized like this.\n   */\n  setOperations: Record<string, Mut | undefined>\n\n  /**\n   * `documentPresent` is true whenever we know that the document must be present due\n   * to preceeding mutations. `false` implies that it may or may not already exist.\n   */\n  documentPresent: boolean\n\n  /**\n   * The operations in the out-Mutation are not able to be optimized any further\n   */\n  out: Mut[] = []\n\n  /**\n   * Staged mutation operations\n   */\n  staged: Mut[]\n\n  constructor(doc: Doc | null) {\n    if (doc) {\n      debug('Reset mutation buffer to rev %s', doc._rev)\n    } else {\n      debug('Reset mutation buffer state to document being deleted')\n    }\n\n    this.staged = []\n    this.setOperations = {}\n    this.documentPresent = false\n\n    this.BASIS = doc\n    this.PRESTAGE = doc\n  }\n\n  add(mut: Mutation): void {\n    mut.mutations.forEach((op) => this.addOperation(op))\n  }\n\n  hasChanges(): boolean {\n    return this.out.length > 0 || Object.keys(this.setOperations).length > 0\n  }\n\n  /**\n   * Extracts the mutations in this buffer.\n   * After this is done, the buffer lifecycle is over and the client should\n   * create an new one with the new, updated BASIS.\n   *\n   * @param txnId - Transaction ID\n   * @returns A `Mutation` instance if we had outgoing mutations pending, null otherwise\n   */\n  purge(txnId?: string): Mutation | null {\n    this.stashStagedOperations()\n    let result = null\n    if (this.out.length > 0) {\n      debug('Purged mutation buffer')\n      result = new Mutation({\n        mutations: this.out,\n        resultRev: txnId,\n        transactionId: txnId,\n      })\n    }\n    this.out = []\n    this.documentPresent = false\n    return result\n  }\n\n  addOperation(op: Mut): void {\n    // Is this a set patch, and only a set patch, and does it apply to the document at hand?\n    if (\n      op.patch &&\n      op.patch.set &&\n      'id' in op.patch &&\n      op.patch.id === this.PRESTAGE?._id &&\n      Object.keys(op.patch).length === 2 // `id` + `set`\n    ) {\n      const setPatch = op.patch.set\n      const unoptimizable: Record<string, unknown> = {}\n      // Apply all optimisable keys in the patch\n      for (const path of Object.keys(setPatch)) {\n        if (setPatch.hasOwnProperty(path)) {\n          if (!this.optimiseSetOperation(path, setPatch[path])) {\n            // If not optimisable, add to unoptimizable set\n            unoptimizable[path] = setPatch[path]\n          }\n        }\n      }\n\n      // If any weren't optimisable, add them to an unoptimised set-operation, then\n      // stash everything.\n      if (Object.keys(unoptimizable).length > 0) {\n        debug('Unoptimizable set-operation detected, purging optimization buffer')\n        this.staged.push({patch: {id: this.PRESTAGE._id, set: unoptimizable}})\n        this.stashStagedOperations()\n      }\n\n      return\n    }\n\n    // Is this a createIfNotExists for our document?\n    if (op.createIfNotExists && this.PRESTAGE && op.createIfNotExists._id === this.PRESTAGE._id) {\n      if (!this.documentPresent) {\n        // If we don't know that it's present we'll have to stage and stash.\n        this.staged.push(op)\n        this.documentPresent = true\n        this.stashStagedOperations()\n      }\n\n      // Otherwise we can fully ignore it.\n      return\n    }\n\n    debug('Unoptimizable mutation detected, purging optimization buffer')\n    // console.log(\"Unoptimizable operation, stashing\", JSON.stringify(op))\n    // Un-optimisable operations causes everything to be stashed\n    this.staged.push(op)\n    this.stashStagedOperations()\n  }\n\n  /**\n   * Attempt to perform one single set operation in an optimised manner, return value\n   * reflects whether or not the operation could be performed.\n\n   * @param path - The JSONPath to the set operation in question\n   * @param nextValue - The value to be set\n   * @returns True of optimized, false otherwise\n   */\n  optimiseSetOperation(path: string, nextValue: unknown): boolean {\n    // console.log('optimiseSetOperation', path, nextValue)\n    // If target value is not a plain value, unable to optimise\n    if (typeof nextValue === 'object') {\n      // console.log(\"Not optimisable because next value is object\")\n      return false\n    }\n\n    // Check the source values, if there is more than one value being assigned,\n    // we won't optimise\n    const matches = extractWithPath(path, this.PRESTAGE)\n    // If we are not overwriting exactly one key, this cannot be optimised, so we bail\n    if (matches.length !== 1) {\n      // console.log('Not optimisable because match count is != 1', JSON.stringify(matches))\n      return false\n    }\n\n    // Okay, we are assigning exactly one value to exactly one existing slot, so we might optimise\n    const match = matches[0]\n    // If the value of the match is an array or object, we cannot safely optimise this since the meaning\n    // of pre-existing operations might change (in theory, at least), so we bail\n    if (typeof match.value === 'object') {\n      // console.log(\"Not optimisable because old value is object\")\n      return false\n    }\n\n    if (!this.PRESTAGE) {\n      // Shouldn't happen, but makes typescript happy\n      return false\n    }\n\n    // If the new and old value are the equal, we optimise this operation by discarding it\n    // Now, let's build the operation\n    let op: Mut | null = null\n    if (match.value === nextValue) {\n      // If new and old values are equal, we optimise this by deleting the operation\n      // console.log(\"Omitting operation\")\n      op = null\n    } else if (typeof match.value === 'string' && typeof nextValue === 'string') {\n      // console.log(\"Rewriting to dmp\")\n      // We are updating a string to another string, so we are making a diffMatchPatch\n      try {\n        const patch = stringifyPatches(makePatches(match.value, nextValue))\n        op = {patch: {id: this.PRESTAGE._id, diffMatchPatch: {[path]: patch}}}\n      } catch {\n        // patch_make failed due to unicode issue https://github.com/google/diff-match-patch/issues/59\n        return false\n      }\n    } else {\n      // console.log(\"Not able to rewrite to dmp, making normal set\")\n      // We are changing the type of the value, so must make a normal set-operation\n      op = {patch: {id: this.PRESTAGE._id, set: {[path]: nextValue}}}\n    }\n\n    // Let's make a plain, concrete path from the array-path. We use this to keep only the latest set\n    // operation touching this path in the buffer.\n    const canonicalPath = arrayToJSONMatchPath(match.path)\n\n    // Store this operation, overwriting any previous operations touching this same path\n    if (op) {\n      this.setOperations[canonicalPath] = op\n    } else {\n      delete this.setOperations[canonicalPath]\n    }\n\n    // Signal that we succeeded in optimizing this patch\n    return true\n  }\n\n  stashStagedOperations(): void {\n    // Short circuit if there are no staged operations\n    const nextOps: Mut[] = []\n\n    // Extract the existing outgoing operations if any\n    Object.keys(this.setOperations).forEach((key) => {\n      const op = this.setOperations[key]\n      if (op) {\n        nextOps.push(op)\n      }\n    })\n\n    nextOps.push(...this.staged)\n    if (nextOps.length > 0) {\n      this.PRESTAGE = new Mutation({mutations: nextOps}).apply(this.PRESTAGE) as Doc\n      this.staged = []\n      this.setOperations = {}\n    }\n\n    this.out.push(...nextOps)\n  }\n\n  /**\n   * Rebases given the new base-document\n   *\n   * @param newBasis - New base document to rebase on\n   * @returns New \"edge\" document with buffered changes integrated\n   */\n  rebase(newBasis: Doc | null): Doc | null {\n    this.stashStagedOperations()\n\n    if (newBasis === null) {\n      // If document was just deleted, we must throw out local changes\n      this.out = []\n      this.BASIS = newBasis\n      this.PRESTAGE = newBasis\n      this.documentPresent = false\n    } else {\n      this.BASIS = newBasis\n\n      // @todo was this supposed to be `this.out.length > 0`?\n      // surely this is always `true`?\n      if (this.out) {\n        this.PRESTAGE = new Mutation({mutations: this.out}).apply(this.BASIS) as Doc\n      } else {\n        this.PRESTAGE = this.BASIS\n      }\n    }\n\n    return this.PRESTAGE\n  }\n}\n","import {isEqual} from 'lodash'\nimport {Document} from './Document'\nimport {Mutation} from './Mutation'\nimport {SquashingBuffer} from './SquashingBuffer'\nimport {debug} from './debug'\nimport type {Doc, Mut} from './types'\n\nconst ONE_MINUTE = 1000 * 60\n\n/**\n * @internal\n */\nexport interface CommitHandlerMessage {\n  mutation: Mutation\n  success: () => void\n  failure: () => void\n  cancel: (error: Error) => void\n}\n\n/**\n * A wrapper for Document that allows the client to gather mutations on the\n * client side and commit them when it wants to.\n */\nclass Commit {\n  mutations: Mutation[]\n  tries: number\n  resolve: () => void\n  reject: (error: Error) => void\n\n  constructor(\n    mutations: Mutation[],\n    {resolve, reject}: {resolve: () => void; reject: (error: Error) => void},\n  ) {\n    this.mutations = mutations\n    this.tries = 0\n    this.resolve = resolve\n    this.reject = reject\n  }\n\n  apply(doc: Doc | null): Doc | null {\n    return Mutation.applyAll(doc, this.mutations)\n  }\n\n  squash(doc: Doc | null) {\n    const result = Mutation.squash(doc, this.mutations)\n    result.assignRandomTransactionId()\n    return result\n  }\n}\n\nconst mutReducerFn = (acc: Mut[], mut: Mutation): Mut[] => acc.concat(mut.mutations)\n\n/**\n * @internal\n */\nexport class BufferedDocument {\n  private mutations: Mutation[]\n\n  /**\n   * The Document we are wrapping\n   */\n  document: Document\n\n  /**\n   * The Document with local changes applied\n   */\n  LOCAL: Doc | null\n\n  /**\n   * Commits that are waiting to be delivered to the server\n   */\n  private commits: Commit[]\n\n  /**\n   * Local mutations that are not scheduled to be committed yet\n   */\n  buffer: SquashingBuffer\n\n  /**\n   * Assignable event handler for when the buffered document applies a mutation\n   */\n  onMutation?: (message: {mutation: Mutation; document: Doc | null; remote: boolean}) => void\n\n  /**\n   * Assignable event handler for when a remote mutation happened\n   */\n  onRemoteMutation?: Document['onRemoteMutation']\n\n  /**\n   * Assignable event handler for when the buffered document rebased\n   */\n  onRebase?: (localDoc: Doc | null, remoteMutations: Mut[], localMutations: Mut[]) => void\n\n  /**\n   * Assignable event handler for when the document is deleted\n   */\n  onDelete?: (doc: Doc | null) => void\n\n  /**\n   * Assignable event handler for when the state of consistency changed\n   */\n  onConsistencyChanged?: (isConsistent: boolean) => void\n\n  /**\n   * Assignable event handler for when the buffered document should commit changes\n   */\n  commitHandler?: (msg: CommitHandlerMessage) => void\n\n  /**\n   * Whether or not we are currently commiting\n   */\n  committerRunning = false\n\n  constructor(doc: Doc | null) {\n    this.buffer = new SquashingBuffer(doc)\n    this.document = new Document(doc)\n    this.document.onMutation = (msg) => this.handleDocMutation(msg)\n    this.document.onRemoteMutation = (mut) => this.onRemoteMutation && this.onRemoteMutation(mut)\n    this.document.onRebase = (edge, remoteMutations, localMutations) =>\n      this.handleDocRebase(edge, remoteMutations, localMutations)\n    this.document.onConsistencyChanged = (msg) => this.handleDocConsistencyChanged(msg)\n    this.LOCAL = doc\n    this.mutations = []\n    this.commits = []\n  }\n\n  // Used to reset the state of the local document model. If the model has been inconsistent\n  // for too long, it has probably missed a notification, and should reload the document from the server\n  reset(doc: Doc | null): void {\n    if (doc) {\n      debug('Document state reset to revision %s', doc._rev)\n    } else {\n      debug('Document state reset to being deleted')\n    }\n    this.document.reset(doc)\n    this.rebase([], [])\n    this.handleDocConsistencyChanged(this.document.isConsistent())\n  }\n\n  // Add a change to the buffer\n  add(mutation: Mutation): void {\n    if (this.onConsistencyChanged) {\n      this.onConsistencyChanged(false)\n    }\n    debug('Staged local mutation')\n    this.buffer.add(mutation)\n    const oldLocal = this.LOCAL\n    this.LOCAL = mutation.apply(this.LOCAL)\n    if (this.onMutation && oldLocal !== this.LOCAL) {\n      debug('onMutation fired')\n      this.onMutation({\n        mutation,\n        document: this.LOCAL,\n        remote: false,\n      })\n      if (this.LOCAL === null && this.onDelete) {\n        this.onDelete(this.LOCAL)\n      }\n    }\n  }\n\n  // Call when a mutation arrives from Sanity\n  arrive(mutation: Mutation): void {\n    debug('Remote mutation arrived %s -> %s', mutation.previousRev, mutation.resultRev)\n    if (mutation.previousRev === mutation.resultRev) {\n      throw new Error(\n        `Mutation ${mutation.transactionId} has previousRev === resultRev (${mutation.previousRev})`,\n      )\n    }\n    return this.document.arrive(mutation)\n  }\n\n  // Submit all mutations in the buffer to be committed\n  commit(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // Anything to commit?\n      if (!this.buffer.hasChanges()) {\n        resolve()\n        return\n      }\n      debug('Committing local changes')\n      // Collect current staged mutations into a commit and ...\n      const pendingMutations = this.buffer.purge()\n      this.commits.push(new Commit(pendingMutations ? [pendingMutations] : [], {resolve, reject}))\n      // ... clear the table for the next commit.\n      this.buffer = new SquashingBuffer(this.LOCAL)\n      this.performCommits()\n    })\n  }\n\n  // Starts the committer that will try to committ all staged commits to the database\n  // by calling the commitHandler. Will keep running until all commits are successfully\n  // committed.\n  performCommits(): void {\n    if (!this.commitHandler) {\n      throw new Error('No commitHandler configured for this BufferedDocument')\n    }\n    if (this.committerRunning) {\n      // We can have only one committer at any given time\n      return\n    }\n    this._cycleCommitter()\n  }\n\n  // TODO: Error handling, right now retries after every error\n  _cycleCommitter(): void {\n    const commit = this.commits.shift()\n    if (!commit) {\n      this.committerRunning = false\n      return\n    }\n\n    this.committerRunning = true\n    const squashed = commit.squash(this.LOCAL)\n    const docResponder = this.document.stage(squashed, true)\n\n    const responder = {\n      success: () => {\n        debug('Commit succeeded')\n        docResponder.success()\n        commit.resolve()\n        // Keep running the committer until no more commits\n        this._cycleCommitter()\n      },\n\n      failure: () => {\n        debug('Commit failed')\n        // Re stage commit\n        commit.tries += 1\n        if (this.LOCAL !== null) {\n          // Only schedule this commit for a retry of the document still exist to avoid looping\n          // indefinitely when the document was deleted from under our noses\n          this.commits.unshift(commit)\n        }\n        docResponder.failure()\n\n        // Todo: Need better error handling (i.e. propagate to user and provide means of retrying)\n        if (commit.tries < 200) {\n          setTimeout(() => this._cycleCommitter(), Math.min(commit.tries * 1000, ONE_MINUTE))\n        }\n      },\n\n      cancel: (error: Error) => {\n        this.commits.forEach((comm) => comm.reject(error))\n\n        // Throw away waiting commits\n        this.commits = []\n\n        // Reset back to last known state from content lake and cause a rebase that will\n        // reset the view in the form\n        this.reset(this.document.HEAD)\n\n        // Clear the buffer of recent mutations\n        this.buffer = new SquashingBuffer(this.LOCAL)\n\n        // Stop the committer loop\n        this.committerRunning = false\n      },\n    }\n\n    debug('Posting commit')\n    if (this.commitHandler) {\n      this.commitHandler({\n        mutation: squashed,\n        success: responder.success,\n        failure: responder.failure,\n        cancel: responder.cancel,\n      })\n    }\n  }\n\n  handleDocRebase(edge: Doc | null, remoteMutations: Mutation[], localMutations: Mutation[]): void {\n    this.rebase(remoteMutations, localMutations)\n  }\n\n  handleDocumentDeleted(): void {\n    debug('Document deleted')\n    // If the document was just deleted, fire the onDelete event with the absolutely latest\n    // version of the document before someone deleted it so that the client may revive the\n    // document in the last state the user saw it, should they so desire.\n    if (this.LOCAL !== null && this.onDelete) {\n      this.onDelete(this.LOCAL)\n    }\n\n    this.commits = []\n    this.mutations = []\n  }\n\n  handleDocMutation(msg: {mutation: Mutation; document: Doc | null; remote: boolean}): void {\n    // If we have no local changes, we can just pass this on to the client\n    if (this.commits.length === 0 && !this.buffer.hasChanges()) {\n      debug('Document mutated from remote with no local changes')\n      this.LOCAL = this.document.EDGE\n      this.buffer = new SquashingBuffer(this.LOCAL)\n      if (this.onMutation) {\n        this.onMutation(msg)\n      }\n      return\n    }\n\n    debug('Document mutated from remote with local changes')\n\n    // If there are local edits, and the document was deleted, we need to purge those local edits now\n    if (this.document.EDGE === null) {\n      this.handleDocumentDeleted()\n    }\n\n    // We had local changes, so need to signal rebase\n    this.rebase([msg.mutation], [])\n  }\n\n  rebase(remoteMutations: Mutation[], localMutations: Mutation[]): void {\n    debug('Rebasing document')\n    if (this.document.EDGE === null) {\n      this.handleDocumentDeleted()\n    }\n\n    const oldLocal = this.LOCAL\n    this.LOCAL = this.commits.reduce((doc, commit) => commit.apply(doc), this.document.EDGE)\n    this.LOCAL = this.buffer.rebase(this.LOCAL)\n\n    // Copy over rev, since we don't care if it changed, we only care about the content\n    if (oldLocal !== null && this.LOCAL !== null) {\n      oldLocal._rev = this.LOCAL._rev\n    }\n\n    const changed = !isEqual(this.LOCAL, oldLocal)\n    if (changed && this.onRebase) {\n      this.onRebase(\n        this.LOCAL,\n        remoteMutations.reduce(mutReducerFn, []),\n        localMutations.reduce(mutReducerFn, []),\n      )\n    }\n  }\n\n  handleDocConsistencyChanged(isConsistent: boolean): void {\n    if (!this.onConsistencyChanged) {\n      return\n    }\n\n    const hasLocalChanges = this.commits.length > 0 || this.buffer.hasChanges()\n\n    if (isConsistent && !hasLocalChanges) {\n      this.onConsistencyChanged(true)\n    }\n\n    if (!isConsistent) {\n      this.onConsistencyChanged(false)\n    }\n  }\n}\n"],"names":["digitChar","attributeCharMatcher","attributeFirstCharMatcher","symbols","operator","comparator","keyword","boolean","paren","symbolClasses","Object","keys","Tokenizer","constructor","path","__publicField","source","length","i","tokenizers","tokenizeSymbol","tokenizeIdentifier","tokenizeNumber","tokenizeQuoted","map","fn","bind","tokenize","result","EOF","chompWhitespace","token","found","some","tokenizer","Boolean","Error","concat","push","takeWhile","start","nextChar","peek","consume","str","slice","tryConsume","char","quote","escape","inner","type","value","first","identifier","match","name","dotSeen","digitSeen","negative","number","raw","symbolClass","patterns","symbol","find","pattern","jsonpath","Parser","tokens","parse","parsePath","probe","record","every","key","parseAttribute","quoted","parseAlias","target","parseNumber","parseNumberValue","expr","parseSliceSelector","rangeStart","colon1","end","colon2","step","parseValueReference","parseLiteralValue","literalString","literalBoolean","parseFilterExpression","lhs","binOp","rhs","parseExpression","parseUnion","terms","nodes","parseRecursive","subpath","term","attr","union","recursive","parseJsonPath","parsed","descend","tail","head","newTail","splitIfPath","spreadIfUnionHead","concatPaths","path1","path2","nodes1","nodes2","node","subHead","subTail","toPath","toPathInner","inUnion","join","JSON","stringify","shift","upcoming","e","Expression","isPath","isUnion","isCollection","isConstraint","isRecursive","isExistenceConstraint","isIndex","isRange","expandRange","probeLength","interpretNegativeIndex","isAttributeReference","isIndexReference","isSelfReference","constraintTargetIsSelf","constraintTargetIsAttribute","testConstraint","containerType","get","testBinaryOperator","lhsValue","getAttribute","pathNodes","prepend","other","headTail","unwrapRecursive","toIndicies","range","toFieldReferences","toString","fromPath","attributeReference","indexReference","rhsValue","index","Descender","iterate","anyConstraints","flatten","default","descender","iterateConstraints","hasArrived","extractRecursives","constraint","getIndex","ht","Matcher","active","parent","recursives","payload","setPayload","filter","activeRecursives","hasAttribute","extractMatches","newActiveSet","forEach","isDestination","hasRecursives","leads","targets","descenderHead","matcher","recursivesMatcher","attributeKeys","delivery","isRecord","PlainProbe","_value","Array","isArray","hasOwnProperty","extractAccessors","appendResult","values","accessor","lead","accessorsFromTarget","childAccessor","compact","extract","accessors","acc","extractWithPath","IS_DOTTABLE","arrayToJSONMatchPath","pathArray","segment","stringifySegment","hasLeading","seg","isPrimitiveValue","test","val","SetPatch","id","apply","set","setIndex","setAttribute","performIncrement","previousValue","delta","Number","isFinite","IncPatch","item","attribute","targetsToIndicies","sort","InsertPatch","location","items","pos","minIndex","insertItemsAt","maxIndex","indicies","unsetIndices","min","max","SetIfMissingPatch","UnsetPatch","unsetAttribute","applyPatch","patch","oldValue","applyPatches","allowExceedingIndices","DiffMatchPatch","dmpPatchSrc","dmpPatch","parsePatch","nextValue","reduce","r","p","setIfMissing","unset","diffMatchPatch","inc","dec","insert","spec","before","after","replace","ImmutableAccessor","is","setIndexAccessor","indices","indexOf","assign","setAttributeAccessor","Patcher","patches","applyViaAccessor","idAccessor","process","isSetPatch","oldValueAccessor","newValueAccessor","isPatcher","luid","uuid","debug","debugIt","Mutation","options","params","transactionId","transition","identity","previousRev","resultRev","mutations","timestamp","Date","effects","assignRandomTransactionId","appliesToMissingDocument","_appliesToMissingDocument","firstMut","create","createIfNotExists","createOrReplace","compile","operations","mutation","doc","_createdAt","delete","_updatedAt","prevRev","rev","compiled","_rev","operation","document","applyAll","squash","squashed","Document","reset","HEAD","EDGE","incoming","submitted","pending","inconsistentAt","considerIncoming","updateConsistencyFlag","arrive","stage","silent","lastStagedAt","onMutation","remote","txnId","success","pendingSuccessfullySubmitted","failure","pendingFailed","isConsistent","mustRebase","nextMut","rebaseMutations","updatedAt","mut","protect","applied","applyIncoming","enabled","rebase","wasConsistent","onConsistencyChanged","onRemoteMutation","m","hasUnresolvedMutations","needRebase","consumeUnresolved","pendingTxnId","justSubmitted","stillPending","incomingMutations","oldEdge","changed","isEqual","onRebase","SquashingBuffer","staged","setOperations","documentPresent","BASIS","PRESTAGE","add","op","addOperation","hasChanges","out","purge","stashStagedOperations","_a","_id","setPatch","unoptimizable","optimiseSetOperation","matches","stringifyPatches","makePatches","canonicalPath","nextOps","newBasis","ONE_MINUTE","Commit","_ref","resolve","reject","tries","mutReducerFn","BufferedDocument","buffer","msg","handleDocMutation","edge","remoteMutations","localMutations","handleDocRebase","handleDocConsistencyChanged","LOCAL","commits","oldLocal","onDelete","commit","Promise","pendingMutations","performCommits","commitHandler","committerRunning","_cycleCommitter","docResponder","responder","unshift","setTimeout","Math","cancel","error","comm","handleDocumentDeleted","hasLocalChanges"],"mappings":"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"}