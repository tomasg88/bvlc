{
  "version": 3,
  "sources": ["../../../sanity/src/desk/panes/documentList/constants.ts", "../../../sanity/src/desk/panes/documentList/helpers.ts", "../../../sanity/src/desk/panes/documentList/DocumentListPaneContent.tsx", "../../../sanity/src/desk/panes/documentList/DocumentListPaneHeader.tsx", "../../../sanity/src/desk/panes/documentList/listenSearchQuery.ts", "../../../sanity/src/desk/panes/documentList/useDocumentList.ts", "../../../sanity/src/desk/panes/documentList/DocumentListPane.tsx"],
  "sourcesContent": ["import {SortOrder} from './types'\n\nexport const PARTIAL_PAGE_LIMIT = 100\nexport const FULL_LIST_LIMIT = 2000\nexport const DEFAULT_ORDERING: SortOrder = {by: [{field: '_updatedAt', direction: 'desc'}]}\nexport const EMPTY_RECORD: Record<string, unknown> = {}\n", "import * as PathUtils from '@sanity/util/paths'\nimport {\n  isIndexSegment,\n  isKeySegment,\n  isReferenceSchemaType,\n  ObjectField,\n  ObjectFieldType,\n  ObjectSchemaType,\n  SanityDocument,\n  SchemaType,\n} from '@sanity/types'\nimport {DocumentListPaneItem, SortOrder} from './types'\nimport {getPublishedId, collate} from 'sanity'\n\nexport function getDocumentKey(value: DocumentListPaneItem, index: number): string {\n  return value._id ? getPublishedId(value._id) : `item-${index}`\n}\n\nexport function removePublishedWithDrafts(documents: SanityDocument[]): DocumentListPaneItem[] {\n  return collate(documents).map((entry) => {\n    const doc = entry.draft || entry.published\n    return {\n      ...doc,\n      hasPublished: !!entry.published,\n      hasDraft: !!entry.draft,\n    }\n  }) as any\n}\n\nconst RE_TYPE_NAME_IN_FILTER =\n  /\\b_type\\s*==\\s*(['\"].*?['\"]|\\$.*?(?:\\s|$))|\\B(['\"].*?['\"]|\\$.*?(?:\\s|$))\\s*==\\s*_type\\b/\nexport function getTypeNameFromSingleTypeFilter(\n  filter: string,\n  params: Record<string, unknown> = {},\n): string | null {\n  const matches = filter.match(RE_TYPE_NAME_IN_FILTER)\n\n  if (!matches) {\n    return null\n  }\n\n  const match = (matches[1] || matches[2]).trim().replace(/^[\"']|[\"']$/g, '')\n\n  if (match[0] === '$') {\n    const k = match.slice(1)\n    const v = params[k]\n\n    return typeof v === 'string' ? v : null\n  }\n\n  return match\n}\n\nexport function isSimpleTypeFilter(filter: string): boolean {\n  return /^_type\\s*==\\s*['\"$]\\w+['\"]?\\s*$/.test(filter.trim())\n}\n\nexport function applyOrderingFunctions(order: SortOrder, schemaType: ObjectSchemaType): SortOrder {\n  const orderBy = order.by.map((by) => {\n    // Skip those that already have a mapper\n    if (by.mapWith) {\n      return by\n    }\n\n    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field)\n    if (!fieldType) {\n      return by\n    }\n\n    // Note: order matters here, since the jsonType of a date field is `string`,\n    // but we want to apply `datetime()`, not `lower()`\n    if (fieldExtendsType(fieldType, 'datetime')) {\n      return {...by, mapWith: 'dateTime'}\n    }\n\n    if (fieldType.jsonType === 'string') {\n      return {...by, mapWith: 'lower'}\n    }\n\n    return by\n  })\n\n  return orderBy.every((item, index) => item === order.by[index]) ? order : {...order, by: orderBy}\n}\n\nfunction tryResolveSchemaTypeForPath(baseType: SchemaType, path: string): SchemaType | undefined {\n  const pathSegments = PathUtils.fromString(path)\n\n  let current: SchemaType | undefined = baseType\n  for (const segment of pathSegments) {\n    if (!current) {\n      return undefined\n    }\n\n    if (typeof segment === 'string') {\n      current = getFieldTypeByName(current, segment)\n      continue\n    }\n\n    const isArrayAccessor = isKeySegment(segment) || isIndexSegment(segment)\n    if (!isArrayAccessor || current.jsonType !== 'array') {\n      return undefined\n    }\n\n    const [memberType, otherType] = current.of || []\n    if (otherType || !memberType) {\n      // Can't figure out the type without knowing the value\n      return undefined\n    }\n\n    if (!isReferenceSchemaType(memberType)) {\n      current = memberType\n      continue\n    }\n\n    const [refType, otherRefType] = memberType.to || []\n    if (otherRefType || !refType) {\n      // Can't figure out the type without knowing the value\n      return undefined\n    }\n\n    current = refType\n  }\n\n  return current\n}\n\nfunction getFieldTypeByName(type: SchemaType, fieldName: string): SchemaType | undefined {\n  if (!('fields' in type)) {\n    return undefined\n  }\n\n  const fieldType = type.fields.find((field) => field.name === fieldName)\n  return fieldType ? fieldType.type : undefined\n}\n\nexport function fieldExtendsType(field: ObjectField | ObjectFieldType, ofType: string): boolean {\n  let current: SchemaType | undefined = field.type\n  while (current) {\n    if (current.name === ofType) {\n      return true\n    }\n\n    if (!current.type && current.jsonType === ofType) {\n      return true\n    }\n\n    current = current.type\n  }\n\n  return false\n}\n", "import {SyncIcon} from '@sanity/icons'\nimport {Box, Button, Card, Container, Flex, Heading, Spinner, Stack, Text} from '@sanity/ui'\nimport React, {useCallback, useEffect, useMemo, useState} from 'react'\nimport {SanityDocument} from '@sanity/types'\nimport styled from 'styled-components'\nimport {Delay, PaneContent, usePane, usePaneLayout, PaneItem} from '../../components'\nimport {DocumentListPaneItem, LoadingVariant} from './types'\nimport {FULL_LIST_LIMIT} from './constants'\nimport {\n  CommandList,\n  CommandListRenderItemCallback,\n  GeneralPreviewLayoutKey,\n  SanityDefaultPreview,\n  getPublishedId,\n  useSchema,\n} from 'sanity'\n\nconst RootBox = styled(Box)`\n  position: relative;\n`\n\nconst CommandListBox = styled(Box)`\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n`\n\ninterface DocumentListPaneContentProps {\n  childItemId?: string\n  error: {message: string} | null\n  filterIsSimpleTypeConstraint: boolean\n  hasMaxItems?: boolean\n  hasSearchQuery: boolean\n  isActive?: boolean\n  isLazyLoading: boolean\n  isLoading: boolean\n  items: DocumentListPaneItem[]\n  layout?: GeneralPreviewLayoutKey\n  loadingVariant?: LoadingVariant\n  onListChange: () => void\n  onRetry?: (event: unknown) => void\n  paneTitle: string\n  searchInputElement: HTMLInputElement | null\n  showIcons: boolean\n}\n\nconst SKELETON_ITEMS = [...Array(30).keys()]\n\nfunction LoadingView(props: {layout?: GeneralPreviewLayoutKey}) {\n  const {layout} = props\n\n  return (\n    <Stack padding={2} space={1}>\n      {SKELETON_ITEMS.map((num) => (\n        <Card padding={2} key={num}>\n          <SanityDefaultPreview isPlaceholder layout={layout} />\n        </Card>\n      ))}\n    </Stack>\n  )\n}\n\nexport function DocumentListPaneContent(props: DocumentListPaneContentProps) {\n  const {\n    childItemId,\n    error,\n    filterIsSimpleTypeConstraint,\n    hasMaxItems,\n    hasSearchQuery,\n    isActive,\n    isLazyLoading,\n    isLoading,\n    items,\n    layout,\n    loadingVariant,\n    onListChange,\n    onRetry,\n    paneTitle,\n    searchInputElement,\n    showIcons,\n  } = props\n\n  const schema = useSchema()\n\n  const {collapsed: layoutCollapsed} = usePaneLayout()\n  const {collapsed, index} = usePane()\n  const [shouldRender, setShouldRender] = useState(false)\n\n  const handleEndReached = useCallback(() => {\n    if (isLoading || isLazyLoading || !shouldRender) return\n\n    onListChange()\n  }, [isLazyLoading, isLoading, onListChange, shouldRender])\n\n  useEffect(() => {\n    if (collapsed) return undefined\n\n    const timer = setTimeout(() => {\n      setShouldRender(true)\n    }, 0)\n\n    return () => {\n      clearTimeout(timer)\n    }\n  }, [collapsed, items])\n\n  const renderItem = useCallback<CommandListRenderItemCallback<SanityDocument>>(\n    (item, {activeIndex}) => {\n      const publishedId = getPublishedId(item._id)\n      const isSelected = childItemId === publishedId\n      const pressed = !isActive && isSelected\n      const selected = isActive && isSelected\n      const isLastItem = activeIndex === items.length - 1\n      const showSpinner = isLastItem && isLazyLoading\n      const showMaxItemsMessage = isLastItem && hasMaxItems\n\n      return (\n        <>\n          <PaneItem\n            icon={showIcons === false ? false : undefined}\n            id={publishedId}\n            layout={layout}\n            marginBottom={1}\n            pressed={pressed}\n            schemaType={schema.get(item._type)}\n            selected={selected}\n            value={item}\n          />\n\n          {showSpinner && (\n            <Flex align=\"center\" justify=\"center\" padding={4}>\n              <Spinner muted />\n            </Flex>\n          )}\n\n          {showMaxItemsMessage && (\n            <Box marginY={1} paddingX={3} paddingY={4}>\n              <Text align=\"center\" muted size={1}>\n                Displaying a maximum of {FULL_LIST_LIMIT} documents\n              </Text>\n            </Box>\n          )}\n        </>\n      )\n    },\n    [childItemId, isActive, items.length, layout, schema, showIcons, hasMaxItems, isLazyLoading],\n  )\n\n  const noDocumentsContent = useMemo(() => {\n    if (hasSearchQuery) {\n      return (\n        <Flex align=\"center\" direction=\"column\" height=\"fill\" justify=\"center\">\n          <Container width={1}>\n            <Box paddingX={4} paddingY={5}>\n              <Text align=\"center\" muted>\n                No results found\n              </Text>\n            </Box>\n          </Container>\n        </Flex>\n      )\n    }\n\n    return (\n      <Flex align=\"center\" direction=\"column\" height=\"fill\" justify=\"center\">\n        <Container width={1}>\n          <Box paddingX={4} paddingY={5}>\n            <Text align=\"center\" muted>\n              {filterIsSimpleTypeConstraint ? 'No documents of this type' : 'No matching documents'}\n            </Text>\n          </Box>\n        </Container>\n      </Flex>\n    )\n  }, [filterIsSimpleTypeConstraint, hasSearchQuery])\n\n  const mainContent = useMemo(() => {\n    if (!shouldRender) {\n      return null\n    }\n\n    if (error) {\n      return (\n        <Flex align=\"center\" direction=\"column\" height=\"fill\" justify=\"center\">\n          <Container width={1}>\n            <Stack paddingX={4} paddingY={5} space={4}>\n              <Heading as=\"h3\">Could not fetch list items</Heading>\n              <Text as=\"p\">\n                Error: <code>{error.message}</code>\n              </Text>\n\n              {onRetry && (\n                <Box>\n                  <Button icon={SyncIcon} onClick={onRetry} text=\"Retry\" tone=\"primary\" />\n                </Box>\n              )}\n            </Stack>\n          </Container>\n        </Flex>\n      )\n    }\n\n    if (!isLoading && items.length === 0) {\n      return noDocumentsContent\n    }\n\n    if (loadingVariant === 'initial' && isLoading) {\n      return (\n        <Delay ms={300}>\n          <LoadingView layout={layout} />\n        </Delay>\n      )\n    }\n\n    if (loadingVariant === 'spinner' && isLoading) {\n      return null\n    }\n\n    // prevents bug when panes won't render if first rendered while collapsed\n    const key = `${index}-${collapsed}`\n\n    return (\n      <RootBox overflow=\"hidden\" height=\"fill\">\n        <CommandListBox>\n          <CommandList\n            activeItemDataAttr=\"data-hovered\"\n            ariaLabel={paneTitle}\n            canReceiveFocus\n            focusRingOffset={-3}\n            inputElement={searchInputElement}\n            itemHeight={51}\n            items={items}\n            key={key}\n            onEndReached={handleEndReached}\n            onlyShowSelectionWhenActive\n            overscan={10}\n            padding={2}\n            paddingBottom={1}\n            renderItem={renderItem}\n            wrapAround={false}\n          />\n        </CommandListBox>\n      </RootBox>\n    )\n    // Explicitly don't include `noDocumentsContent` in the deps array, as it's\n    // causing a visual bug where the \"No documents\" message is shown for a split second\n    // when clearing a search query with no results\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    collapsed,\n    error,\n    handleEndReached,\n    index,\n    isLoading,\n    items,\n    layout,\n    loadingVariant,\n    // noDocumentsContent,\n    onRetry,\n    renderItem,\n    searchInputElement,\n    shouldRender,\n  ])\n\n  return (\n    <PaneContent overflow={layoutCollapsed || loadingVariant === 'initial' ? 'hidden' : 'auto'}>\n      {mainContent}\n    </PaneContent>\n  )\n}\n", "import {ArrowLeftIcon} from '@sanity/icons'\nimport {Button} from '@sanity/ui'\nimport React, {memo, useMemo} from 'react'\nimport {PaneMenuItem, PaneMenuItemGroup, DeskToolPaneActionHandler} from '../../types'\nimport {BackLink, PaneHeader, PaneHeaderActions, usePane} from '../../components'\nimport {useDeskTool} from '../../useDeskTool'\nimport {SortOrder} from './types'\nimport {GeneralPreviewLayoutKey, InitialValueTemplateItem} from 'sanity'\n\ninterface DocumentListPaneHeaderProps {\n  contentAfter?: React.ReactNode\n  index: number\n  initialValueTemplates?: InitialValueTemplateItem[]\n  menuItemGroups?: PaneMenuItemGroup[]\n  menuItems?: PaneMenuItem[]\n  setLayout: (layout: GeneralPreviewLayoutKey) => void\n  setSortOrder: (sortOrder: SortOrder) => void\n  title: string\n}\n\nexport const DocumentListPaneHeader = memo(\n  ({\n    contentAfter,\n    index,\n    initialValueTemplates = [],\n    menuItemGroups = [],\n    menuItems = [],\n    setLayout,\n    setSortOrder,\n    title,\n  }: DocumentListPaneHeaderProps) => {\n    const {features} = useDeskTool()\n    const {collapsed, isLast} = usePane()\n    // Prevent focus if this is the last (non-collapsed) pane.\n    const tabIndex = isLast && !collapsed ? -1 : 0\n\n    const actionHandlers = useMemo((): Record<string, DeskToolPaneActionHandler> => {\n      return {\n        setLayout: ({layout: value}: {layout: GeneralPreviewLayoutKey}) => {\n          setLayout(value)\n        },\n        setSortOrder: (sort: SortOrder) => {\n          setSortOrder(sort)\n        },\n      }\n    }, [setLayout, setSortOrder])\n\n    return (\n      <PaneHeader\n        actions={\n          <PaneHeaderActions\n            initialValueTemplateItems={initialValueTemplates}\n            actionHandlers={actionHandlers}\n            menuItemGroups={menuItemGroups}\n            menuItems={menuItems}\n          />\n        }\n        backButton={\n          features.backButton &&\n          index > 0 && <Button as={BackLink} data-as=\"a\" icon={ArrowLeftIcon} mode=\"bleed\" />\n        }\n        contentAfter={contentAfter}\n        tabIndex={tabIndex}\n        title={title}\n      />\n    )\n  },\n)\n\nDocumentListPaneHeader.displayName = 'DocumentListPaneHeader'\n", "import {SanityClient, SanityDocument} from '@sanity/client'\nimport {\n  asyncScheduler,\n  defer,\n  merge,\n  mergeMap,\n  Observable,\n  of,\n  partition,\n  share,\n  take,\n  throttleTime,\n  throwError,\n  timer,\n} from 'rxjs'\nimport {exhaustMapWithTrailing} from 'rxjs-exhaustmap-with-trailing'\nimport {SortOrder} from './types'\nimport {\n  createSearchQuery,\n  Schema,\n  SearchableType,\n  SearchOptions,\n  SearchTerms,\n  WeightedSearchOptions,\n} from 'sanity'\n\ninterface ListenQueryOptions {\n  client: SanityClient\n  filter: string\n  limit: number\n  params: Record<string, unknown>\n  schema: Schema\n  searchQuery: string\n  sort: SortOrder\n  staticTypeNames?: string[]\n}\n\nexport function listenSearchQuery(options: ListenQueryOptions): Observable<SanityDocument[]> {\n  const {client, schema, sort, limit, params, filter, searchQuery, staticTypeNames} = options\n  const sortBy = sort.by\n  const extendedProjection = sort?.extendedProjection\n\n  // Listen for changes with the given filter and params, and whenever a change occurs, we want to\n  // re-fetch the documents that match the search query (see below).\n  // We use a separate listener since the search query is too large to use in a listen query.\n  const events$ = defer(() => {\n    return client.listen(`*[${filter}]`, params, {\n      events: ['welcome', 'mutation', 'reconnect'],\n      includeResult: false,\n      visibility: 'query',\n    })\n  }).pipe(\n    mergeMap((ev, i) => {\n      const isFirst = i === 0\n      if (isFirst && ev.type !== 'welcome') {\n        // If the first event is not welcome, it is most likely a reconnect and\n        // if it's not a reconnect something is very wrong and we should throw.\n        return throwError(\n          () =>\n            new Error(\n              ev.type === 'reconnect'\n                ? 'Could not establish EventSource connection'\n                : `Received unexpected type of first event \"${ev.type}\"`,\n            ),\n        )\n      }\n      return of(ev)\n    }),\n    share(),\n  )\n\n  const [welcome$, mutationAndReconnect$] = partition(events$, (ev) => ev.type === 'welcome')\n\n  return merge(\n    welcome$.pipe(take(1)),\n    mutationAndReconnect$.pipe(throttleTime(1000, asyncScheduler, {leading: true, trailing: true})),\n  ).pipe(\n    exhaustMapWithTrailing((event) => {\n      // Get the types names to use for searching.\n      // If we have a static list of types, we can skip fetching the types and use the static list.\n      const typeNames$ = staticTypeNames\n        ? of(staticTypeNames)\n        : client.observable.fetch(`array::unique(*[${filter}][]._type)`, params)\n\n      // Use the type names to create a search query and fetch the documents that match the query.\n      return typeNames$.pipe(\n        mergeMap((typeNames: string[]) => {\n          const types = typeNames.flatMap((name) => schema.get(name) || []) as SearchableType[]\n\n          const searchTerms: SearchTerms = {\n            filter,\n            query: searchQuery || '',\n            types,\n          }\n\n          const searchOptions: SearchOptions & WeightedSearchOptions = {\n            __unstable_extendedProjection: extendedProjection,\n            comments: [`findability-source: ${searchQuery ? 'list-query' : 'list'}`],\n            limit,\n            params,\n            sort: sortBy,\n          }\n\n          const {query: createdQuery, params: createdParams} = createSearchQuery(\n            searchTerms,\n            searchOptions,\n          )\n          const doFetch = () => client.observable.fetch(createdQuery, createdParams)\n\n          if (event.type === 'mutation' && event.visibility !== 'query') {\n            // Even though the listener request specifies visibility=query, the events are not guaranteed to be delivered with visibility=query\n            // If the event we are responding to arrives with visibility != query, we add a little delay to allow for the updated document to be available for queries\n            // See https://www.sanity.io/docs/listening#visibility-c4786e55c3ff\n            return timer(1200).pipe(mergeMap(doFetch))\n          }\n          return doFetch()\n        }),\n      )\n    }),\n  )\n}\n", "import {useCallback, useEffect, useMemo, useState} from 'react'\nimport {concat, fromEvent, merge, of, Subject, throwError} from 'rxjs'\nimport {catchError, map, mergeMap, scan, startWith, take} from 'rxjs/operators'\nimport {DocumentListPaneItem, QueryResult, SortOrder} from './types'\nimport {getTypeNameFromSingleTypeFilter, removePublishedWithDrafts} from './helpers'\nimport {DEFAULT_ORDERING, FULL_LIST_LIMIT, PARTIAL_PAGE_LIMIT} from './constants'\nimport {listenSearchQuery} from './listenSearchQuery'\nimport {DEFAULT_STUDIO_CLIENT_OPTIONS, useClient, useSchema} from 'sanity'\n\nconst EMPTY_ARRAY: [] = []\n\nconst INITIAL_STATE: QueryResult = {\n  error: null,\n  onRetry: undefined,\n  result: null,\n}\n\ninterface UseDocumentListOpts {\n  apiVersion?: string\n  filter: string\n  params: Record<string, unknown>\n  searchQuery: string | null\n  sortOrder?: SortOrder\n}\n\ninterface DocumentListState {\n  error: {message: string} | null\n  hasMaxItems?: boolean\n  isLazyLoading: boolean\n  isLoading: boolean\n  isSearchReady: boolean\n  items: DocumentListPaneItem[]\n  onListChange: () => void\n  onRetry?: (event: unknown) => void\n}\n\nconst INITIAL_QUERY_RESULTS: QueryResult = {\n  result: null,\n  error: null,\n}\n\n/**\n * @internal\n */\nexport function useDocumentList(opts: UseDocumentListOpts): DocumentListState {\n  const {filter, params: paramsProp, sortOrder, searchQuery, apiVersion} = opts\n  const client = useClient({\n    ...DEFAULT_STUDIO_CLIENT_OPTIONS,\n    apiVersion: apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion,\n  })\n  const schema = useSchema()\n\n  const [resultState, setResult] = useState<QueryResult>(INITIAL_STATE)\n  const {onRetry, error, result} = resultState\n\n  const documents = result?.documents\n\n  // Filter out published documents that have drafts to avoid duplicates in the list.\n  const items = useMemo(\n    () => (documents ? removePublishedWithDrafts(documents) : EMPTY_ARRAY),\n    [documents],\n  )\n\n  // A state variable to keep track of whether we are currently lazy loading the list.\n  // This is used to determine whether we should show the loading spinner at the bottom of the list.\n  const [isLazyLoading, setIsLazyLoading] = useState<boolean>(false)\n\n  // A state to keep track of whether we have fetched the full list of documents.\n  const [hasFullList, setHasFullList] = useState<boolean>(false)\n\n  // A state to keep track of whether we should fetch the full list of documents.\n  const [shouldFetchFullList, setShouldFetchFullList] = useState<boolean>(false)\n\n  // Get the type name from the filter, if it is a simple type filter.\n  const typeNameFromFilter = useMemo(\n    () => getTypeNameFromSingleTypeFilter(filter, paramsProp),\n    [filter, paramsProp],\n  )\n\n  // We can't have the loading state as part of the result state, since the loading\n  // state would be updated whenever a mutation is performed in a document in the list.\n  // Instead, we determine if the list is loading by checking if the result is null.\n  // The result is null when:\n  // 1. We are making the initial request\n  // 2. The user has performed a search or changed the sort order\n  const isLoading = result === null && !error\n\n  // A flag to indicate whether we have reached the maximum number of documents.\n  const hasMaxItems = documents?.length === FULL_LIST_LIMIT\n\n  // This function is triggered when the user has scrolled to the bottom of the list\n  // and we need to fetch more items.\n  const onListChange = useCallback(() => {\n    if (isLoading || hasFullList || shouldFetchFullList) return\n\n    setShouldFetchFullList(true)\n  }, [isLoading, hasFullList, shouldFetchFullList])\n\n  const handleSetResult = useCallback(\n    (res: QueryResult) => {\n      if (res.error) {\n        setResult(res)\n        return\n      }\n\n      const documentsLength = res.result?.documents?.length || 0\n      const isLoadingMoreItems = !res.error && res?.result === null && shouldFetchFullList\n\n      // 1. When the result is null and shouldFetchFullList is true, we are loading _more_ items.\n      // In this case, we want to wait for the next result and set the isLazyLoading state to true.\n      if (isLoadingMoreItems) {\n        setIsLazyLoading(true)\n        return\n      }\n\n      // 2. If the result is not null, and less than the partial page limit, we know that\n      // we have fetched the full list of documents. In this case, we want to set the\n      // hasFullList state to true to prevent further requests.\n      if (documentsLength < PARTIAL_PAGE_LIMIT && documentsLength !== 0 && !shouldFetchFullList) {\n        setHasFullList(true)\n      }\n\n      // 3. If the result is null, we are loading items. In this case, we want to\n      // wait for the next result.\n      if (res?.result === null) {\n        setResult((prev) => ({...(prev.error ? res : prev)}))\n        return\n      }\n\n      // 4. Finally, set the result\n      setIsLazyLoading(false)\n      setResult(res)\n    },\n    [shouldFetchFullList],\n  )\n\n  const queryResults$ = useMemo(() => {\n    const onRetry$ = new Subject<void>()\n    const _onRetry = () => onRetry$.next()\n\n    const limit = shouldFetchFullList ? FULL_LIST_LIMIT : PARTIAL_PAGE_LIMIT\n    const sort = sortOrder || DEFAULT_ORDERING\n\n    return listenSearchQuery({\n      client,\n      filter,\n      limit,\n      params: paramsProp,\n      schema,\n      searchQuery: searchQuery || '',\n      sort,\n      staticTypeNames: typeNameFromFilter ? [typeNameFromFilter] : undefined,\n    }).pipe(\n      map((results) => ({\n        result: {documents: results},\n        error: null,\n      })),\n      startWith(INITIAL_QUERY_RESULTS),\n      catchError((err) => {\n        if (err instanceof ProgressEvent) {\n          // todo: hack to work around issue with get-it (used by sanity/client) that propagates connection errors as ProgressEvent instances. This if-block can be removed once @sanity/client is par with a version of get-it that includes this fix: https://github.com/sanity-io/get-it/pull/127\n          return throwError(() => new Error(`Request error`))\n        }\n        return throwError(() => err)\n      }),\n      catchError((err, caught$) => {\n        return concat(\n          of({result: null, error: err}),\n          merge(fromEvent(window, 'online'), onRetry$).pipe(\n            take(1),\n            mergeMap(() => caught$),\n          ),\n        )\n      }),\n      scan((prev, next) => ({...prev, ...next, onRetry: _onRetry})),\n    )\n  }, [\n    client,\n    filter,\n    paramsProp,\n    schema,\n    searchQuery,\n    shouldFetchFullList,\n    sortOrder,\n    typeNameFromFilter,\n  ])\n\n  useEffect(() => {\n    const sub = queryResults$.subscribe(handleSetResult)\n\n    return () => {\n      sub.unsubscribe()\n    }\n  }, [handleSetResult, queryResults$])\n\n  const reset = useCallback(() => {\n    setHasFullList(false)\n    setIsLazyLoading(false)\n    setResult(INITIAL_STATE)\n    setShouldFetchFullList(false)\n  }, [])\n\n  useEffect(() => {\n    reset()\n  }, [reset, filter, paramsProp, sortOrder, searchQuery])\n\n  return {\n    error,\n    hasMaxItems,\n    isLazyLoading,\n    isLoading,\n    isSearchReady: !error,\n    items,\n    onListChange,\n    onRetry,\n  }\n}\n", "import React, {memo, useCallback, useEffect, useMemo, useRef, useState} from 'react'\nimport {Box, Card, Code, TextInput} from '@sanity/ui'\nimport shallowEquals from 'shallow-equals'\nimport {isEqual} from 'lodash'\nimport {SearchIcon, SpinnerIcon} from '@sanity/icons'\nimport styled, {keyframes} from 'styled-components'\nimport {Observable, debounce, map, of, tap, timer} from 'rxjs'\nimport {useObservableCallback} from 'react-rx'\nimport {Pane} from '../../components/pane'\nimport {_DEBUG} from '../../constants'\nimport {useDeskToolSetting} from '../../useDeskToolSetting'\nimport {BaseDeskToolPaneProps} from '../types'\nimport {PaneMenuItem} from '../../types'\nimport {DEFAULT_ORDERING, EMPTY_RECORD} from './constants'\nimport {\n  applyOrderingFunctions,\n  getTypeNameFromSingleTypeFilter,\n  isSimpleTypeFilter,\n} from './helpers'\nimport {DocumentListPaneContent} from './DocumentListPaneContent'\nimport {DocumentListPaneHeader} from './DocumentListPaneHeader'\nimport {LoadingVariant, SortOrder} from './types'\nimport {useDocumentList} from './useDocumentList'\nimport {GeneralPreviewLayoutKey, SourceProvider, useSchema, useSource, useUnique} from 'sanity'\n\ntype DocumentListPaneProps = BaseDeskToolPaneProps<'documentList'>\n\nconst EMPTY_ARRAY: never[] = []\n\nconst rotate = keyframes`\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n`\n\nconst AnimatedSpinnerIcon = styled(SpinnerIcon)`\n  animation: ${rotate} 500ms linear infinite;\n`\n\nconst SearchCard = styled(Card)`\n  [data-ui='TextInput'] {\n    border-radius: inherit;\n  }\n`\n\nfunction useShallowUnique<ValueType>(value: ValueType): ValueType {\n  const valueRef = useRef<ValueType>(value)\n  if (!shallowEquals(valueRef.current, value)) {\n    valueRef.current = value\n  }\n  return valueRef.current\n}\n\nconst addSelectedStateToMenuItems = (options: {\n  menuItems?: PaneMenuItem[]\n  sortOrderRaw?: SortOrder\n  layout?: GeneralPreviewLayoutKey\n}) => {\n  const {menuItems, sortOrderRaw, layout} = options\n\n  return menuItems?.map((item) => {\n    if (item.params?.layout) {\n      return {\n        ...item,\n        selected: layout === item.params?.layout,\n      }\n    }\n\n    if (item?.params?.by) {\n      return {\n        ...item,\n        selected: isEqual(sortOrderRaw?.by, item?.params?.by || EMPTY_ARRAY),\n      }\n    }\n\n    return {...item, selected: false}\n  })\n}\n\n/**\n * @internal\n */\nexport const DocumentListPane = memo(function DocumentListPane(props: DocumentListPaneProps) {\n  const {childItemId, index, isActive, isSelected, pane, paneKey} = props\n  const schema = useSchema()\n  const {name: parentSourceName} = useSource()\n  const {\n    defaultLayout = 'default',\n    displayOptions,\n    initialValueTemplates = EMPTY_ARRAY,\n    menuItemGroups,\n    menuItems,\n    options,\n    title,\n  } = pane\n  const {apiVersion, defaultOrdering = EMPTY_ARRAY, filter} = options\n  const params = useShallowUnique(options.params || EMPTY_RECORD)\n  const sourceName = pane.source\n  const typeName = useMemo(() => getTypeNameFromSingleTypeFilter(filter, params), [filter, params])\n  const showIcons = displayOptions?.showIcons !== false\n  const [layout, setLayout] = useDeskToolSetting<GeneralPreviewLayoutKey>(\n    typeName,\n    'layout',\n    defaultLayout,\n  )\n\n  const [searchQuery, setSearchQuery] = useState<string>('')\n  const [searchInputValue, setSearchInputValue] = useState<string>('')\n  const [searchInputElement, setSearchInputElement] = useState<HTMLInputElement | null>(null)\n\n  // A ref to determine if we should show the loading spinner in the search input.\n  // This is used to avoid showing the spinner on initial load of the document list.\n  // We only wan't to show the spinner when the user interacts with the search input.\n  const showSearchLoadingRef = useRef<boolean>(false)\n\n  // Ensure that we use the defaultOrdering value from structure builder if any as the default\n  const defaultSortOrder = useMemo(() => {\n    return defaultOrdering?.length > 0 ? {by: defaultOrdering} : DEFAULT_ORDERING\n  }, [defaultOrdering])\n\n  const [sortOrderRaw, setSortOrder] = useDeskToolSetting<SortOrder>(\n    typeName,\n    'sortOrder',\n    defaultSortOrder,\n  )\n\n  const sortWithOrderingFn =\n    typeName && sortOrderRaw\n      ? applyOrderingFunctions(sortOrderRaw, schema.get(typeName) as any)\n      : sortOrderRaw\n\n  const sortOrder = useUnique(sortWithOrderingFn)\n  const filterIsSimpleTypeConstraint = isSimpleTypeFilter(filter)\n\n  const {\n    error,\n    hasMaxItems,\n    isLazyLoading,\n    isLoading,\n    isSearchReady,\n    items,\n    onListChange,\n    onRetry,\n  } = useDocumentList({\n    apiVersion,\n    filter,\n    params,\n    searchQuery: searchQuery?.trim(),\n    sortOrder,\n  })\n\n  const menuItemsWithSelectedState = useMemo(\n    () =>\n      addSelectedStateToMenuItems({\n        menuItems,\n        sortOrderRaw,\n        layout,\n      }),\n    [layout, menuItems, sortOrderRaw],\n  )\n\n  const handleQueryChange = useObservableCallback(\n    (event$: Observable<React.ChangeEvent<HTMLInputElement>>) => {\n      return event$.pipe(\n        map((event) => event.target.value),\n        tap(setSearchInputValue),\n        debounce((value) => (value === '' ? of('') : timer(300))),\n        tap(setSearchQuery),\n      )\n    },\n    [],\n  )\n\n  const handleClearSearch = useCallback(() => {\n    setSearchQuery('')\n    setSearchInputValue('')\n  }, [])\n\n  const handleSearchKeyDown = useCallback(\n    (event: React.KeyboardEvent<HTMLInputElement>) => {\n      if (event.key === 'Escape') {\n        handleClearSearch()\n      }\n    },\n    [handleClearSearch],\n  )\n\n  useEffect(() => {\n    if (showSearchLoadingRef.current === false && !isLoading) {\n      showSearchLoadingRef.current = true\n    }\n\n    return () => {\n      showSearchLoadingRef.current = false\n    }\n  }, [isLoading])\n\n  useEffect(() => {\n    // Clear search field and reset showSearchLoadingRef ref\n    // when switching between panes (i.e. when paneKey changes).\n    handleClearSearch()\n    showSearchLoadingRef.current = false\n  }, [paneKey, handleClearSearch])\n\n  const loadingVariant: LoadingVariant = useMemo(() => {\n    const showSpinner = isLoading && items.length === 0 && showSearchLoadingRef.current\n\n    if (showSpinner) return 'spinner'\n\n    return 'initial'\n  }, [isLoading, items.length])\n\n  const searchInput = (\n    <Box paddingX={2} paddingBottom={2}>\n      <SearchCard radius={4} tone=\"transparent\">\n        <TextInput\n          aria-label=\"Search list\"\n          autoComplete=\"off\"\n          border={false}\n          clearButton={Boolean(searchQuery)}\n          disabled={!isSearchReady}\n          fontSize={[2, 2, 1]}\n          icon={loadingVariant === 'spinner' ? AnimatedSpinnerIcon : SearchIcon}\n          onChange={handleQueryChange}\n          onClear={handleClearSearch}\n          onKeyDown={handleSearchKeyDown}\n          placeholder=\"Search list\"\n          radius={2}\n          ref={setSearchInputElement}\n          spellCheck={false}\n          value={searchInputValue}\n        />\n      </SearchCard>\n    </Box>\n  )\n\n  return (\n    <SourceProvider name={sourceName || parentSourceName}>\n      <Pane\n        currentMaxWidth={350}\n        data-ui=\"DocumentListPane\"\n        id={paneKey}\n        maxWidth={640}\n        minWidth={320}\n        selected={isSelected}\n      >\n        {_DEBUG && (\n          <Card padding={4} tone=\"transparent\">\n            <Code>{pane.source || '(none)'}</Code>\n          </Card>\n        )}\n\n        <DocumentListPaneHeader\n          contentAfter={searchInput}\n          index={index}\n          initialValueTemplates={initialValueTemplates}\n          menuItemGroups={menuItemGroups}\n          menuItems={menuItemsWithSelectedState}\n          setLayout={setLayout}\n          setSortOrder={setSortOrder}\n          title={title}\n        />\n\n        <DocumentListPaneContent\n          childItemId={childItemId}\n          error={error}\n          filterIsSimpleTypeConstraint={filterIsSimpleTypeConstraint}\n          hasMaxItems={hasMaxItems}\n          hasSearchQuery={Boolean(searchQuery)}\n          isActive={isActive}\n          isLazyLoading={isLazyLoading}\n          isLoading={isLoading}\n          items={items}\n          key={paneKey}\n          layout={layout}\n          loadingVariant={loadingVariant}\n          onListChange={onListChange}\n          onRetry={onRetry}\n          paneTitle={title}\n          searchInputElement={searchInputElement}\n          showIcons={showIcons}\n        />\n      </Pane>\n    </SourceProvider>\n  )\n})\n"],
  "mappings": "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",
  "names": ["PARTIAL_PAGE_LIMIT", "FULL_LIST_LIMIT", "DEFAULT_ORDERING", "by", "field", "direction", "EMPTY_RECORD", "removePublishedWithDrafts", "documents", "collate", "map", "entry", "doc", "draft", "published", "hasPublished", "hasDraft", "RE_TYPE_NAME_IN_FILTER", "getTypeNameFromSingleTypeFilter", "filter", "params", "arguments", "length", "undefined", "matches", "match", "trim", "replace", "k", "slice", "v", "isSimpleTypeFilter", "test", "applyOrderingFunctions", "order", "schemaType", "orderBy", "mapWith", "fieldType", "tryResolveSchemaTypeForPath", "fieldExtendsType", "jsonType", "every", "item", "index", "baseType", "path", "pathSegments", "fromString", "current", "segment", "getFieldTypeByName", "isArrayAccessor", "isKeySegment", "isIndexSegment", "memberType", "otherType", "of", "isReferenceSchemaType", "refType", "otherRefType", "to", "type", "fieldName", "fields", "find", "name", "ofType", "_a", "_b", "RootBox", "styled", "Box", "__template", "CommandListBox", "SKELETON_ITEMS", "Array", "keys", "LoadingView", "props", "layout", "jsx", "Stack", "padding", "space", "children", "num", "Card", "SanityDefaultPreview", "isPlaceholder", "DocumentListPaneContent", "childItemId", "error", "filterIsSimpleTypeConstraint", "hasMaxItems", "hasSearchQuery", "isActive", "isLazyLoading", "isLoading", "items", "loadingVariant", "onListChange", "onRetry", "paneTitle", "searchInputElement", "showIcons", "schema", "useSchema", "collapsed", "layoutCollapsed", "usePaneLayout", "usePane", "shouldRender", "setShouldRender", "useState", "handleEndReached", "useCallback", "useEffect", "timer", "setTimeout", "clearTimeout", "renderItem", "_ref", "activeIndex", "publishedId", "getPublishedId", "_id", "isSelected", "pressed", "selected", "isLastItem", "showSpinner", "showMaxItemsMessage", "jsxs", "Fragment", "PaneItem", "icon", "id", "marginBottom", "get", "_type", "value", "Flex", "align", "justify", "Spinner", "muted", "marginY", "paddingX", "paddingY", "Text", "size", "noDocumentsContent", "useMemo", "height", "Container", "width", "mainContent", "Heading", "as", "message", "Button", "SyncIcon", "onClick", "text", "tone", "Delay", "ms", "key", "concat", "overflow", "CommandList", "activeItemDataAttr", "ariaLabel", "canReceiveFocus", "focusRingOffset", "inputElement", "itemHeight", "onEndReached", "onlyShowSelectionWhenActive", "overscan", "paddingBottom", "wrapAround", "PaneContent", "DocumentListPaneHeader", "memo", "_ref2", "contentAfter", "initialValueTemplates", "menuItemGroups", "menuItems", "setLayout", "setSortOrder", "title", "features", "useDeskTool", "isLast", "tabIndex", "actionHandlers", "_ref3", "sort", "PaneHeader", "actions", "PaneHeaderActions", "initialValueTemplateItems", "backButton", "BackLink", "ArrowLeftIcon", "mode", "displayName", "listenSearchQuery", "options", "client", "limit", "searchQuery", "staticTypeNames", "sortBy", "extendedProjection", "events$", "defer", "listen", "events", "includeResult", "visibility", "pipe", "mergeMap", "ev", "i", "isFirst", "throwError", "Error", "share", "welcome$", "mutationAndReconnect$", "partition", "merge", "take", "throttleTime", "asyncScheduler", "leading", "trailing", "exhaustMapWithTrailing", "event", "typeNames$", "observable", "fetch", "typeNames", "types", "flatMap", "searchTerms", "query", "searchOptions", "__unstable_extendedProjection", "comments", "createdQuery", "createdParams", "createSearchQuery", "doFetch", "EMPTY_ARRAY", "INITIAL_STATE", "result", "INITIAL_QUERY_RESULTS", "useDocumentList", "opts", "paramsProp", "sortOrder", "apiVersion", "useClient", "DEFAULT_STUDIO_CLIENT_OPTIONS", "resultState", "setResult", "setIsLazyLoading", "hasFullList", "setHasFullList", "shouldFetchFullList", "setShouldFetchFullList", "typeNameFromFilter", "handleSetResult", "res", "documentsLength", "isLoadingMoreItems", "prev", "queryResults$", "onRetry$", "Subject", "_onRetry", "next", "results", "startWith", "catchError", "err", "ProgressEvent", "caught$", "fromEvent", "window", "scan", "sub", "subscribe", "unsubscribe", "reset", "isSearchReady", "_c", "rotate", "keyframes", "AnimatedSpinnerIcon", "SpinnerIcon", "SearchCard", "useShallowUnique", "valueRef", "useRef", "shallowEquals", "addSelectedStateToMenuItems", "sortOrderRaw", "_d", "isEqual", "DocumentListPane", "pane", "paneKey", "parentSourceName", "useSource", "defaultLayout", "displayOptions", "defaultOrdering", "sourceName", "source", "typeName", "useDeskToolSetting", "setSearchQuery", "searchInputValue", "setSearchInputValue", "setSearchInputElement", "showSearchLoadingRef", "defaultSortOrder", "sortWithOrderingFn", "useUnique", "menuItemsWithSelectedState", "handleQueryChange", "useObservableCallback", "event$", "target", "tap", "debounce", "handleClearSearch", "handleSearchKeyDown", "searchInput", "radius", "TextInput", "autoComplete", "border", "clearButton", "Boolean", "disabled", "fontSize", "SearchIcon", "onChange", "onClear", "onKeyDown", "placeholder", "ref", "spellCheck", "SourceProvider", "Pane", "currentMaxWidth", "maxWidth", "minWidth", "_DEBUG"]
}
