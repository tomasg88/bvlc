import {
  BackLink,
  ChildLink,
  DOCUMENT_INSPECTOR_MAX_WIDTH,
  DOCUMENT_INSPECTOR_MIN_WIDTH,
  DOCUMENT_PANEL_INITIAL_MIN_WIDTH,
  DOCUMENT_PANEL_MIN_WIDTH,
  DOCUMENT_PANEL_PORTAL_ELEMENT,
  Delay,
  DeskToolProvider,
  DocTitle,
  DocumentPaneProvider,
  HistoryRestoreAction,
  LOADING_PANE,
  PANE_COLLAPSED_WIDTH,
  PANE_DEFAULT_MIN_WIDTH,
  Pane,
  PaneContent,
  PaneContextMenuButton,
  PaneFooter,
  PaneHeader,
  PaneHeaderActionButton,
  PaneLayoutContext,
  PaneRouterContext,
  ParameterizedLink,
  ReferenceChildLink,
  Resizable,
  Root$9,
  SerializeError,
  TimelineMenu,
  isMenuNodeButton,
  isNotMenuNodeButton,
  require_camelCase,
  require_isNumber,
  require_kebabCase,
  resolveMenuNodes,
  setActivePanes,
  useDeskTool,
  useDocumentPane,
  usePane,
  usePaneLayout,
  usePaneRouter
} from "./chunk-Y3U5344O.js";
import {
  Ae,
  ArrowLeftIcon,
  Badge,
  BoundaryElementProvider,
  Box,
  Button,
  Card,
  ChangeConnectorRoot,
  ChevronDownIcon,
  CloseIcon,
  Code,
  Container,
  Dialog,
  DialogProvider,
  ErrorBoundary,
  Flex,
  FormBuilder,
  GetHookCollectionState,
  Grid,
  Heading,
  Hotkeys,
  Inline,
  Label,
  LayerProvider,
  LegacyLayerProvider,
  Menu,
  MenuButton,
  MenuItem,
  NEVER,
  PlayIcon,
  Popover,
  PortalProvider,
  PresenceOverlay,
  PublishIcon,
  ReadOnlyIcon,
  ReferenceInputOptionsProvider,
  ReplaySubject,
  ScrollContainer,
  SearchIcon,
  SourceProvider,
  Spinner,
  SplitVerticalIcon,
  Stack,
  SyncIcon,
  Tab,
  TabList,
  TabPanel,
  Text,
  TextInput,
  Tooltip,
  VirtualizerScrollInstanceProvider,
  WarningOutlineIcon,
  We,
  _isCustomDocumentTypeDefinition,
  _raf2,
  concat,
  createPatchChannel,
  debounceTime,
  delay,
  distinctUntilChanged,
  firstValueFrom,
  focusFirstDescendant,
  from,
  fromMutationPatches,
  fromString,
  generateHelpUrl,
  get,
  getPublishedId,
  isDev,
  isObservable,
  isRecord$4,
  isString,
  map,
  mapTo,
  merge,
  motion,
  nanoid,
  of,
  pairwise,
  publishReplay,
  refCount,
  rem,
  require_find,
  require_isEqual,
  require_isString,
  require_lib,
  require_omit,
  require_pickBy,
  require_react_is,
  require_speakingurl,
  require_startCase,
  require_uniq,
  require_uniqueId,
  scan,
  startWith,
  styled_components_browser_esm_default,
  switchMap,
  tap,
  toString,
  useClickOutside,
  useCurrentUser,
  useDocumentOperation,
  useDocumentOperationEvent,
  useDocumentPresence,
  useDocumentPreview,
  useDocumentPreviewStore,
  useDocumentStore,
  useDocumentType,
  useEditState,
  useElementRect,
  useFieldActions,
  useGlobalKeyDown,
  useLayer,
  useMemoObservable,
  usePortal,
  useRouter,
  useRouterState,
  useSchema,
  useSettingsStore,
  useSource,
  useSyncState,
  useTemplatePermissions,
  useTemplates,
  useTheme,
  useTimeAgo,
  useTimelineSelector,
  useToast,
  useWorkspace,
  useZIndex,
  v4_default
} from "./chunk-O6KNGBUF.js";
import {
  require_jsx_runtime
} from "./chunk-W7O3NKM5.js";
import {
  require_object_assign
} from "./chunk-ZQMTLKGR.js";
import {
  require_react
} from "./chunk-Z7L3MLVS.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/create-react-class/factory.js
var require_factory = __commonJS({
  "node_modules/create-react-class/factory.js"(exports, module) {
    "use strict";
    var _assign = require_object_assign();
    var emptyObject = {};
    if (true) {
      Object.freeze(emptyObject);
    }
    var validateFormat = function validateFormat2(format) {
    };
    if (true) {
      validateFormat = function validateFormat2(format) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      };
    }
    function _invariant(condition, format, a, b, c, d, e, f) {
      validateFormat(format);
      if (!condition) {
        var error;
        if (format === void 0) {
          error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    }
    var warning = function() {
    };
    if (true) {
      printWarning = function printWarning2(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var argIndex = 0;
        var message = "Warning: " + format.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
      warning = function warning2(condition, format) {
        if (format === void 0) {
          throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
        }
        if (format.indexOf("Failed Composite propType: ") === 0) {
          return;
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }
          printWarning.apply(void 0, [format].concat(args));
        }
      };
    }
    var printWarning;
    var MIXINS_KEY = "mixins";
    function identity(fn) {
      return fn;
    }
    var ReactPropTypeLocationNames;
    if (true) {
      ReactPropTypeLocationNames = {
        prop: "prop",
        context: "context",
        childContext: "child context"
      };
    } else {
      ReactPropTypeLocationNames = {};
    }
    function factory(ReactComponent, isValidElement2, ReactNoopUpdateQueue) {
      var injectedMixins = [];
      var ReactClassInterface = {
        /**
         * An array of Mixin objects to include when defining your component.
         *
         * @type {array}
         * @optional
         */
        mixins: "DEFINE_MANY",
        /**
         * An object containing properties and methods that should be defined on
         * the component's constructor instead of its prototype (static methods).
         *
         * @type {object}
         * @optional
         */
        statics: "DEFINE_MANY",
        /**
         * Definition of prop types for this component.
         *
         * @type {object}
         * @optional
         */
        propTypes: "DEFINE_MANY",
        /**
         * Definition of context types for this component.
         *
         * @type {object}
         * @optional
         */
        contextTypes: "DEFINE_MANY",
        /**
         * Definition of context types this component sets for its children.
         *
         * @type {object}
         * @optional
         */
        childContextTypes: "DEFINE_MANY",
        // ==== Definition methods ====
        /**
         * Invoked when the component is mounted. Values in the mapping will be set on
         * `this.props` if that prop is not specified (i.e. using an `in` check).
         *
         * This method is invoked before `getInitialState` and therefore cannot rely
         * on `this.state` or use `this.setState`.
         *
         * @return {object}
         * @optional
         */
        getDefaultProps: "DEFINE_MANY_MERGED",
        /**
         * Invoked once before the component is mounted. The return value will be used
         * as the initial value of `this.state`.
         *
         *   getInitialState: function() {
         *     return {
         *       isOn: false,
         *       fooBaz: new BazFoo()
         *     }
         *   }
         *
         * @return {object}
         * @optional
         */
        getInitialState: "DEFINE_MANY_MERGED",
        /**
         * @return {object}
         * @optional
         */
        getChildContext: "DEFINE_MANY_MERGED",
        /**
         * Uses props from `this.props` and state from `this.state` to render the
         * structure of the component.
         *
         * No guarantees are made about when or how often this method is invoked, so
         * it must not have side effects.
         *
         *   render: function() {
         *     var name = this.props.name;
         *     return <div>Hello, {name}!</div>;
         *   }
         *
         * @return {ReactComponent}
         * @required
         */
        render: "DEFINE_ONCE",
        // ==== Delegate methods ====
        /**
         * Invoked when the component is initially created and about to be mounted.
         * This may have side effects, but any external subscriptions or data created
         * by this method must be cleaned up in `componentWillUnmount`.
         *
         * @optional
         */
        componentWillMount: "DEFINE_MANY",
        /**
         * Invoked when the component has been mounted and has a DOM representation.
         * However, there is no guarantee that the DOM node is in the document.
         *
         * Use this as an opportunity to operate on the DOM when the component has
         * been mounted (initialized and rendered) for the first time.
         *
         * @param {DOMElement} rootNode DOM element representing the component.
         * @optional
         */
        componentDidMount: "DEFINE_MANY",
        /**
         * Invoked before the component receives new props.
         *
         * Use this as an opportunity to react to a prop transition by updating the
         * state using `this.setState`. Current props are accessed via `this.props`.
         *
         *   componentWillReceiveProps: function(nextProps, nextContext) {
         *     this.setState({
         *       likesIncreasing: nextProps.likeCount > this.props.likeCount
         *     });
         *   }
         *
         * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
         * transition may cause a state change, but the opposite is not true. If you
         * need it, you are probably looking for `componentWillUpdate`.
         *
         * @param {object} nextProps
         * @optional
         */
        componentWillReceiveProps: "DEFINE_MANY",
        /**
         * Invoked while deciding if the component should be updated as a result of
         * receiving new props, state and/or context.
         *
         * Use this as an opportunity to `return false` when you're certain that the
         * transition to the new props/state/context will not require a component
         * update.
         *
         *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
         *     return !equal(nextProps, this.props) ||
         *       !equal(nextState, this.state) ||
         *       !equal(nextContext, this.context);
         *   }
         *
         * @param {object} nextProps
         * @param {?object} nextState
         * @param {?object} nextContext
         * @return {boolean} True if the component should update.
         * @optional
         */
        shouldComponentUpdate: "DEFINE_ONCE",
        /**
         * Invoked when the component is about to update due to a transition from
         * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
         * and `nextContext`.
         *
         * Use this as an opportunity to perform preparation before an update occurs.
         *
         * NOTE: You **cannot** use `this.setState()` in this method.
         *
         * @param {object} nextProps
         * @param {?object} nextState
         * @param {?object} nextContext
         * @param {ReactReconcileTransaction} transaction
         * @optional
         */
        componentWillUpdate: "DEFINE_MANY",
        /**
         * Invoked when the component's DOM representation has been updated.
         *
         * Use this as an opportunity to operate on the DOM when the component has
         * been updated.
         *
         * @param {object} prevProps
         * @param {?object} prevState
         * @param {?object} prevContext
         * @param {DOMElement} rootNode DOM element representing the component.
         * @optional
         */
        componentDidUpdate: "DEFINE_MANY",
        /**
         * Invoked when the component is about to be removed from its parent and have
         * its DOM representation destroyed.
         *
         * Use this as an opportunity to deallocate any external resources.
         *
         * NOTE: There is no `componentDidUnmount` since your component will have been
         * destroyed by that point.
         *
         * @optional
         */
        componentWillUnmount: "DEFINE_MANY",
        /**
         * Replacement for (deprecated) `componentWillMount`.
         *
         * @optional
         */
        UNSAFE_componentWillMount: "DEFINE_MANY",
        /**
         * Replacement for (deprecated) `componentWillReceiveProps`.
         *
         * @optional
         */
        UNSAFE_componentWillReceiveProps: "DEFINE_MANY",
        /**
         * Replacement for (deprecated) `componentWillUpdate`.
         *
         * @optional
         */
        UNSAFE_componentWillUpdate: "DEFINE_MANY",
        // ==== Advanced methods ====
        /**
         * Updates the component's currently mounted DOM representation.
         *
         * By default, this implements React's rendering and reconciliation algorithm.
         * Sophisticated clients may wish to override this.
         *
         * @param {ReactReconcileTransaction} transaction
         * @internal
         * @overridable
         */
        updateComponent: "OVERRIDE_BASE"
      };
      var ReactClassStaticInterface = {
        /**
         * This method is invoked after a component is instantiated and when it
         * receives new props. Return an object to update state in response to
         * prop changes. Return null to indicate no change to state.
         *
         * If an object is returned, its keys will be merged into the existing state.
         *
         * @return {object || null}
         * @optional
         */
        getDerivedStateFromProps: "DEFINE_MANY_MERGED"
      };
      var RESERVED_SPEC_KEYS = {
        displayName: function(Constructor, displayName) {
          Constructor.displayName = displayName;
        },
        mixins: function(Constructor, mixins) {
          if (mixins) {
            for (var i = 0; i < mixins.length; i++) {
              mixSpecIntoComponent(Constructor, mixins[i]);
            }
          }
        },
        childContextTypes: function(Constructor, childContextTypes) {
          if (true) {
            validateTypeDef(Constructor, childContextTypes, "childContext");
          }
          Constructor.childContextTypes = _assign(
            {},
            Constructor.childContextTypes,
            childContextTypes
          );
        },
        contextTypes: function(Constructor, contextTypes) {
          if (true) {
            validateTypeDef(Constructor, contextTypes, "context");
          }
          Constructor.contextTypes = _assign(
            {},
            Constructor.contextTypes,
            contextTypes
          );
        },
        /**
         * Special case getDefaultProps which should move into statics but requires
         * automatic merging.
         */
        getDefaultProps: function(Constructor, getDefaultProps) {
          if (Constructor.getDefaultProps) {
            Constructor.getDefaultProps = createMergedResultFunction(
              Constructor.getDefaultProps,
              getDefaultProps
            );
          } else {
            Constructor.getDefaultProps = getDefaultProps;
          }
        },
        propTypes: function(Constructor, propTypes) {
          if (true) {
            validateTypeDef(Constructor, propTypes, "prop");
          }
          Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
        },
        statics: function(Constructor, statics) {
          mixStaticSpecIntoComponent(Constructor, statics);
        },
        autobind: function() {
        }
      };
      function validateTypeDef(Constructor, typeDef, location) {
        for (var propName in typeDef) {
          if (typeDef.hasOwnProperty(propName)) {
            if (true) {
              warning(
                typeof typeDef[propName] === "function",
                "%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.",
                Constructor.displayName || "ReactClass",
                ReactPropTypeLocationNames[location],
                propName
              );
            }
          }
        }
      }
      function validateMethodOverride(isAlreadyDefined, name) {
        var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
        if (ReactClassMixin.hasOwnProperty(name)) {
          _invariant(
            specPolicy === "OVERRIDE_BASE",
            "ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.",
            name
          );
        }
        if (isAlreadyDefined) {
          _invariant(
            specPolicy === "DEFINE_MANY" || specPolicy === "DEFINE_MANY_MERGED",
            "ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.",
            name
          );
        }
      }
      function mixSpecIntoComponent(Constructor, spec) {
        if (!spec) {
          if (true) {
            var typeofSpec = typeof spec;
            var isMixinValid = typeofSpec === "object" && spec !== null;
            if (true) {
              warning(
                isMixinValid,
                "%s: You're attempting to include a mixin that is either null or not an object. Check the mixins included by the component, as well as any mixins they include themselves. Expected object but got %s.",
                Constructor.displayName || "ReactClass",
                spec === null ? null : typeofSpec
              );
            }
          }
          return;
        }
        _invariant(
          typeof spec !== "function",
          "ReactClass: You're attempting to use a component class or function as a mixin. Instead, just use a regular object."
        );
        _invariant(
          !isValidElement2(spec),
          "ReactClass: You're attempting to use a component as a mixin. Instead, just use a regular object."
        );
        var proto = Constructor.prototype;
        var autoBindPairs = proto.__reactAutoBindPairs;
        if (spec.hasOwnProperty(MIXINS_KEY)) {
          RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
        }
        for (var name in spec) {
          if (!spec.hasOwnProperty(name)) {
            continue;
          }
          if (name === MIXINS_KEY) {
            continue;
          }
          var property = spec[name];
          var isAlreadyDefined = proto.hasOwnProperty(name);
          validateMethodOverride(isAlreadyDefined, name);
          if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
            RESERVED_SPEC_KEYS[name](Constructor, property);
          } else {
            var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
            var isFunction = typeof property === "function";
            var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
            if (shouldAutoBind) {
              autoBindPairs.push(name, property);
              proto[name] = property;
            } else {
              if (isAlreadyDefined) {
                var specPolicy = ReactClassInterface[name];
                _invariant(
                  isReactClassMethod && (specPolicy === "DEFINE_MANY_MERGED" || specPolicy === "DEFINE_MANY"),
                  "ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.",
                  specPolicy,
                  name
                );
                if (specPolicy === "DEFINE_MANY_MERGED") {
                  proto[name] = createMergedResultFunction(proto[name], property);
                } else if (specPolicy === "DEFINE_MANY") {
                  proto[name] = createChainedFunction(proto[name], property);
                }
              } else {
                proto[name] = property;
                if (true) {
                  if (typeof property === "function" && spec.displayName) {
                    proto[name].displayName = spec.displayName + "_" + name;
                  }
                }
              }
            }
          }
        }
      }
      function mixStaticSpecIntoComponent(Constructor, statics) {
        if (!statics) {
          return;
        }
        for (var name in statics) {
          var property = statics[name];
          if (!statics.hasOwnProperty(name)) {
            continue;
          }
          var isReserved = name in RESERVED_SPEC_KEYS;
          _invariant(
            !isReserved,
            'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.',
            name
          );
          var isAlreadyDefined = name in Constructor;
          if (isAlreadyDefined) {
            var specPolicy = ReactClassStaticInterface.hasOwnProperty(name) ? ReactClassStaticInterface[name] : null;
            _invariant(
              specPolicy === "DEFINE_MANY_MERGED",
              "ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.",
              name
            );
            Constructor[name] = createMergedResultFunction(Constructor[name], property);
            return;
          }
          Constructor[name] = property;
        }
      }
      function mergeIntoWithNoDuplicateKeys(one, two) {
        _invariant(
          one && two && typeof one === "object" && typeof two === "object",
          "mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects."
        );
        for (var key in two) {
          if (two.hasOwnProperty(key)) {
            _invariant(
              one[key] === void 0,
              "mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.",
              key
            );
            one[key] = two[key];
          }
        }
        return one;
      }
      function createMergedResultFunction(one, two) {
        return function mergedResult() {
          var a = one.apply(this, arguments);
          var b = two.apply(this, arguments);
          if (a == null) {
            return b;
          } else if (b == null) {
            return a;
          }
          var c = {};
          mergeIntoWithNoDuplicateKeys(c, a);
          mergeIntoWithNoDuplicateKeys(c, b);
          return c;
        };
      }
      function createChainedFunction(one, two) {
        return function chainedFunction() {
          one.apply(this, arguments);
          two.apply(this, arguments);
        };
      }
      function bindAutoBindMethod(component, method) {
        var boundMethod = method.bind(component);
        if (true) {
          boundMethod.__reactBoundContext = component;
          boundMethod.__reactBoundMethod = method;
          boundMethod.__reactBoundArguments = null;
          var componentName = component.constructor.displayName;
          var _bind = boundMethod.bind;
          boundMethod.bind = function(newThis) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            if (newThis !== component && newThis !== null) {
              if (true) {
                warning(
                  false,
                  "bind(): React component methods may only be bound to the component instance. See %s",
                  componentName
                );
              }
            } else if (!args.length) {
              if (true) {
                warning(
                  false,
                  "bind(): You are binding a component method to the component. React does this for you automatically in a high-performance way, so you can safely remove this call. See %s",
                  componentName
                );
              }
              return boundMethod;
            }
            var reboundMethod = _bind.apply(boundMethod, arguments);
            reboundMethod.__reactBoundContext = component;
            reboundMethod.__reactBoundMethod = method;
            reboundMethod.__reactBoundArguments = args;
            return reboundMethod;
          };
        }
        return boundMethod;
      }
      function bindAutoBindMethods(component) {
        var pairs = component.__reactAutoBindPairs;
        for (var i = 0; i < pairs.length; i += 2) {
          var autoBindKey = pairs[i];
          var method = pairs[i + 1];
          component[autoBindKey] = bindAutoBindMethod(component, method);
        }
      }
      var IsMountedPreMixin = {
        componentDidMount: function() {
          this.__isMounted = true;
        }
      };
      var IsMountedPostMixin = {
        componentWillUnmount: function() {
          this.__isMounted = false;
        }
      };
      var ReactClassMixin = {
        /**
         * TODO: This will be deprecated because state should always keep a consistent
         * type signature and the only use case for this, is to avoid that.
         */
        replaceState: function(newState, callback) {
          this.updater.enqueueReplaceState(this, newState, callback);
        },
        /**
         * Checks whether or not this composite component is mounted.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function() {
          if (true) {
            warning(
              this.__didWarnIsMounted,
              "%s: isMounted is deprecated. Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.",
              this.constructor && this.constructor.displayName || this.name || "Component"
            );
            this.__didWarnIsMounted = true;
          }
          return !!this.__isMounted;
        }
      };
      var ReactClassComponent = function() {
      };
      _assign(
        ReactClassComponent.prototype,
        ReactComponent.prototype,
        ReactClassMixin
      );
      function createClass(spec) {
        var Constructor = identity(function(props, context, updater) {
          if (true) {
            warning(
              this instanceof Constructor,
              "Something is calling a React component directly. Use a factory or JSX instead. See: https://fb.me/react-legacyfactory"
            );
          }
          if (this.__reactAutoBindPairs.length) {
            bindAutoBindMethods(this);
          }
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
          this.state = null;
          var initialState = this.getInitialState ? this.getInitialState() : null;
          if (true) {
            if (initialState === void 0 && this.getInitialState._isMockFunction) {
              initialState = null;
            }
          }
          _invariant(
            typeof initialState === "object" && !Array.isArray(initialState),
            "%s.getInitialState(): must return an object or null",
            Constructor.displayName || "ReactCompositeComponent"
          );
          this.state = initialState;
        });
        Constructor.prototype = new ReactClassComponent();
        Constructor.prototype.constructor = Constructor;
        Constructor.prototype.__reactAutoBindPairs = [];
        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
        mixSpecIntoComponent(Constructor, IsMountedPreMixin);
        mixSpecIntoComponent(Constructor, spec);
        mixSpecIntoComponent(Constructor, IsMountedPostMixin);
        if (Constructor.getDefaultProps) {
          Constructor.defaultProps = Constructor.getDefaultProps();
        }
        if (true) {
          if (Constructor.getDefaultProps) {
            Constructor.getDefaultProps.isReactClassApproved = {};
          }
          if (Constructor.prototype.getInitialState) {
            Constructor.prototype.getInitialState.isReactClassApproved = {};
          }
        }
        _invariant(
          Constructor.prototype.render,
          "createClass(...): Class specification must implement a `render` method."
        );
        if (true) {
          warning(
            !Constructor.prototype.componentShouldUpdate,
            "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
            spec.displayName || "A component"
          );
          warning(
            !Constructor.prototype.componentWillRecieveProps,
            "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
            spec.displayName || "A component"
          );
          warning(
            !Constructor.prototype.UNSAFE_componentWillRecieveProps,
            "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
            spec.displayName || "A component"
          );
        }
        for (var methodName in ReactClassInterface) {
          if (!Constructor.prototype[methodName]) {
            Constructor.prototype[methodName] = null;
          }
        }
        return Constructor;
      }
      return createClass;
    }
    module.exports = factory;
  }
});

// node_modules/create-react-class/index.js
var require_create_react_class = __commonJS({
  "node_modules/create-react-class/index.js"(exports, module) {
    "use strict";
    var React2 = require_react();
    var factory = require_factory();
    if (typeof React2 === "undefined") {
      throw Error(
        "create-react-class could not find the React object. If you are using script tags, make sure that React is being loaded before create-react-class."
      );
    }
    var ReactNoopUpdateQueue = new React2.Component().updater;
    module.exports = factory(
      React2.Component,
      React2.isValidElement,
      ReactNoopUpdateQueue
    );
  }
});

// node_modules/date-now/index.js
var require_date_now = __commonJS({
  "node_modules/date-now/index.js"(exports, module) {
    module.exports = Date.now || now;
    function now() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
  }
});

// node_modules/debounce/index.js
var require_debounce = __commonJS({
  "node_modules/debounce/index.js"(exports, module) {
    var now = require_date_now();
    module.exports = function debounce(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      if (null == wait)
        wait = 100;
      function later() {
        var last = now() - timestamp;
        if (last < wait && last > 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            if (!timeout)
              context = args = null;
          }
        }
      }
      ;
      return function debounced() {
        context = this;
        args = arguments;
        timestamp = now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }
        return result;
      };
    };
  }
});

// node_modules/md5-o-matic/lib/md5omatic.js
var require_md5omatic = __commonJS({
  "node_modules/md5-o-matic/lib/md5omatic.js"(exports, module) {
    "use strict";
    module.exports = md5omatic;
    function md5omatic(str) {
      var x = str2blks_MD5(str);
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;
      for (var i = 0; i < x.length; i += 16) {
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        a = ff(a, b, c, d, x[i + 0], 7, -680876936);
        d = ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = ff(c, d, a, b, x[i + 10], 17, -42063);
        b = ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = gg(b, c, d, a, x[i + 0], 20, -373897302);
        a = gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = hh(a, b, c, d, x[i + 5], 4, -378558);
        d = hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = hh(d, a, b, c, x[i + 0], 11, -358537222);
        c = hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = ii(a, b, c, d, x[i + 0], 6, -198630844);
        d = ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = addme(a, olda);
        b = addme(b, oldb);
        c = addme(c, oldc);
        d = addme(d, oldd);
      }
      return rhex(a) + rhex(b) + rhex(c) + rhex(d);
    }
    var hex_chr = "0123456789abcdef";
    function bitOR(a, b) {
      var lsb = a & 1 | b & 1;
      var msb31 = a >>> 1 | b >>> 1;
      return msb31 << 1 | lsb;
    }
    function bitXOR(a, b) {
      var lsb = a & 1 ^ b & 1;
      var msb31 = a >>> 1 ^ b >>> 1;
      return msb31 << 1 | lsb;
    }
    function bitAND(a, b) {
      var lsb = a & 1 & (b & 1);
      var msb31 = a >>> 1 & b >>> 1;
      return msb31 << 1 | lsb;
    }
    function addme(x, y) {
      var lsw = (x & 65535) + (y & 65535);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function rhex(num) {
      var str = "";
      var j;
      for (j = 0; j <= 3; j++)
        str += hex_chr.charAt(num >> j * 8 + 4 & 15) + hex_chr.charAt(num >> j * 8 & 15);
      return str;
    }
    function str2blks_MD5(str) {
      var nblk = (str.length + 8 >> 6) + 1;
      var blks = new Array(nblk * 16);
      var i;
      for (i = 0; i < nblk * 16; i++)
        blks[i] = 0;
      for (i = 0; i < str.length; i++)
        blks[i >> 2] |= str.charCodeAt(i) << (str.length * 8 + i) % 4 * 8;
      blks[i >> 2] |= 128 << (str.length * 8 + i) % 4 * 8;
      var l = str.length * 8;
      blks[nblk * 16 - 2] = l & 255;
      blks[nblk * 16 - 2] |= (l >>> 8 & 255) << 8;
      blks[nblk * 16 - 2] |= (l >>> 16 & 255) << 16;
      blks[nblk * 16 - 2] |= (l >>> 24 & 255) << 24;
      return blks;
    }
    function rol(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function cmn(q, a, b, x, s, t) {
      return addme(rol(addme(addme(a, q), addme(x, t)), s), b);
    }
    function ff(a, b, c, d, x, s, t) {
      return cmn(bitOR(bitAND(b, c), bitAND(~b, d)), a, b, x, s, t);
    }
    function gg(a, b, c, d, x, s, t) {
      return cmn(bitOR(bitAND(b, d), bitAND(c, ~d)), a, b, x, s, t);
    }
    function hh(a, b, c, d, x, s, t) {
      return cmn(bitXOR(bitXOR(b, c), d), a, b, x, s, t);
    }
    function ii(a, b, c, d, x, s, t) {
      return cmn(bitXOR(c, bitOR(b, ~d)), a, b, x, s, t);
    }
  }
});

// node_modules/@rexxars/react-json-inspector/lib/uid.js
var require_uid = __commonJS({
  "node_modules/@rexxars/react-json-inspector/lib/uid.js"(exports, module) {
    var id = Math.ceil(Math.random() * 10);
    module.exports = function() {
      return ++id;
    };
  }
});

// node_modules/@rexxars/react-json-inspector/lib/type.js
var require_type = __commonJS({
  "node_modules/@rexxars/react-json-inspector/lib/type.js"(exports, module) {
    module.exports = function(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    };
  }
});

// node_modules/@rexxars/react-json-inspector/lib/is-primitive.js
var require_is_primitive = __commonJS({
  "node_modules/@rexxars/react-json-inspector/lib/is-primitive.js"(exports, module) {
    var type = require_type();
    function isPrimitive(value) {
      var t = type(value);
      return t !== "Object" && t !== "Array";
    }
    module.exports = isPrimitive;
  }
});

// node_modules/@rexxars/react-json-inspector/lib/highlighter.js
var require_highlighter = __commonJS({
  "node_modules/@rexxars/react-json-inspector/lib/highlighter.js"(exports, module) {
    var React2 = require_react();
    var createReactClass = require_create_react_class();
    var h = React2.createElement;
    module.exports = createReactClass({
      getDefaultProps: function() {
        return {
          string: "",
          highlight: ""
        };
      },
      shouldComponentUpdate: function(p) {
        return p.highlight !== this.props.highlight;
      },
      render: function() {
        var p = this.props, highlightStart = p.string.search(p.highlight);
        if (!p.highlight || highlightStart === -1) {
          return h("span", null, p.string);
        }
        var highlightLength = p.highlight.source.length, highlightString = p.string.substr(highlightStart, highlightLength);
        return h(
          "span",
          null,
          p.string.split(p.highlight).map(function(part, index2) {
            return h(
              "span",
              { key: index2 },
              index2 > 0 ? h("span", { className: "json-inspector__hl" }, highlightString) : null,
              part
            );
          })
        );
      }
    });
  }
});

// node_modules/@rexxars/react-json-inspector/lib/leaf.js
var require_leaf = __commonJS({
  "node_modules/@rexxars/react-json-inspector/lib/leaf.js"(exports, module) {
    var React2 = require_react();
    var createReactClass = require_create_react_class();
    var md5omatic = require_md5omatic();
    var uid = require_uid();
    var type = require_type();
    var isPrimitive = require_is_primitive();
    var Highlighter = require_highlighter();
    var h = React2.createElement;
    var PATH_PREFIX = ".root.";
    var Leaf = createReactClass({
      getInitialState: function() {
        return {
          expanded: this._isInitiallyExpanded(this.props)
        };
      },
      getDefaultProps: function() {
        return {
          root: false,
          prefix: ""
        };
      },
      render: function() {
        var id = "id_" + uid();
        var p = this.props;
        var d = {
          path: this.keypath(),
          key: p.label.toString(),
          value: p.data
        };
        var onLabelClick = this._onClick.bind(this, d);
        return h(
          "div",
          { className: this.getClassName(), id: "leaf-" + this._rootPath() },
          h("input", { className: "json-inspector__radio", type: "radio", name: p.id, id, tabIndex: -1 }),
          h(
            "label",
            { className: "json-inspector__line", htmlFor: id, onClick: onLabelClick },
            h(
              "div",
              { className: "json-inspector__flatpath" },
              d.path
            ),
            h(
              "span",
              { className: "json-inspector__key" },
              this.format(d.key),
              ":",
              this.renderInteractiveLabel(d.key, true)
            ),
            this.renderTitle(),
            this.renderShowOriginalButton()
          ),
          this.renderChildren()
        );
      },
      renderTitle: function() {
        var data = this.data();
        var t = type(data);
        switch (t) {
          case "Array":
            var length = data.length;
            return h(
              "span",
              { className: "json-inspector__value json-inspector__value_helper" },
              (length > 0 ? "[…] " : "[] ") + items(length)
            );
          case "Object":
            var keys = Object.keys(data).length;
            return h(
              "span",
              { className: "json-inspector__value json-inspector__value_helper" },
              (keys > 0 ? "{…} " : "{} ") + properties(keys)
            );
          default:
            return h(
              "span",
              { className: "json-inspector__value json-inspector__value_" + t.toLowerCase() },
              this.format(String(data)),
              this.renderInteractiveLabel(data, false)
            );
        }
      },
      renderChildren: function() {
        var p = this.props;
        var childPrefix = this._rootPath();
        var data = this.data();
        if (this.state.expanded && !isPrimitive(data)) {
          return Object.keys(data).map(function(key) {
            var value = data[key];
            var shouldGetOriginal = !this.state.original || (p.verboseShowOriginal ? p.query : false);
            return h(Leaf, {
              data: value,
              label: key,
              prefix: childPrefix,
              onClick: p.onClick,
              id: p.id,
              query: p.query,
              getOriginal: shouldGetOriginal ? p.getOriginal : null,
              key: getLeafKey(key, value),
              isExpanded: p.isExpanded,
              interactiveLabel: p.interactiveLabel,
              verboseShowOriginal: p.verboseShowOriginal
            });
          }, this);
        }
        return null;
      },
      renderShowOriginalButton: function() {
        var p = this.props;
        if (isPrimitive(p.data) || this.state.original || !p.getOriginal || !p.query || contains(this.keypath(), p.query)) {
          return null;
        }
        return h("span", {
          className: "json-inspector__show-original",
          onClick: this._onShowOriginalClick
        });
      },
      renderInteractiveLabel: function(originalValue, isKey) {
        if (typeof this.props.interactiveLabel === "function") {
          return h(this.props.interactiveLabel, {
            // The distinction between `value` and `originalValue` is
            // provided to have backwards compatibility.
            value: String(originalValue),
            originalValue,
            isKey,
            keypath: this.keypath()
          });
        }
        return null;
      },
      componentWillReceiveProps: function(p) {
        if (p.query) {
          this.setState({
            expanded: !contains(p.label, p.query)
          });
        }
        if (this.props.query && !p.query) {
          this.setState({
            expanded: this._isInitiallyExpanded(p)
          });
        }
      },
      _rootPath: function() {
        return this.props.prefix + "." + this.props.label;
      },
      keypath: function() {
        return this._rootPath().substr(PATH_PREFIX.length);
      },
      data: function() {
        return this.state.original || this.props.data;
      },
      format: function(string) {
        return h(Highlighter, {
          string,
          highlight: this.props.query
        });
      },
      getClassName: function() {
        var cn = "json-inspector__leaf";
        if (this.props.root) {
          cn += " json-inspector__leaf_root";
        }
        if (this.state.expanded) {
          cn += " json-inspector__leaf_expanded";
        }
        if (!isPrimitive(this.props.data)) {
          cn += " json-inspector__leaf_composite";
        }
        return cn;
      },
      toggle: function() {
        this.setState({
          expanded: !this.state.expanded
        });
      },
      _onClick: function(data, e) {
        this.toggle();
        this.props.onClick(data);
        e.stopPropagation();
      },
      _onShowOriginalClick: function(e) {
        this.setState({
          original: this.props.getOriginal(this.keypath())
        });
        e.stopPropagation();
      },
      _isInitiallyExpanded: function(p) {
        var keypath = this.keypath();
        if (p.root) {
          return true;
        }
        if (!p.query) {
          return p.isExpanded(keypath, p.data);
        } else {
          return !contains(keypath, p.query) && typeof p.getOriginal === "function";
        }
      }
    });
    function items(count) {
      return count + (count === 1 ? " item" : " items");
    }
    function properties(count) {
      return count + (count === 1 ? " property" : " properties");
    }
    function getLeafKey(key, value) {
      if (isPrimitive(value)) {
        var hash = md5omatic(String(value));
        return key + ":" + hash;
      } else {
        return key + "[" + type(value) + "]";
      }
    }
    function contains(string, substring) {
      return string.indexOf(substring) !== -1;
    }
    module.exports = Leaf;
  }
});

// node_modules/@rexxars/react-json-inspector/lib/noop.js
var require_noop = __commonJS({
  "node_modules/@rexxars/react-json-inspector/lib/noop.js"(exports, module) {
    module.exports = function() {
    };
  }
});

// node_modules/@rexxars/react-json-inspector/lib/search-bar.js
var require_search_bar = __commonJS({
  "node_modules/@rexxars/react-json-inspector/lib/search-bar.js"(exports, module) {
    var React2 = require_react();
    var createReactClass = require_create_react_class();
    var h = React2.createElement;
    var noop = require_noop();
    module.exports = createReactClass({
      getDefaultProps: function() {
        return {
          onChange: noop
        };
      },
      render: function() {
        return h("input", {
          className: "json-inspector__search",
          type: "search",
          placeholder: "Search",
          onChange: this.onChange
        });
      },
      onChange: function(e) {
        this.props.onChange(e.target.value);
      }
    });
  }
});

// node_modules/@rexxars/react-json-inspector/lib/is-empty.js
var require_is_empty = __commonJS({
  "node_modules/@rexxars/react-json-inspector/lib/is-empty.js"(exports, module) {
    module.exports = function(object) {
      return Object.keys(object).length === 0;
    };
  }
});

// node_modules/@rexxars/react-json-inspector/lib/filterer.js
var require_filterer = __commonJS({
  "node_modules/@rexxars/react-json-inspector/lib/filterer.js"(exports, module) {
    var keys = Object.keys;
    var isPrimitive = require_is_primitive();
    var isEmpty = require_is_empty();
    module.exports = function(data, options) {
      options || (options = { cacheResults: true });
      var cache = {};
      return function(query) {
        if (!options.cacheResults) {
          return find(data, query, options);
        }
        var subquery;
        if (!cache[query]) {
          for (var i = query.length - 1; i > 0; i -= 1) {
            subquery = query.substr(0, i);
            if (cache[subquery]) {
              cache[query] = find(cache[subquery], query, options);
              break;
            }
          }
        }
        if (!cache[query]) {
          cache[query] = find(data, query, options);
        }
        return cache[query];
      };
    };
    function find(data, query, options) {
      return keys(data).reduce(function(acc, key) {
        var value = data[key];
        var matches;
        if (isPrimitive(value)) {
          if (contains(query, key, options) || contains(query, value, options)) {
            acc[key] = value;
          }
        } else {
          if (contains(query, key, options)) {
            acc[key] = value;
          } else {
            matches = find(value, query, options);
            if (!isEmpty(matches)) {
              Object.assign(acc, pair(key, matches));
            }
          }
        }
        return acc;
      }, {});
    }
    function contains(query, string, options) {
      if (string) {
        var haystack = String(string);
        var needle = query;
        if (options.ignoreCase) {
          haystack = haystack.toLowerCase();
          needle = needle.toLowerCase();
        }
        return haystack.indexOf(needle) !== -1;
      }
    }
    function pair(key, value) {
      var p = {};
      p[key] = value;
      return p;
    }
  }
});

// node_modules/@rexxars/react-json-inspector/lib/lens.js
var require_lens = __commonJS({
  "node_modules/@rexxars/react-json-inspector/lib/lens.js"(exports, module) {
    var type = require_type();
    var PATH_DELIMITER = ".";
    function lens(data, path) {
      var p = path.split(PATH_DELIMITER);
      var segment = p.shift();
      if (!segment) {
        return data;
      }
      var t = type(data);
      if (t === "Array" && data[integer(segment)]) {
        return lens(data[integer(segment)], p.join(PATH_DELIMITER));
      } else if (t === "Object" && data[segment]) {
        return lens(data[segment], p.join(PATH_DELIMITER));
      }
    }
    function integer(string) {
      return parseInt(string, 10);
    }
    module.exports = lens;
  }
});

// node_modules/@rexxars/react-json-inspector/json-inspector.js
var require_json_inspector = __commonJS({
  "node_modules/@rexxars/react-json-inspector/json-inspector.js"(exports, module) {
    var React2 = require_react();
    var createReactClass = require_create_react_class();
    var debounce = require_debounce();
    var h = React2.createElement;
    var Leaf = require_leaf();
    var SearchBar = require_search_bar();
    var filterer = require_filterer();
    var isEmpty = require_is_empty();
    var lens = require_lens();
    var noop = require_noop();
    module.exports = createReactClass({
      getDefaultProps: function() {
        return {
          data: null,
          search: SearchBar,
          searchOptions: {
            debounceTime: 0
          },
          className: "",
          id: "json-" + Date.now(),
          onClick: noop,
          filterOptions: {
            cacheResults: true,
            ignoreCase: false
          },
          validateQuery: function(query) {
            return query.length >= 2;
          },
          /**
           * Decide whether the leaf node at given `keypath` should be
           * expanded initially.
           * @param  {String} keypath
           * @param  {Any} value
           * @return {Boolean}
           */
          isExpanded: function(keypath, value) {
            return false;
          },
          verboseShowOriginal: false
        };
      },
      getInitialState: function() {
        return {
          query: this.props.query || ""
        };
      },
      render: function() {
        var p = this.props;
        var s = this.state;
        var isQueryValid = s.query !== "" && p.validateQuery(s.query);
        var data = isQueryValid ? s.filterer(s.query) : p.data;
        var isNotFound = isQueryValid && isEmpty(data);
        return h(
          "div",
          { className: "json-inspector " + p.className },
          this.renderToolbar(),
          isNotFound ? h("div", { className: "json-inspector__not-found" }, "Nothing found") : h(Leaf, {
            data,
            onClick: p.onClick,
            id: p.id,
            getOriginal: this.getOriginal,
            query: isQueryValid ? new RegExp(
              s.query,
              p.filterOptions.ignoreCase ? "i" : ""
            ) : null,
            label: "root",
            root: true,
            isExpanded: p.isExpanded,
            interactiveLabel: p.interactiveLabel,
            verboseShowOriginal: p.verboseShowOriginal
          })
        );
      },
      renderToolbar: function() {
        var search = this.props.search;
        if (search) {
          return h(
            "div",
            { className: "json-inspector__toolbar" },
            h(search, {
              onChange: debounce(this.search, this.props.searchOptions.debounceTime),
              data: this.props.data,
              query: this.state.query
            })
          );
        }
      },
      search: function(query) {
        this.setState({
          query
        });
      },
      componentWillMount: function() {
        this.createFilterer(this.props.data, this.props.filterOptions);
      },
      componentWillReceiveProps: function(p) {
        this.createFilterer(p.data, p.filterOptions);
        var isReceivingNewQuery = typeof p.query === "string" && p.query !== this.state.query;
        if (isReceivingNewQuery) {
          this.setState({
            query: p.query
          });
        }
      },
      shouldComponentUpdate: function(p, s) {
        return p.query !== this.props.query || s.query !== this.state.query || p.data !== this.props.data || p.onClick !== this.props.onClick;
      },
      createFilterer: function(data, options) {
        this.setState({
          filterer: filterer(data, options)
        });
      },
      getOriginal: function(path) {
        return lens(this.props.data, path);
      }
    });
  }
});

// node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports, module) {
    module.exports = function(max) {
      if (!max)
        throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value) {
        cache[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache;
          cache = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache[key] !== void 0)
            cache[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache[key];
          if (v !== void 0)
            return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache[key] !== void 0)
            cache[key] = value;
          else
            update(key, value);
        },
        clear: function() {
          cache = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// node_modules/sanity/lib/_chunks/index-dd34e89c.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var import_omit = __toESM(require_omit());
var import_isEqual = __toESM(require_isEqual());
var import_camelCase = __toESM(require_camelCase());
var import_speakingurl = __toESM(require_speakingurl());
var import_uniq = __toESM(require_uniq());
var import_kebabCase = __toESM(require_kebabCase());
var import_pickBy = __toESM(require_pickBy());
var import_find = __toESM(require_find());
var import_uniqueId = __toESM(require_uniqueId());
var import_react_is = __toESM(require_react_is());
var import_startCase = __toESM(require_startCase());
var import_is_hotkey = __toESM(require_lib());
var import_isNumber = __toESM(require_isNumber());
var import_isString = __toESM(require_isString());
var import_react_json_inspector = __toESM(require_json_inspector());
var import_hashlru = __toESM(require_hashlru());
var RenderActionCollectionState = (props) => {
  const {
    actions,
    children,
    actionProps,
    onActionComplete
  } = props;
  return (0, import_jsx_runtime.jsx)(GetHookCollectionState, {
    onReset: onActionComplete,
    hooks: actions,
    args: actionProps,
    children
  });
};
var RenderBadgeCollectionState = (props) => {
  const {
    badges,
    children,
    badgeProps,
    ...rest
  } = props;
  return (0, import_jsx_runtime.jsx)(GetHookCollectionState, {
    ...rest,
    hooks: badges,
    args: badgeProps,
    children
  });
};
var emptyArray = [];
function PaneRouterProvider(props) {
  const {
    children,
    flatIndex,
    index: index2,
    params,
    payload,
    siblingIndex
  } = props;
  const {
    navigate,
    navigateIntent,
    resolvePathFromState
  } = useRouter();
  const routerState = useRouterState();
  const {
    panes,
    expand
  } = usePaneLayout();
  const routerPaneGroups = (0, import_react.useMemo)(() => (routerState == null ? void 0 : routerState.panes) || emptyArray, [routerState == null ? void 0 : routerState.panes]);
  const lastPane = (0, import_react.useMemo)(() => panes == null ? void 0 : panes[panes.length - 2], [panes]);
  const groupIndex = index2 - 1;
  const createNextRouterState = (0, import_react.useCallback)((modifier) => {
    const currentGroup = routerPaneGroups[groupIndex] || [];
    const currentItem = currentGroup[siblingIndex];
    const nextGroup = modifier(currentGroup, currentItem);
    const nextPanes = [...routerPaneGroups.slice(0, groupIndex), nextGroup, ...routerPaneGroups.slice(groupIndex + 1)];
    const nextRouterState = {
      ...routerState || {},
      panes: nextPanes
    };
    return nextRouterState;
  }, [groupIndex, routerPaneGroups, routerState, siblingIndex]);
  const modifyCurrentGroup = (0, import_react.useCallback)((modifier) => {
    const nextRouterState = createNextRouterState(modifier);
    setTimeout(() => navigate(nextRouterState), 0);
    return nextRouterState;
  }, [createNextRouterState, navigate]);
  const createPathWithParams = (0, import_react.useCallback)((nextParams) => {
    const nextRouterState = createNextRouterState((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      params: nextParams
    }, ...siblings.slice(siblingIndex + 1)]);
    return resolvePathFromState(nextRouterState);
  }, [createNextRouterState, resolvePathFromState, siblingIndex]);
  const setPayload = (0, import_react.useCallback)((nextPayload) => {
    modifyCurrentGroup((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      payload: nextPayload
    }, ...siblings.slice(siblingIndex + 1)]);
  }, [modifyCurrentGroup, siblingIndex]);
  const setParams = (0, import_react.useCallback)((nextParams) => {
    modifyCurrentGroup((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      params: nextParams
    }, ...siblings.slice(siblingIndex + 1)]);
  }, [modifyCurrentGroup, siblingIndex]);
  const handleEditReference = (0, import_react.useCallback)((_ref) => {
    let {
      id,
      parentRefPath,
      type,
      template
    } = _ref;
    navigate({
      panes: [...routerPaneGroups.slice(0, groupIndex + 1), [{
        id,
        params: {
          template: template.id,
          parentRefPath: toString(parentRefPath),
          type
        },
        payload: template.params
      }]]
    });
  }, [groupIndex, navigate, routerPaneGroups]);
  const ctx = (0, import_react.useMemo)(() => ({
    // Zero-based index (position) of pane, visually
    index: flatIndex,
    // Zero-based index of pane group (within URL structure)
    groupIndex,
    // Zero-based index of pane within sibling group
    siblingIndex,
    // Payload of the current pane
    payload,
    // Params of the current pane
    params,
    // Whether or not the pane has any siblings (within the same group)
    hasGroupSiblings: routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length > 1 : false,
    // The length of the current group
    groupLength: routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length : 0,
    // Current router state for the "panes" property
    routerPanesState: routerPaneGroups,
    // Curried StateLink that passes the correct state automatically
    ChildLink,
    // Curried StateLink that pops off the last pane group
    BackLink,
    // A specialized `ChildLink` that takes in the needed props to open a
    // referenced document to the right
    ReferenceChildLink,
    // Similar to `ReferenceChildLink` expect without the wrapping component
    handleEditReference,
    // Curried StateLink that passed the correct state, but merges params/payload
    ParameterizedLink,
    // Replaces the current pane with a new one
    replaceCurrent: function() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      modifyCurrentGroup(() => [{
        id: opts.id || "",
        payload: opts.payload,
        params: opts.params || {}
      }]);
    },
    // Removes the current pane from the group
    closeCurrent: () => {
      modifyCurrentGroup((siblings, item) => siblings.length > 1 ? siblings.filter((sibling) => sibling !== item) : siblings);
    },
    // Removes all panes to the right including current
    closeCurrentAndAfter: function() {
      let expandLast = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (expandLast && lastPane) {
        expand(lastPane.element);
      }
      navigate({
        panes: [...routerPaneGroups.slice(0, groupIndex)]
      }, {
        replace: true
      });
    },
    // Duplicate the current pane, with optional overrides for payload, parameters
    duplicateCurrent: (options) => {
      modifyCurrentGroup((siblings, item) => {
        const duplicatedItem = {
          ...item,
          payload: (options == null ? void 0 : options.payload) || item.payload,
          params: (options == null ? void 0 : options.params) || item.params
        };
        return [...siblings.slice(0, siblingIndex), duplicatedItem, ...siblings.slice(siblingIndex)];
      });
    },
    // Set the view for the current pane
    setView: (viewId) => {
      const restParams = (0, import_omit.default)(params, "view");
      return setParams(viewId ? {
        ...restParams,
        view: viewId
      } : restParams);
    },
    // Set the parameters for the current pane
    setParams,
    // Set the payload for the current pane
    setPayload,
    // A function that returns a path with the given parameters
    createPathWithParams,
    // Proxied navigation to a given intent. Consider just exposing `router` instead?
    navigateIntent
  }), [flatIndex, groupIndex, siblingIndex, payload, params, routerPaneGroups, handleEditReference, setParams, setPayload, createPathWithParams, navigateIntent, modifyCurrentGroup, lastPane, navigate, expand]);
  return (0, import_jsx_runtime.jsx)(PaneRouterContext.Provider, {
    value: ctx,
    children
  });
}
function _calcPaneResize(cache, left, right, deltaX) {
  var _a2, _b2;
  const sum = {
    flex: cache.left.flex + cache.right.flex,
    width: cache.left.width + cache.right.width
  };
  const leftMinWidth = (_a2 = left.minWidth) != null ? _a2 : PANE_DEFAULT_MIN_WIDTH;
  const rightMinWidth = (_b2 = right.minWidth) != null ? _b2 : PANE_DEFAULT_MIN_WIDTH;
  const leftMaxWidth = Math.min(left.maxWidth || Infinity, sum.width - rightMinWidth);
  const rightMaxWidth = Math.min(right.maxWidth || Infinity, sum.width - leftMinWidth);
  let minDeltaX = leftMinWidth - cache.left.width;
  const rightMinDeltaX = cache.right.width - rightMaxWidth;
  if (minDeltaX < rightMinDeltaX) {
    minDeltaX = rightMinDeltaX;
  }
  let maxDeltaX = cache.right.width - rightMinWidth;
  const leftMaxDeltaX = leftMaxWidth - cache.left.width;
  if (maxDeltaX > leftMaxDeltaX) {
    maxDeltaX = leftMaxDeltaX;
  }
  const _deltaX = Math.min(Math.max(deltaX, minDeltaX), maxDeltaX);
  const leftW = cache.left.width + _deltaX;
  const rightW = cache.right.width - _deltaX;
  const leftFlex = leftW / sum.width * sum.flex;
  const rightFlex = rightW / sum.width * sum.flex;
  return {
    leftFlex,
    leftW,
    rightFlex,
    rightW
  };
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  while (e !== rootElement) {
    const parentElement = e.parentElement;
    if (!parentElement)
      return path;
    const children = Array.from(parentElement.childNodes);
    const index2 = children.indexOf(e);
    path.unshift(index2);
    if (parentElement === rootElement) {
      return path;
    }
    e = parentElement;
  }
  return path;
}
var EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  const map2 = /* @__PURE__ */ new WeakMap();
  for (const element of elements) {
    map2.set(element, _getDOMPath(rootElement, element));
  }
  const _sortByElementPath = (a, b) => {
    const _a2 = map2.get(a) || EMPTY_PATH;
    const _b2 = map2.get(b) || EMPTY_PATH;
    const len = Math.max(_a2.length, _b2.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a2[i] || -1;
      const bIndex = _b2[i] || -1;
      if (aIndex !== bIndex) {
        return aIndex - bIndex;
      }
    }
    return 0;
  };
  elements.sort(_sortByElementPath);
}
function createPaneLayoutController() {
  const observers = [];
  const elements = [];
  const optionsMap = /* @__PURE__ */ new WeakMap();
  const userCollapsedElementSet = /* @__PURE__ */ new Set();
  const cache = {};
  let rootElement = null;
  let rootWidth = 0;
  let expandedElement = null;
  let resizeDataMap = /* @__PURE__ */ new Map();
  let resizing = false;
  function collapse(element) {
    userCollapsedElementSet.add(element);
    if (expandedElement === element) {
      expandedElement = null;
    }
    _notifyObservers();
  }
  function expand(element) {
    userCollapsedElementSet.delete(element);
    expandedElement = element;
    _notifyObservers();
  }
  function mount(element, options) {
    optionsMap.set(element, {
      ...options,
      original: options
    });
    elements.push(element);
    if (rootElement) {
      _sortElements(rootElement, elements);
    }
    expand(element);
    return () => {
      const idx = elements.indexOf(element);
      if (idx > -1) {
        elements.splice(idx, 1);
      }
      optionsMap.delete(element);
      _notifyObservers();
    };
  }
  function resize(type, leftElement, deltaX) {
    var _a2, _b2, _c2, _d;
    const leftIndex = elements.indexOf(leftElement);
    const leftOptions = optionsMap.get(leftElement);
    if (!leftOptions)
      return;
    const rightElement = elements[leftIndex + 1];
    const rightOptions = optionsMap.get(rightElement);
    if (!rightOptions)
      return;
    if (type === "start") {
      resizing = true;
      cache.left = {
        element: leftElement,
        flex: leftOptions.flex || 1,
        width: leftElement.offsetWidth
      };
      cache.right = {
        element: rightElement,
        flex: rightOptions.flex || 1,
        width: rightElement.offsetWidth
      };
      _notifyObservers();
    }
    if (type === "move" && cache.left && cache.right) {
      resizeDataMap = /* @__PURE__ */ new Map();
      const {
        leftW,
        rightW,
        leftFlex,
        rightFlex
      } = _calcPaneResize(cache, leftOptions, rightOptions, deltaX);
      resizeDataMap.set(leftElement, {
        flex: leftFlex,
        width: leftW
      });
      resizeDataMap.set(rightElement, {
        flex: rightFlex,
        width: rightW
      });
      _notifyObservers();
    }
    if (type === "end") {
      resizing = false;
      const leftResizeData = resizeDataMap.get(leftElement);
      const rightResizeData = resizeDataMap.get(rightElement);
      optionsMap.set(leftElement, {
        ...leftOptions,
        currentMinWidth: 0,
        currentMaxWidth: (_a2 = leftOptions.maxWidth) != null ? _a2 : Infinity,
        flex: (_b2 = leftResizeData == null ? void 0 : leftResizeData.flex) != null ? _b2 : leftOptions.flex
      });
      optionsMap.set(rightElement, {
        ...rightOptions,
        currentMinWidth: 0,
        currentMaxWidth: (_c2 = leftOptions.maxWidth) != null ? _c2 : Infinity,
        flex: (_d = rightResizeData == null ? void 0 : rightResizeData.flex) != null ? _d : rightOptions.flex
      });
      resizeDataMap = /* @__PURE__ */ new Map();
      delete cache.left;
      delete cache.right;
      _notifyObservers();
    }
  }
  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }
  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth;
    _notifyObservers();
  }
  function subscribe(observer) {
    observers.push(observer);
    return () => {
      const idx = observers.push(observer);
      if (idx > -1) {
        observers.splice(idx, 1);
      }
    };
  }
  return {
    collapse,
    expand,
    mount,
    resize,
    setRootElement,
    setRootWidth,
    subscribe
  };
  function _notifyObservers() {
    var _a2, _b2, _c2, _d;
    if (!rootWidth)
      return;
    const _elements = [];
    for (const element of elements) {
      if (element !== expandedElement) {
        _elements.unshift(element);
      }
    }
    if (expandedElement) {
      _elements.unshift(expandedElement);
    }
    const dataMap = /* @__PURE__ */ new WeakMap();
    const len = _elements.length;
    const lastElement = _elements[0];
    const collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;
    for (const element of _elements) {
      const options = optionsMap.get(element);
      if (!options) {
        continue;
      }
      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH;
      const isLast = element === lastElement;
      const userCollapsed = userCollapsedElementSet.has(element);
      const sizeCollapsed = minWidth > remaingWidth;
      const collapsed = isLast ? false : userCollapsed || sizeCollapsed;
      const resizeData = resizeDataMap.get(element);
      dataMap.set(element, {
        element,
        collapsed,
        currentMinWidth: (_a2 = resizeData == null ? void 0 : resizeData.width) != null ? _a2 : options.currentMinWidth,
        currentMaxWidth: (_b2 = resizeData == null ? void 0 : resizeData.width) != null ? _b2 : options.currentMaxWidth,
        flex: (_d = (_c2 = resizeData == null ? void 0 : resizeData.flex) != null ? _c2 : options.flex) != null ? _d : 1
      });
      if (collapsed) {
        remaingWidth -= PANE_COLLAPSED_WIDTH;
      } else {
        remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
      }
    }
    const panes = [];
    for (const element of elements) {
      const data = dataMap.get(element);
      if (data)
        panes.push(data);
    }
    for (const observer of observers) {
      observer({
        expandedElement: expandedElement || elements[elements.length - 1] || null,
        panes,
        resizing
      });
    }
  }
}
function PaneLayout(props) {
  const {
    children,
    minWidth,
    onCollapse,
    onExpand,
    ...restProps
  } = props;
  const controller = (0, import_react.useMemo)(() => createPaneLayoutController(), []);
  const [rootElement, setRootElement] = (0, import_react.useState)(null);
  const rootRect = useElementRect(rootElement);
  const width = (rootRect == null ? void 0 : rootRect.width) || 0;
  const collapsed = width === void 0 || !minWidth ? void 0 : width < minWidth;
  const [state, setState] = (0, import_react.useState)({
    expandedElement: null,
    panes: [],
    resizing: false
  });
  (0, import_react.useEffect)(() => controller.setRootElement(rootElement), [controller, rootElement]);
  (0, import_react.useEffect)(() => controller.setRootWidth(width), [controller, width]);
  (0, import_react.useEffect)(() => controller.subscribe(setState), [controller]);
  (0, import_react.useEffect)(() => {
    if (collapsed === void 0)
      return;
    if (collapsed && onCollapse)
      onCollapse();
    if (!collapsed && onExpand)
      onExpand();
  }, [collapsed, onCollapse, onExpand]);
  const paneLayout = (0, import_react.useMemo)(() => ({
    collapse: controller.collapse,
    collapsed,
    expand: controller.expand,
    expandedElement: state.expandedElement,
    mount: controller.mount,
    panes: state.panes,
    resize: controller.resize,
    resizing: state.resizing
  }), [collapsed, controller, state.expandedElement, state.panes, state.resizing]);
  return (0, import_jsx_runtime.jsx)(PaneLayoutContext.Provider, {
    value: paneLayout,
    children: (0, import_jsx_runtime.jsx)(Root$9, {
      "data-ui": "PaneLayout",
      ...restProps,
      "data-collapsed": collapsed ? "" : void 0,
      "data-resizing": state.resizing ? "" : void 0,
      "data-mounted": width ? "" : void 0,
      ref: setRootElement,
      children
    })
  });
}
function DocumentInspectorPanel(props) {
  const {
    documentId,
    documentType,
    flex
  } = props;
  const {
    collapsed
  } = usePane();
  const {
    closeInspector,
    inspector
  } = useDocumentPane();
  const {
    features
  } = useDeskTool();
  const handleClose = (0, import_react.useCallback)(() => {
    if (inspector)
      closeInspector(inspector.name);
  }, [closeInspector, inspector]);
  if (collapsed || !inspector)
    return null;
  const element = (0, import_react.createElement)(inspector.component, {
    onClose: handleClose,
    documentId,
    documentType
  });
  if (features.resizablePanes) {
    return (0, import_jsx_runtime.jsx)(Resizable, {
      as: "aside",
      "data-ui": "DocumentInspectorPanel",
      flex,
      maxWidth: DOCUMENT_INSPECTOR_MAX_WIDTH,
      minWidth: DOCUMENT_INSPECTOR_MIN_WIDTH,
      children: element
    });
  }
  return (0, import_jsx_runtime.jsx)(Box, {
    as: "aside",
    "data-ui": "DocumentInspectorPanel",
    flex,
    children: element
  });
}
var __defProp$c = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp$c(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var PaneResolutionError = class extends Error {
  constructor(_ref2) {
    let {
      message,
      context,
      helpId,
      cause
    } = _ref2;
    super(message);
    __publicField(this, "cause");
    __publicField(this, "context");
    __publicField(this, "helpId");
    this.context = context;
    this.helpId = helpId;
    this.cause = cause;
  }
};
var randomIdCache = /* @__PURE__ */ new WeakMap();
function assignId(obj) {
  const cachedValue = randomIdCache.get(obj);
  if (cachedValue)
    return cachedValue;
  const id = nanoid();
  randomIdCache.set(obj, id);
  return id;
}
var bindCache = /* @__PURE__ */ new WeakMap();
function memoBind(obj, methodKey) {
  const boundMethods = bindCache.get(obj) || /* @__PURE__ */ new Map();
  if (boundMethods) {
    const bound2 = boundMethods.get(methodKey);
    if (bound2)
      return bound2;
  }
  const method = obj[methodKey];
  if (typeof method !== "function") {
    throw new Error("Expected property `".concat(methodKey, "` to be a function but got ").concat(typeof method, " instead."));
  }
  const bound = method.bind(obj);
  boundMethods.set(methodKey, bound);
  bindCache.set(obj, boundMethods);
  return bound;
}
var isPromise = (thing) => {
  return !!thing && typeof (thing == null ? void 0 : thing.then) === "function";
};
var isSerializable = (thing) => {
  if (!isRecord$4(thing))
    return false;
  return typeof thing.serialize === "function";
};
var rethrowWithPaneResolutionErrors = (next) => (unresolvedPane, context, flatIndex) => {
  try {
    return next(unresolvedPane, context, flatIndex);
  } catch (e) {
    if (e instanceof PaneResolutionError) {
      throw e;
    }
    throw new PaneResolutionError({
      message: typeof (e == null ? void 0 : e.message) === "string" ? e.message : "",
      context,
      cause: e
    });
  }
};
var wrapWithPublishReplay = (next) => function() {
  return next(...arguments).pipe(
    // need to add publishReplay + refCount to ensure new subscribers always
    // get an emission. without this, memoized observables may get stuck
    // waiting for their first emissions resulting in a loading pane
    publishReplay(1),
    refCount()
  );
};
function createPaneResolver(middleware) {
  const resolvePane = rethrowWithPaneResolutionErrors(wrapWithPublishReplay(middleware((unresolvedPane, context, flatIndex) => {
    if (!unresolvedPane) {
      throw new PaneResolutionError({
        message: "Pane returned no child",
        context,
        helpId: "structure-item-returned-no-child"
      });
    }
    if (isPromise(unresolvedPane) || isObservable(unresolvedPane)) {
      return from(unresolvedPane).pipe(switchMap((result) => resolvePane(result, context, flatIndex)));
    }
    if (isSerializable(unresolvedPane)) {
      return resolvePane(unresolvedPane.serialize(context), context, flatIndex);
    }
    if (typeof unresolvedPane === "function") {
      return resolvePane(unresolvedPane(context.id, context), context, flatIndex);
    }
    return of(unresolvedPane);
  })));
  return resolvePane;
}
async function resolveIntent(options) {
  const resolvedPaneCache = /* @__PURE__ */ new Map();
  const memoize = (nextFn) => (unresolvedPane, context, flatIndex) => {
    const key = unresolvedPane && "".concat(assignId(unresolvedPane), "-").concat(context.path.join("__"));
    const cachedResolvedPane = key && resolvedPaneCache.get(key);
    if (cachedResolvedPane)
      return cachedResolvedPane;
    const result = nextFn(unresolvedPane, context, flatIndex);
    if (key)
      resolvedPaneCache.set(key, result);
    return result;
  };
  const resolvePane = createPaneResolver(memoize);
  const fallbackEditorPanes = [[{
    id: "__edit__".concat(options.params.id),
    params: {
      ...(0, import_omit.default)(options.params, ["id"]),
      type: options.params.type
    },
    payload: options.payload
  }]];
  async function traverse(_ref3) {
    let {
      currentId,
      flatIndex,
      intent,
      params,
      parent: parent2,
      path,
      payload,
      unresolvedPane,
      levelIndex,
      structureContext
    } = _ref3;
    var _a2;
    if (!unresolvedPane)
      return [];
    const {
      id: targetId,
      type: schemaTypeName,
      ...otherParams
    } = params;
    const context = {
      id: currentId,
      splitIndex: 0,
      parent: parent2,
      path,
      index: flatIndex,
      params: {},
      payload: void 0,
      structureContext
    };
    const resolvedPane = await firstValueFrom(resolvePane(unresolvedPane, context, flatIndex));
    if (resolvedPane.type === "document" && resolvedPane.id === targetId) {
      return [{
        panes: [...path.slice(0, path.length - 1).map((i) => [{
          id: i
        }]), [{
          id: targetId,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }
    if (
      // if the resolve pane's `canHandleIntent` returns true, then resolve
      ((_a2 = resolvedPane.canHandleIntent) == null ? void 0 : _a2.call(resolvedPane, intent, params, {
        pane: resolvedPane,
        index: flatIndex
      })) || // if the pane's `canHandleIntent` did not return true, then match against
      // this default case. we will resolve the intent if:
      resolvedPane.type === "documentList" && // 1. the schema type matches (this required for the document to render)
      resolvedPane.schemaTypeName === schemaTypeName && // 2. the filter is the default filter.
      //
      // NOTE: this case is to prevent false positive matches where the user
      // has configured a more specific filter for a particular type. In that
      // case, the user can implement their own `canHandleIntent` function
      resolvedPane.options.filter === "_type == $type"
    ) {
      return [{
        panes: [
          // map the current path to router panes
          ...path.map((id) => [{
            id
          }]),
          // then augment with the intents IDs and params
          [{
            id: params.id,
            params: otherParams,
            payload
          }]
        ],
        depthIndex: path.length,
        levelIndex
      }];
    }
    if (resolvedPane.type === "list" && resolvedPane.child && resolvedPane.items) {
      return (await Promise.all(resolvedPane.items.map((item, nextLevelIndex) => {
        if (item.type === "divider")
          return Promise.resolve([]);
        return traverse({
          currentId: item._id || item.id,
          flatIndex: flatIndex + 1,
          intent,
          params,
          parent: resolvedPane,
          path: [...path, item.id],
          payload,
          unresolvedPane: typeof resolvedPane.child === "function" ? memoBind(resolvedPane, "child") : resolvedPane.child,
          levelIndex: nextLevelIndex,
          structureContext
        });
      }))).flat();
    }
    return [];
  }
  const matchingPanes = await traverse({
    currentId: "root",
    flatIndex: 0,
    levelIndex: 0,
    intent: options.intent,
    params: options.params,
    parent: null,
    path: [],
    payload: options.payload,
    unresolvedPane: options.rootPaneNode,
    structureContext: options.structureContext
  });
  const closestPaneToRoot = matchingPanes.sort((a, b) => {
    if (a.depthIndex === b.depthIndex)
      return a.levelIndex - b.levelIndex;
    return a.depthIndex - b.depthIndex;
  })[0];
  if (closestPaneToRoot) {
    return closestPaneToRoot.panes;
  }
  return fallbackEditorPanes;
}
var fallbackEditorChild = (nodeId, context) => {
  const id = nodeId.replace(/^__edit__/, "");
  const {
    params,
    payload,
    structureContext: {
      resolveDocumentNode
    }
  } = context;
  const {
    type,
    template
  } = params;
  if (!type) {
    throw new Error("Document type for document with ID ".concat(id, " was not provided in the router params."));
  }
  let defaultDocumentBuilder = resolveDocumentNode({
    schemaType: type,
    documentId: id
  }).id("editor");
  if (template) {
    defaultDocumentBuilder = defaultDocumentBuilder.initialValueTemplate(template, payload);
  }
  return defaultDocumentBuilder.serialize();
};
function hashContext(context) {
  var _a2, _b2;
  return "contextHash(".concat(JSON.stringify({
    id: context.id,
    parentId: parent && assignId(parent),
    path: context.path,
    index: context.index,
    splitIndex: context.splitIndex,
    serializeOptionsIndex: (_a2 = context.serializeOptions) == null ? void 0 : _a2.index,
    serializeOptionsPath: (_b2 = context.serializeOptions) == null ? void 0 : _b2.path
  }), ")");
}
var hashResolvedPaneMeta = (meta) => {
  const normalized = {
    type: meta.type,
    id: meta.routerPaneSibling.id,
    params: meta.routerPaneSibling.params || {},
    payload: meta.routerPaneSibling.payload || null,
    flatIndex: meta.flatIndex,
    groupIndex: meta.groupIndex,
    siblingIndex: meta.siblingIndex,
    path: meta.path,
    paneNode: meta.type === "resolvedMeta" ? assignId(meta.paneNode) : null
  };
  return "metaHash(".concat(JSON.stringify(normalized), ")");
};
function resolvePaneTree(_ref4) {
  let {
    unresolvedPane,
    flattenedRouterPanes,
    parent: parent2,
    path,
    resolvePane,
    structureContext
  } = _ref4;
  const [current, ...rest] = flattenedRouterPanes;
  const next = rest[0];
  const context = {
    id: current.routerPaneSibling.id,
    splitIndex: current.siblingIndex,
    parent: parent2,
    path: [...path, current.routerPaneSibling.id],
    index: current.flatIndex,
    params: current.routerPaneSibling.params || {},
    payload: current.routerPaneSibling.payload,
    structureContext
  };
  try {
    return resolvePane(unresolvedPane, context, current.flatIndex).pipe(
      // this switch map receives a resolved pane
      switchMap((paneNode) => {
        const resolvedPaneMeta = {
          type: "resolvedMeta",
          ...current,
          paneNode,
          path: context.path
        };
        const loadingPanes = rest.map((i, restIndex) => {
          const loadingPanePath = [...context.path, ...rest.slice(restIndex).map((_, currentIndex) => "[".concat(i.flatIndex + currentIndex, "]"))];
          const loadingPane = {
            type: "loading",
            path: loadingPanePath,
            paneNode: null,
            ...i
          };
          return loadingPane;
        });
        if (!rest.length) {
          return of([resolvedPaneMeta]);
        }
        let nextStream;
        if (
          // the fallback editor case
          next == null ? void 0 : next.routerPaneSibling.id.startsWith("__edit__")
        ) {
          nextStream = resolvePaneTree({
            unresolvedPane: fallbackEditorChild,
            flattenedRouterPanes: rest,
            parent: parent2,
            path: context.path,
            resolvePane,
            structureContext
          });
        } else if (current.groupIndex === (next == null ? void 0 : next.groupIndex)) {
          nextStream = resolvePaneTree({
            unresolvedPane,
            flattenedRouterPanes: rest,
            parent: parent2,
            path,
            resolvePane,
            structureContext
          });
        } else {
          nextStream = resolvePaneTree({
            unresolvedPane: typeof paneNode.child === "function" ? memoBind(paneNode, "child") : paneNode.child,
            flattenedRouterPanes: rest,
            parent: paneNode,
            path: context.path,
            resolvePane,
            structureContext
          });
        }
        return concat(
          // we emit the loading panes first in a concat (this emits immediately)
          of([resolvedPaneMeta, ...loadingPanes]),
          // then whenever the next stream is done, the results will be combined.
          nextStream.pipe(map((nextResolvedPanes) => [resolvedPaneMeta, ...nextResolvedPanes]))
        );
      })
    );
  } catch (e) {
    if (e instanceof PaneResolutionError) {
      if (e.context) {
        console.warn("Pane resolution error at index ".concat(e.context.index).concat(e.context.splitIndex > 0 ? " for split pane index ".concat(e.context.splitIndex) : "", ": ").concat(e.message).concat(e.helpId ? " - see ".concat(generateHelpUrl(e.helpId)) : ""), e);
      }
      if (e.helpId === "structure-item-returned-no-child") {
        return of([]);
      }
    }
    throw e;
  }
}
function createResolvedPaneNodeStream(_ref5) {
  let {
    routerPanesStream,
    rootPaneNode,
    initialCacheState = {
      cacheKeysByFlatIndex: [],
      flattenedRouterPanes: [],
      resolvedPaneCache: /* @__PURE__ */ new Map(),
      resolvePane: () => NEVER
    },
    structureContext
  } = _ref5;
  const resolvedPanes$ = routerPanesStream.pipe(
    // add in implicit "root" router pane
    map((rawRouterPanes) => [[{
      id: "root"
    }], ...rawRouterPanes]),
    // create flattened router panes
    map((routerPanes) => {
      const flattenedRouterPanes = routerPanes.flatMap((routerPaneGroup, groupIndex) => routerPaneGroup.map((routerPaneSibling, siblingIndex) => ({
        routerPaneSibling,
        groupIndex,
        siblingIndex
      }))).map((i, index2) => ({
        ...i,
        flatIndex: index2
      }));
      return flattenedRouterPanes;
    }),
    // calculate a "diffIndex" used for clearing the memo cache
    startWith([]),
    pairwise(),
    map((_ref6) => {
      let [prev, curr] = _ref6;
      for (let i = 0; i < curr.length; i++) {
        const prevValue = prev[i];
        const currValue = curr[i];
        if (!(0, import_isEqual.default)(prevValue, currValue)) {
          return {
            flattenedRouterPanes: curr,
            diffIndex: i
          };
        }
      }
      return {
        flattenedRouterPanes: curr,
        diffIndex: curr.length
      };
    }),
    // create the memoized `resolvePane` function and manage the memo cache
    scan((acc, next) => {
      const {
        cacheKeysByFlatIndex,
        resolvedPaneCache
      } = acc;
      const {
        flattenedRouterPanes,
        diffIndex
      } = next;
      const beforeDiffIndex = cacheKeysByFlatIndex.slice(0, diffIndex + 1);
      const afterDiffIndex = cacheKeysByFlatIndex.slice(diffIndex + 1);
      const keysToKeep = new Set(beforeDiffIndex.flatMap((keySet) => Array.from(keySet)));
      const keysToDelete = afterDiffIndex.flatMap((keySet) => Array.from(keySet)).filter((key) => !keysToKeep.has(key));
      for (const key of keysToDelete) {
        resolvedPaneCache.delete(key);
      }
      const memoize = (nextFn) => (unresolvedPane, context, flatIndex) => {
        const key = unresolvedPane && "".concat(assignId(unresolvedPane), "-").concat(hashContext(context));
        const cachedResolvedPane = key && resolvedPaneCache.get(key);
        if (cachedResolvedPane)
          return cachedResolvedPane;
        const result = nextFn(unresolvedPane, context, flatIndex);
        if (!key)
          return result;
        const cacheKeySet = cacheKeysByFlatIndex[flatIndex] || /* @__PURE__ */ new Set();
        cacheKeySet.add(key);
        cacheKeysByFlatIndex[flatIndex] = cacheKeySet;
        resolvedPaneCache.set(key, result);
        return result;
      };
      return {
        flattenedRouterPanes,
        cacheKeysByFlatIndex,
        resolvedPaneCache,
        resolvePane: createPaneResolver(memoize)
      };
    }, initialCacheState),
    // run the memoized, recursive resolving
    switchMap((_ref7) => {
      let {
        flattenedRouterPanes,
        resolvePane
      } = _ref7;
      return resolvePaneTree({
        unresolvedPane: rootPaneNode,
        flattenedRouterPanes,
        parent: null,
        path: [],
        resolvePane,
        structureContext
      });
    })
  );
  return resolvedPanes$.pipe(
    // this diffs the previous emission with the current one. if there is a new
    // loading pane at the same position where a previous pane already had a
    // resolved value (looking at the IDs to compare), then return the previous
    // pane instead of the loading pane
    scan((prev, next) => next.map((nextPane, index2) => {
      const prevPane = prev[index2];
      if (!prevPane)
        return nextPane;
      if (nextPane.type !== "loading")
        return nextPane;
      if (prevPane.routerPaneSibling.id === nextPane.routerPaneSibling.id) {
        return prevPane;
      }
      return nextPane;
    }), []),
    // this prevents duplicate emissions
    distinctUntilChanged((prev, next) => {
      if (prev.length !== next.length)
        return false;
      for (let i = 0; i < next.length; i++) {
        const prevValue = prev[i];
        const nextValue = next[i];
        if (hashResolvedPaneMeta(prevValue) !== hashResolvedPaneMeta(nextValue)) {
          return false;
        }
      }
      return true;
    })
  );
}
function useRouterPanesStream() {
  const routerStateSubject = (0, import_react.useMemo)(() => new ReplaySubject(1), []);
  const routerPanes$ = (0, import_react.useMemo)(() => routerStateSubject.asObservable().pipe(map((_routerState) => (_routerState == null ? void 0 : _routerState.panes) || [])), [routerStateSubject]);
  const {
    state: routerState
  } = useRouter();
  (0, import_react.useEffect)(() => {
    routerStateSubject.next(routerState);
  }, [routerState, routerStateSubject]);
  return routerPanes$;
}
function useResolvedPanes() {
  const [error, setError] = (0, import_react.useState)();
  if (error)
    throw error;
  const {
    structureContext,
    rootPaneNode
  } = useDeskTool();
  const [data, setData] = (0, import_react.useState)({
    paneDataItems: [],
    resolvedPanes: [],
    routerPanes: []
  });
  const routerPanesStream = useRouterPanesStream();
  (0, import_react.useEffect)(() => {
    const resolvedPanes$ = createResolvedPaneNodeStream({
      rootPaneNode,
      routerPanesStream,
      structureContext
    }).pipe(map((resolvedPanes) => {
      const routerPanes = resolvedPanes.reduce((acc, next) => {
        const currentGroup = acc[next.groupIndex] || [];
        currentGroup[next.siblingIndex] = next.routerPaneSibling;
        acc[next.groupIndex] = currentGroup;
        return acc;
      }, []);
      const groupsLen = routerPanes.length;
      const paneDataItems = resolvedPanes.map((pane) => {
        var _a2;
        const {
          groupIndex,
          flatIndex,
          siblingIndex,
          routerPaneSibling,
          path
        } = pane;
        const itemId = routerPaneSibling.id;
        const nextGroup = routerPanes[groupIndex + 1];
        const paneDataItem = {
          active: groupIndex === groupsLen - 2,
          childItemId: (_a2 = nextGroup == null ? void 0 : nextGroup[0].id) != null ? _a2 : null,
          index: flatIndex,
          itemId: routerPaneSibling.id,
          groupIndex,
          key: "".concat(pane.type === "loading" ? "unknown" : pane.paneNode.id, "-").concat(itemId, "-").concat(siblingIndex),
          pane: pane.type === "loading" ? LOADING_PANE : pane.paneNode,
          params: routerPaneSibling.params || {},
          path: path.join(";"),
          payload: routerPaneSibling.payload,
          selected: flatIndex === resolvedPanes.length - 1,
          siblingIndex
        };
        return paneDataItem;
      });
      return {
        paneDataItems,
        routerPanes,
        resolvedPanes: paneDataItems.map((pane) => pane.pane)
      };
    }));
    const subscription = resolvedPanes$.subscribe({
      next: (result) => setData(result),
      error: (e) => setError(e)
    });
    return () => subscription.unsubscribe();
  }, [rootPaneNode, routerPanesStream, structureContext]);
  return data;
}
async function ensureDocumentIdAndType(documentStore, id, type) {
  if (id && type)
    return {
      id,
      type
    };
  if (!id && type)
    return {
      id: v4_default(),
      type
    };
  if (id && !type) {
    const resolvedType = await firstValueFrom(documentStore.resolveTypeForDocument(id));
    return {
      id,
      type: resolvedType
    };
  }
  throw new PaneResolutionError({
    message: "Neither document `id` or `type` was provided when trying to resolve intent."
  });
}
var EMPTY_RECORD = {};
var IntentResolver = (0, import_react.memo)(function IntentResolver2() {
  const {
    navigate
  } = useRouter();
  const maybeIntent = useRouterState((0, import_react.useCallback)((routerState) => {
    const intentName = typeof routerState.intent === "string" ? routerState.intent : void 0;
    return intentName ? {
      intent: intentName,
      params: isRecord$4(routerState.params) ? routerState.params : EMPTY_RECORD,
      payload: routerState.payload
    } : void 0;
  }, []));
  const {
    rootPaneNode,
    structureContext
  } = useDeskTool();
  const documentStore = useDocumentStore();
  const [error, setError] = (0, import_react.useState)(null);
  if (error)
    throw error;
  (0, import_react.useEffect)(() => {
    if (maybeIntent) {
      const {
        intent,
        params,
        payload
      } = maybeIntent;
      let cancelled = false;
      async function effect() {
        const {
          id,
          type
        } = await ensureDocumentIdAndType(documentStore, typeof params.id === "string" ? params.id : void 0, typeof params.type === "string" ? params.type : void 0);
        if (cancelled)
          return;
        const panes = await resolveIntent({
          intent,
          params: {
            ...params,
            id,
            type
          },
          payload,
          rootPaneNode,
          structureContext
        });
        if (cancelled)
          return;
        navigate({
          panes
        }, {
          replace: true
        });
      }
      effect().catch(setError);
      return () => {
        cancelled = true;
      };
    }
  }, [documentStore, maybeIntent, navigate, rootPaneNode, structureContext]);
  return null;
});
var __freeze$b = Object.freeze;
var __defProp$b = Object.defineProperty;
var __template$b = (cooked, raw) => __freeze$b(__defProp$b(cooked, "raw", {
  value: __freeze$b(raw || cooked.slice())
}));
var _a$b;
var PathSegment = styled_components_browser_esm_default.span(_a$b || (_a$b = __template$b(["\n  &:not(:last-child)::after {\n    content: ' ➝ ';\n    opacity: 0.5;\n  }\n"])));
function formatStack(stack) {
  return stack.replace(/\(\.\.\.\)\./g, "(...)\n  .").replace(/__WEBPACK_IMPORTED_MODULE_\d+_+/g, "").replace(/___default\./g, ".").replace(new RegExp(" \\(https?:\\/\\/".concat(window.location.host), "g"), " (");
}
function StructureError(_ref8) {
  let {
    error
  } = _ref8;
  if (!(error instanceof PaneResolutionError)) {
    throw error;
  }
  const {
    cause
  } = error;
  const stack = (cause == null ? void 0 : cause.stack) || error.stack;
  const showStack = stack && !(cause instanceof SerializeError) && !error.message.includes("Module build failed:");
  const path = cause instanceof SerializeError ? cause.path : [];
  const helpId = cause instanceof SerializeError && cause.helpId || error.helpId;
  const handleReload = (0, import_react.useCallback)(() => {
    window.location.reload();
  }, []);
  return (0, import_jsx_runtime.jsx)(Card, {
    height: "fill",
    overflow: "auto",
    padding: 4,
    sizing: "border",
    tone: "critical",
    children: (0, import_jsx_runtime.jsxs)(Container, {
      children: [(0, import_jsx_runtime.jsx)(Heading, {
        as: "h2",
        children: "Encountered an error while reading structure"
      }), (0, import_jsx_runtime.jsxs)(Card, {
        marginTop: 4,
        padding: 4,
        radius: 2,
        overflow: "auto",
        shadow: 1,
        tone: "inherit",
        children: [path.length > 0 && (0, import_jsx_runtime.jsxs)(Stack, {
          space: 2,
          children: [(0, import_jsx_runtime.jsx)(Label, {
            children: "Structure path"
          }), (0, import_jsx_runtime.jsx)(Code, {
            children: path.slice(1).map((segment, i) => (
              // eslint-disable-next-line react/no-array-index-key
              (0, import_jsx_runtime.jsx)(PathSegment, {
                children: segment
              }, "".concat(segment, "-").concat(i))
            ))
          })]
        }), (0, import_jsx_runtime.jsxs)(Stack, {
          marginTop: 4,
          space: 2,
          children: [(0, import_jsx_runtime.jsx)(Label, {
            children: "Error"
          }), (0, import_jsx_runtime.jsx)(Code, {
            children: showStack ? formatStack(stack) : error.message
          })]
        }), helpId && (0, import_jsx_runtime.jsx)(Box, {
          marginTop: 4,
          children: (0, import_jsx_runtime.jsx)(Text, {
            children: (0, import_jsx_runtime.jsx)("a", {
              href: generateHelpUrl(helpId),
              rel: "noopener noreferrer",
              target: "_blank",
              children: "View documentation"
            })
          })
        }), (0, import_jsx_runtime.jsx)(Box, {
          marginTop: 4,
          children: (0, import_jsx_runtime.jsx)(Button, {
            text: "Reload",
            icon: SyncIcon,
            tone: "primary",
            onClick: handleReload
          })
        })]
      })]
    })
  });
}
function UnknownPane(props) {
  const {
    isSelected,
    pane,
    paneKey
  } = props;
  const type = isRecord$4(pane) && pane.type || null;
  return (0, import_jsx_runtime.jsxs)(Pane, {
    id: paneKey,
    selected: isSelected,
    children: [(0, import_jsx_runtime.jsx)(PaneHeader, {
      title: "Unknown pane type"
    }), (0, import_jsx_runtime.jsx)(PaneContent, {
      children: (0, import_jsx_runtime.jsx)(Box, {
        padding: 4,
        children: typeof type === "string" ? (0, import_jsx_runtime.jsxs)(Text, {
          as: "p",
          muted: true,
          children: ["Structure item of type ", (0, import_jsx_runtime.jsx)("code", {
            children: type
          }), " is not a known entity."]
        }) : (0, import_jsx_runtime.jsxs)(Text, {
          as: "p",
          muted: true,
          children: ["Structure item is missing required ", (0, import_jsx_runtime.jsx)("code", {
            children: "type"
          }), " property."]
        })
      })
    })]
  });
}
function getWaitMessages(path) {
  const thresholds = [{
    ms: 300,
    message: "Loading…"
  }, {
    ms: 5e3,
    message: "Still loading…"
  }];
  if (isDev) {
    const message = ["Check console for errors?", "Is your observable/promise resolving?", path.length > 0 ? "Structure path: ".concat(path.join(" ➝ ")) : ""];
    thresholds.push({
      ms: 1e4,
      message: message.join("\n")
    });
  }
  const src = of(null);
  return merge(...thresholds.map((_ref9) => {
    let {
      ms,
      message
    } = _ref9;
    return src.pipe(mapTo(message), delay(ms));
  }));
}
var __freeze$a = Object.freeze;
var __defProp$a = Object.defineProperty;
var __template$a = (cooked, raw) => __freeze$a(__defProp$a(cooked, "raw", {
  value: __freeze$a(raw || cooked.slice())
}));
var _a$a;
var DEFAULT_MESSAGE = "Loading…";
var Content = styled_components_browser_esm_default(Flex)(_a$a || (_a$a = __template$a(["\n  opacity: 0;\n  transition: opacity 200ms;\n\n  &[data-mounted] {\n    opacity: 1;\n  }\n"])));
var LoadingPane = (0, import_react.memo)((props) => {
  const {
    delay: delay2 = 300,
    flex,
    message: messageProp = getWaitMessages,
    minWidth,
    paneKey,
    path,
    selected,
    title,
    tone
  } = props;
  const resolvedMessage = (0, import_react.useMemo)(() => {
    if (typeof messageProp === "function") {
      return messageProp(path ? path.split(";") : []);
    }
    return messageProp;
  }, [messageProp, path]);
  const [currentMessage, setCurrentMessage] = (0, import_react.useState)(() => {
    if (typeof resolvedMessage === "string")
      return resolvedMessage;
    return DEFAULT_MESSAGE;
  });
  (0, import_react.useEffect)(() => {
    if (typeof resolvedMessage !== "object")
      return void 0;
    if (typeof resolvedMessage.subscribe === "function")
      return void 0;
    const sub = resolvedMessage.subscribe(setCurrentMessage);
    return () => sub.unsubscribe();
  }, [resolvedMessage]);
  const [contentElement, setContentElement] = (0, import_react.useState)(null);
  const [mounted, setMounted] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    if (!contentElement)
      return void 0;
    return _raf2(() => setMounted(true));
  }, [contentElement]);
  const content = (0, import_jsx_runtime.jsxs)(Content, {
    align: "center",
    "data-mounted": mounted ? "" : void 0,
    direction: "column",
    height: "fill",
    justify: "center",
    ref: setContentElement,
    children: [(0, import_jsx_runtime.jsx)(Spinner, {
      muted: true
    }), (title || currentMessage) && (0, import_jsx_runtime.jsx)(Box, {
      marginTop: 3,
      children: (0, import_jsx_runtime.jsx)(Text, {
        align: "center",
        muted: true,
        size: 1,
        children: title || currentMessage
      })
    })]
  });
  return (0, import_jsx_runtime.jsx)(Pane, {
    flex,
    id: paneKey,
    minWidth,
    selected,
    tone,
    children: (0, import_jsx_runtime.jsx)(PaneContent, {
      children: content
    })
  });
});
LoadingPane.displayName = "LoadingPane";
var paneMap = {
  component: (0, import_react.lazy)(() => import("./index-9cbc91eb-XWXIPIF4.js")),
  document: (0, import_react.lazy)(() => import("./index-3e9457ce-HWLUY6JO.js")),
  documentList: (0, import_react.lazy)(() => import("./index-9b184a3d-H7JXFNJA.js")),
  list: (0, import_react.lazy)(() => import("./index-f4b3c5f5-Z2AH2DAK.js"))
};
var DeskToolPane = (0, import_react.memo)(function DeskToolPane2(props) {
  const {
    active,
    childItemId,
    groupIndex,
    index: index2,
    itemId,
    pane,
    paneKey,
    params,
    payload,
    path,
    selected,
    siblingIndex
  } = props;
  const PaneComponent = paneMap[pane.type] || UnknownPane;
  return (0, import_jsx_runtime.jsx)(PaneRouterProvider, {
    flatIndex: index2,
    index: groupIndex,
    params,
    payload,
    siblingIndex,
    children: (0, import_jsx_runtime.jsx)(import_react.Suspense, {
      fallback: (0, import_jsx_runtime.jsx)(LoadingPane, {
        paneKey,
        path,
        selected
      }),
      children: (0, import_jsx_runtime.jsx)(PaneComponent, {
        childItemId: childItemId || "",
        index: index2,
        itemId,
        isActive: active,
        isSelected: selected,
        paneKey,
        pane
      })
    })
  });
}, (_ref10, _ref11) => {
  let {
    params: prevParams = {},
    payload: prevPayload = null,
    ...prev
  } = _ref10;
  let {
    params: nextParams = {},
    payload: nextPayload = null,
    ...next
  } = _ref11;
  if (!(0, import_isEqual.default)(prevParams, nextParams))
    return false;
  if (!(0, import_isEqual.default)(prevPayload, nextPayload))
    return false;
  const keys = /* @__PURE__ */ new Set([...Object.keys(prev), ...Object.keys(next)]);
  for (const key of keys) {
    if (prev[key] !== next[key])
      return false;
  }
  return true;
});
function ErrorPane(props) {
  const {
    children,
    currentMinWidth,
    flex,
    minWidth,
    paneKey,
    title = "Error",
    tone = "critical"
  } = props;
  return (0, import_jsx_runtime.jsxs)(Pane, {
    currentMinWidth,
    flex,
    id: paneKey,
    minWidth,
    tone,
    children: [(0, import_jsx_runtime.jsx)(PaneHeader, {
      title
    }), (0, import_jsx_runtime.jsx)(PaneContent, {
      overflow: "auto",
      children: (0, import_jsx_runtime.jsx)(Box, {
        paddingX: 4,
        paddingY: 5,
        children
      })
    })]
  });
}
function getOpErrorTitle(op) {
  if (op === "delete") {
    return "An error occurred while attempting to delete this document.\n      This usually means that there are other documents that refers to it.";
  }
  if (op === "unpublish") {
    return "An error occurred while attempting to unpublish this document.\n      This usually means that there are other documents that refers to it.";
  }
  return "An error occurred during ".concat(op);
}
function getOpSuccessTitle(op) {
  if (op === "publish") {
    return "The document was published";
  }
  if (op === "unpublish") {
    return "The document was unpublished. A draft has been created from the latest published version.";
  }
  if (op === "discardChanges") {
    return "All changes since last publish has now been discarded. The discarded draft can still be recovered from history";
  }
  if (op === "delete") {
    return "The document was successfully deleted";
  }
  return "Successfully performed ".concat(op, " on document");
}
var IGNORE_OPS = ["patch", "commit"];
var DocumentOperationResults = (0, import_react.memo)(function DocumentOperationResults2() {
  const {
    push: pushToast
  } = useToast();
  const {
    documentId,
    documentType
  } = useDocumentPane();
  const event = useDocumentOperationEvent(documentId, documentType);
  const prevEvent = (0, import_react.useRef)(event);
  const paneRouter = usePaneRouter();
  (0, import_react.useEffect)(() => {
    if (!event || event === prevEvent.current)
      return;
    let cleanupId;
    if (event.type === "error") {
      pushToast({
        closable: true,
        duration: 3e4,
        // 30s
        status: "error",
        title: getOpErrorTitle(event.op),
        description: (0, import_jsx_runtime.jsxs)("details", {
          children: [(0, import_jsx_runtime.jsx)("summary", {
            children: "Details"
          }), event.error.message]
        })
      });
    }
    if (event.type === "success" && !IGNORE_OPS.includes(event.op)) {
      pushToast({
        closable: true,
        status: "success",
        title: getOpSuccessTitle(event.op)
      });
    }
    if (event.type === "success" && event.op === "delete") {
      cleanupId = setTimeout(() => paneRouter.closeCurrentAndAfter(), 0);
    }
    prevEvent.current = event;
    return () => clearTimeout(cleanupId);
  }, [event, paneRouter, pushToast]);
  return null;
});
function useDeskToolSetting(namespace, key, defaultValue) {
  const settingsStore = useSettingsStore();
  const [value, setValue] = (0, import_react.useState)(defaultValue);
  const deskToolSettings = (0, import_react.useMemo)(() => settingsStore.forNamespace("desk-tool"), [settingsStore]);
  const settings = (0, import_react.useMemo)(() => {
    if (namespace) {
      return deskToolSettings.forNamespace(namespace).forKey(key);
    }
    return deskToolSettings.forKey(key);
  }, [deskToolSettings, namespace, key]);
  (0, import_react.useEffect)(() => {
    const sub = settings.listen(defaultValue).subscribe({
      next: setValue
    });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [defaultValue, key, namespace, settings]);
  const set = (0, import_react.useCallback)((newValue) => {
    setValue(newValue);
    settings.set(newValue);
  }, [settings]);
  return (0, import_react.useMemo)(() => [value, set], [set, value]);
}
var VIEW_MODE_PARSED = {
  id: "parsed",
  title: "Parsed"
};
var VIEW_MODE_RAW = {
  id: "raw",
  title: "Raw JSON"
};
var VIEW_MODES = [VIEW_MODE_PARSED, VIEW_MODE_RAW];
var lru = (0, import_hashlru.default)(1e3);
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  if (cached === void 0) {
    lru.set(keyPath, Array.isArray(value) || isRecord$4(value));
    return isExpanded(keyPath, value);
  }
  return cached;
}
function toggleExpanded(event) {
  const {
    path
  } = event;
  const current = lru.get(path);
  if (current === void 0) {
    return;
  }
  lru.set(path, !current);
}
function selectElement(element) {
  const sel = window.getSelection();
  if (sel) {
    const range = document.createRange();
    sel.removeAllRanges();
    range.selectNodeContents(element);
    sel.addRange(range);
  }
}
function select(event) {
  selectElement(event.currentTarget);
}
function maybeSelectAll(event) {
  const selectAll = event.keyCode === 65 && (event.metaKey || event.ctrlKey);
  if (!selectAll) {
    return;
  }
  event.preventDefault();
  selectElement(event.currentTarget);
}
function isDocumentLike(value) {
  return isRecord$4(value) && isString(value._id) && isString(value._type);
}
var __freeze$9 = Object.freeze;
var __defProp$9 = Object.defineProperty;
var __template$9 = (cooked, raw) => __freeze$9(__defProp$9(cooked, "raw", {
  value: __freeze$9(raw || cooked.slice())
}));
var _a$9;
var JSONInspectorWrapper = styled_components_browser_esm_default.div((_ref12) => {
  let {
    theme
  } = _ref12;
  const {
    color,
    fonts,
    space
  } = theme.sanity;
  return Ae(_a$9 || (_a$9 = __template$9(["\n    & .json-inspector,\n    & .json-inspector .json-inspector__selection {\n      font-family: ", ";\n      font-size: ", "px;\n      line-height: ", "px;\n      color: var(--card-code-fg-color);\n    }\n\n    & .json-inspector .json-inspector__leaf {\n      padding-left: ", ";\n    }\n\n    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {\n      padding-top: ", ";\n      padding-left: 0;\n    }\n\n    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {\n      display: none;\n    }\n\n    & .json-inspector .json-inspector__line {\n      display: block;\n      position: relative;\n      cursor: default;\n    }\n\n    & .json-inspector .json-inspector__line::after {\n      content: '';\n      position: absolute;\n      top: 0;\n      left: -200px;\n      right: -50px;\n      bottom: 0;\n      z-index: -1;\n      pointer-events: none;\n    }\n\n    & .json-inspector .json-inspector__line:hover::after {\n      background: var(--card-code-bg-color);\n    }\n\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {\n      cursor: pointer;\n    }\n\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {\n      content: '▸ ';\n      margin-left: calc(0 - ", " + 3px);\n      font-size: ", "px;\n      line-height: ", "px;\n    }\n\n    &\n      .json-inspector\n      .json-inspector__leaf_expanded.json-inspector__leaf_composite\n      > .json-inspector__line::before {\n      content: '▾ ';\n      font-size: ", "px;\n      line-height: ", "px;\n    }\n\n    & .json-inspector .json-inspector__radio,\n    & .json-inspector .json-inspector__flatpath {\n      display: none;\n    }\n\n    & .json-inspector .json-inspector__value {\n      margin-left: ", ";\n    }\n\n    &\n      .json-inspector\n      > .json-inspector__leaf_root\n      > .json-inspector__line\n      > .json-inspector__key\n      + .json-inspector__value {\n      margin: 0;\n    }\n\n    & .json-inspector .json-inspector__key {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_helper,\n    & .json-inspector .json-inspector__value_null {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__not-found {\n      padding-top: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_string {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_boolean {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_number {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__show-original {\n      display: inline-block;\n      padding: 0 6px;\n      cursor: pointer;\n    }\n\n    & .json-inspector .json-inspector__show-original:hover {\n      color: inherit;\n    }\n\n    & .json-inspector .json-inspector__show-original::before {\n      content: '↔';\n    }\n\n    & .json-inspector .json-inspector__show-original:hover::after {\n      content: ' expand';\n    }\n  "])), fonts.code.family, fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, rem(space[4]), rem(space[3]), rem(space[4]), fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, rem(space[4] / 2), color.syntax.property, color.syntax.constant, rem(space[3]), color.syntax.string, color.syntax.boolean, color.syntax.number);
});
function Search(props) {
  const {
    onChange,
    query
  } = props;
  const handleChange = (0, import_react.useCallback)((event) => onChange(event.target.value), [onChange]);
  return (0, import_jsx_runtime.jsx)(TextInput, {
    icon: SearchIcon,
    onChange: handleChange,
    placeholder: "Search",
    radius: 2,
    value: query || ""
  });
}
function InspectDialog(props) {
  const {
    value
  } = props;
  const {
    onInspectClose,
    paneKey
  } = useDocumentPane();
  const dialogIdPrefix = "".concat(paneKey, "_inspect_");
  const [viewModeId, onViewModeChange] = useDeskToolSetting("desk-tool", "inspect-view-preferred-view-mode-".concat(paneKey), "parsed");
  const viewMode = VIEW_MODES.find((mode) => mode.id === viewModeId);
  const setParsedViewMode = (0, import_react.useCallback)(() => {
    onViewModeChange(VIEW_MODE_PARSED.id);
  }, [onViewModeChange]);
  const setRawViewMode = (0, import_react.useCallback)(() => {
    onViewModeChange(VIEW_MODE_RAW.id);
  }, [onViewModeChange]);
  return (0, import_jsx_runtime.jsx)(Dialog, {
    id: "".concat(dialogIdPrefix, "dialog"),
    header: isDocumentLike(value) ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: ["Inspecting", " ", (0, import_jsx_runtime.jsx)("em", {
        children: (0, import_jsx_runtime.jsx)(DocTitle, {
          document: value
        })
      })]
    }) : (0, import_jsx_runtime.jsx)("em", {
      children: "No value"
    }),
    onClose: onInspectClose,
    onClickOutside: onInspectClose,
    width: 3,
    children: (0, import_jsx_runtime.jsxs)(Flex, {
      direction: "column",
      height: "fill",
      children: [(0, import_jsx_runtime.jsx)(Card, {
        padding: 3,
        shadow: 1,
        style: {
          position: "sticky",
          bottom: 0,
          zIndex: 3
        },
        children: (0, import_jsx_runtime.jsxs)(TabList, {
          space: 1,
          children: [(0, import_jsx_runtime.jsx)(Tab, {
            "aria-controls": "".concat(dialogIdPrefix, "tabpanel"),
            fontSize: 1,
            id: "".concat(dialogIdPrefix, "tab-").concat(VIEW_MODE_PARSED.id),
            label: VIEW_MODE_PARSED.title,
            onClick: setParsedViewMode,
            selected: viewMode === VIEW_MODE_PARSED
          }), (0, import_jsx_runtime.jsx)(Tab, {
            "aria-controls": "".concat(dialogIdPrefix, "tabpanel"),
            fontSize: 1,
            id: "".concat(dialogIdPrefix, "tab-").concat(VIEW_MODE_RAW.id),
            label: VIEW_MODE_RAW.title,
            onClick: setRawViewMode,
            selected: viewMode === VIEW_MODE_RAW
          })]
        })
      }), (0, import_jsx_runtime.jsxs)(TabPanel, {
        "aria-labelledby": "".concat(dialogIdPrefix, "tab-").concat(viewModeId),
        flex: 1,
        id: "".concat(dialogIdPrefix, "tabpanel"),
        overflow: "auto",
        padding: 4,
        style: {
          outline: "none"
        },
        children: [viewMode === VIEW_MODE_PARSED && (0, import_jsx_runtime.jsx)(JSONInspectorWrapper, {
          children: (0, import_jsx_runtime.jsx)(import_react_json_inspector.default, {
            data: value,
            isExpanded,
            onClick: toggleExpanded,
            search: Search
          })
        }), viewMode === VIEW_MODE_RAW && (0, import_jsx_runtime.jsx)(Code, {
          language: "json",
          tabIndex: 0,
          onKeyDown: maybeSelectAll,
          onDoubleClick: select,
          onFocus: select,
          children: JSON.stringify(value, null, 2)
        })]
      })]
    })
  });
}
var __freeze$8 = Object.freeze;
var __defProp$8 = Object.defineProperty;
var __template$8 = (cooked, raw) => __freeze$8(__defProp$8(cooked, "raw", {
  value: __freeze$8(raw || cooked.slice())
}));
var _a$8;
var Root$3 = styled_components_browser_esm_default(Card)(_a$8 || (_a$8 = __template$8(["\n  position: relative;\n  z-index: 50;\n"])));
function DeletedDocumentBanner(_ref13) {
  let {
    revisionId
  } = _ref13;
  const {
    documentId,
    documentType
  } = useDocumentPane();
  const {
    restore
  } = useDocumentOperation(documentId, documentType);
  const {
    navigateIntent
  } = useRouter();
  const handleRestore = (0, import_react.useCallback)(() => {
    if (revisionId) {
      restore.execute(revisionId);
      navigateIntent("edit", {
        id: documentId,
        type: documentType
      });
    }
  }, [documentId, documentType, navigateIntent, restore, revisionId]);
  return (0, import_jsx_runtime.jsx)(Root$3, {
    "data-testid": "deleted-document-banner",
    shadow: 1,
    tone: "transparent",
    children: (0, import_jsx_runtime.jsx)(Container, {
      paddingX: 4,
      paddingY: revisionId ? 2 : 3,
      sizing: "border",
      width: 1,
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        align: "center",
        children: [(0, import_jsx_runtime.jsx)(Text, {
          size: 1,
          children: (0, import_jsx_runtime.jsx)(ReadOnlyIcon, {})
        }), (0, import_jsx_runtime.jsxs)(Flex, {
          align: "center",
          gap: 2,
          flex: 1,
          marginLeft: 3,
          children: [(0, import_jsx_runtime.jsx)(Text, {
            size: 1,
            children: "This document has been deleted."
          }), revisionId && (0, import_jsx_runtime.jsx)(Button, {
            fontSize: 1,
            padding: 2,
            mode: "bleed",
            tone: "primary",
            onClick: handleRestore,
            text: "Restore most recent version"
          })]
        })]
      })
    })
  });
}
var __freeze$7 = Object.freeze;
var __defProp$7 = Object.defineProperty;
var __template$7 = (cooked, raw) => __freeze$7(__defProp$7(cooked, "raw", {
  value: __freeze$7(raw || cooked.slice())
}));
var _a$7;
var _b$1;
var Root$2 = styled_components_browser_esm_default(Card)(_a$7 || (_a$7 = __template$7(["\n  position: relative;\n  z-index: 50;\n"])));
var TextOneLine = styled_components_browser_esm_default(Text)(_b$1 || (_b$1 = __template$7(["\n  & > * {\n    overflow: hidden;\n    overflow: clip;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n  }\n"])));
var ReferenceChangedBanner = (0, import_react.memo)(() => {
  var _a2, _b2, _c2, _d, _e, _f;
  const documentPreviewStore = useDocumentPreviewStore();
  const {
    params,
    groupIndex,
    routerPanesState,
    replaceCurrent,
    BackLink: BackLink2
  } = usePaneRouter();
  const routerReferenceId = (_a2 = routerPanesState[groupIndex]) == null ? void 0 : _a2[0].id;
  const parentGroup = routerPanesState[groupIndex - 1];
  const parentSibling = parentGroup == null ? void 0 : parentGroup[0];
  const parentId = parentSibling == null ? void 0 : parentSibling.id;
  const hasHistoryOpen = Boolean((_b2 = parentSibling == null ? void 0 : parentSibling.params) == null ? void 0 : _b2.rev);
  const parentRefPath = (0, import_react.useMemo)(() => {
    return (params == null ? void 0 : params.parentRefPath) && fromString(params.parentRefPath) || null;
  }, [params == null ? void 0 : params.parentRefPath]);
  const referenceInfo = useMemoObservable(() => {
    const parentRefPathSegment = parentRefPath == null ? void 0 : parentRefPath[0];
    if (!parentId || !parentRefPathSegment || !parentRefPath) {
      return of({
        loading: false
      });
    }
    const publishedId = getPublishedId(parentId);
    const path = fromString(parentRefPathSegment);
    const keyedSegmentIndex = path.findIndex((p) => typeof p == "object" && "_key" in p);
    return concat(
      // emit a loading state instantly
      of({
        loading: true
      }),
      // then emit the values from watching the published ID's path
      documentPreviewStore.unstable_observePathsDocumentPair(publishedId, keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex)).pipe(
        // this debounce time is needed to prevent flashing banners due to
        // the router state updating faster than the content-lake state. we
        // debounce to wait for more emissions because the value pulled
        // initially could be stale.
        debounceTime(750),
        map((_ref14) => {
          let {
            draft,
            published
          } = _ref14;
          var _a3;
          return {
            loading: false,
            result: {
              availability: {
                draft: draft.availability,
                published: published.availability
              },
              refValue: (_a3 = get(draft.snapshot || published.snapshot, parentRefPath)) == null ? void 0 : _a3._ref
            }
          };
        })
      )
    );
  }, [documentPreviewStore, parentId, parentRefPath], {
    loading: true
  });
  const handleReloadReference = (0, import_react.useCallback)(() => {
    var _a3;
    if (referenceInfo.loading)
      return;
    if ((_a3 = referenceInfo.result) == null ? void 0 : _a3.refValue) {
      replaceCurrent({
        id: referenceInfo.result.refValue,
        params
      });
    }
  }, [referenceInfo.loading, referenceInfo.result, replaceCurrent, params]);
  const shouldHide = (
    // if `parentId` or `parentRefPath` is not present then this banner is n/a
    !parentId || !parentRefPath || // if viewing this pane via history, then hide
    hasHistoryOpen || // if loading, hide
    referenceInfo.loading || // if the parent document is not available (e.g. due to permission denied or
    // not found) we don't want to display a warning here, but instead rely on the
    // parent view to display the appropriate message
    !((_c2 = referenceInfo.result) == null ? void 0 : _c2.availability.draft.available) && !((_d = referenceInfo.result) == null ? void 0 : _d.availability.published.available) || // if the references are the same, then hide the reference changed banner
    ((_e = referenceInfo.result) == null ? void 0 : _e.refValue) === routerReferenceId
  );
  if (shouldHide)
    return null;
  return (0, import_jsx_runtime.jsx)(Root$2, {
    shadow: 1,
    tone: "caution",
    "data-testid": "reference-changed-banner",
    children: (0, import_jsx_runtime.jsx)(Container, {
      paddingX: 4,
      paddingY: 2,
      sizing: "border",
      width: 1,
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        align: "center",
        children: [(0, import_jsx_runtime.jsx)(Text, {
          size: 1,
          children: (0, import_jsx_runtime.jsx)(WarningOutlineIcon, {})
        }), ((_f = referenceInfo.result) == null ? void 0 : _f.refValue) ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [(0, import_jsx_runtime.jsx)(Box, {
            flex: 1,
            marginLeft: 3,
            children: (0, import_jsx_runtime.jsx)(TextOneLine, {
              title: "This reference has changed since you opened it.",
              size: 1,
              children: "This reference has changed since you opened it."
            })
          }), (0, import_jsx_runtime.jsx)(Box, {
            marginLeft: 3,
            children: (0, import_jsx_runtime.jsx)(Button, {
              onClick: handleReloadReference,
              icon: SyncIcon,
              fontSize: 1,
              mode: "ghost",
              padding: 2,
              space: 2,
              text: "Reload reference"
            })
          })]
        }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [(0, import_jsx_runtime.jsx)(Box, {
            flex: 1,
            marginLeft: 3,
            children: (0, import_jsx_runtime.jsx)(TextOneLine, {
              title: "This reference has been removed since you opened it.",
              size: 1,
              children: "This reference has been removed since you opened it."
            })
          }), (0, import_jsx_runtime.jsx)(Box, {
            marginLeft: 3,
            children: (0, import_jsx_runtime.jsx)(Button, {
              as: BackLink2,
              icon: CloseIcon,
              fontSize: 1,
              mode: "ghost",
              padding: 2,
              space: 2,
              text: "Close reference"
            })
          })]
        })]
      })
    })
  });
});
ReferenceChangedBanner.displayName = "ReferenceChangedBanner";
var __freeze$6 = Object.freeze;
var __defProp$6 = Object.defineProperty;
var __template$6 = (cooked, raw) => __freeze$6(__defProp$6(cooked, "raw", {
  value: __freeze$6(raw || cooked.slice())
}));
var _a$6;
var Root$1 = styled_components_browser_esm_default(Card)(_a$6 || (_a$6 = __template$6(["\n  position: relative;\n  z-index: 50;\n"])));
function PermissionCheckBanner(_ref15) {
  let {
    granted,
    requiredPermission
  } = _ref15;
  var _a2, _b2;
  const currentUser = useCurrentUser();
  const plural = ((_a2 = currentUser == null ? void 0 : currentUser.roles) == null ? void 0 : _a2.length) !== 1;
  const roles = join(((_b2 = currentUser == null ? void 0 : currentUser.roles) == null ? void 0 : _b2.map((r) => (0, import_jsx_runtime.jsx)("code", {
    children: r.title
  }, r.name))) || [], ", ");
  if (granted)
    return null;
  return (0, import_jsx_runtime.jsx)(Root$1, {
    "data-testid": "permission-check-banner",
    shadow: 1,
    tone: "transparent",
    children: (0, import_jsx_runtime.jsx)(Container, {
      paddingX: 4,
      paddingY: 3,
      sizing: "border",
      width: 1,
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        align: "flex-start",
        children: [(0, import_jsx_runtime.jsx)(Text, {
          size: 1,
          children: (0, import_jsx_runtime.jsx)(ReadOnlyIcon, {})
        }), (0, import_jsx_runtime.jsx)(Box, {
          flex: 1,
          marginLeft: 3,
          children: (0, import_jsx_runtime.jsxs)(Text, {
            size: 1,
            children: ["Your role", plural && "s", " ", roles, " ", plural ? "do" : "does", " not have permissions to", " ", requiredPermission, " this document."]
          })
        })]
      })
    })
  });
}
function join(array, sep) {
  return array.reduce((result, item) => {
    if (result === null) {
      return [item];
    }
    return result.concat([sep, item]);
  }, null);
}
function usePrevious(value) {
  const ref = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
var LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function useConditionalToast(params) {
  const toast = useToast();
  const wasEnabled = usePrevious(params.enabled);
  (0, import_react.useEffect)(() => {
    if (!wasEnabled && params.enabled) {
      toast.push({
        ...params,
        duration: LONG_ENOUGH_BUT_NOT_TOO_LONG
      });
    }
    if (wasEnabled && !params.enabled) {
      toast.push({
        ...params,
        // Note: @sanity/ui fallbacks to the default duration of 4s in case of falsey values
        duration: 0.01
      });
    }
  }, [params, toast, wasEnabled]);
}
var preventDefault = (ev) => ev.preventDefault();
var FormView = (0, import_react.forwardRef)(function FormView2(props, ref) {
  var _a2;
  const {
    hidden,
    margins
  } = props;
  const {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    editState,
    documentId,
    documentType,
    fieldActions,
    onChange,
    validation,
    ready,
    formState,
    onFocus,
    onBlur,
    onSetCollapsedPath,
    onPathOpen,
    onSetCollapsedFieldSet,
    onSetActiveFieldGroup
  } = useDocumentPane();
  const documentStore = useDocumentStore();
  const presence = useDocumentPresence(documentId);
  const patchChannel = (0, import_react.useMemo)(() => createPatchChannel(), []);
  const isLocked = (_a2 = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a2.enabled;
  useConditionalToast({
    id: "sync-lock-".concat(documentId),
    status: "warning",
    enabled: isLocked,
    title: "Syncing document…",
    description: "Please hold tight while the document is synced. This usually happens right after the document has been published, and it shouldn't take more than a few seconds"
  });
  (0, import_react.useEffect)(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe(tap((event) => {
      if (event.type === "mutation") {
        patchChannel.publish(prepareMutationEvent(event));
      }
      if (event.type === "rebase") {
        patchChannel.publish(prepareRebaseEvent(event));
      }
    })).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = Boolean(value == null ? void 0 : value._rev);
  (0, import_react.useEffect)(() => {
    if (hasRev) {
      patchChannel.publish({
        type: "mutation",
        patches: [],
        snapshot: value
      });
    }
  }, [hasRev]);
  const [formRef, setFormRef] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    if (ready && !(formState == null ? void 0 : formState.focusPath.length) && formRef) {
      focusFirstDescendant(formRef);
    }
  }, [ready]);
  const setRef = (0, import_react.useCallback)((node) => {
    setFormRef(node);
    if (typeof ref === "function") {
      ref(node);
    } else if (ref) {
      ref.current = node;
    }
  }, [ref]);
  return (0, import_jsx_runtime.jsx)(Container, {
    hidden,
    paddingX: 4,
    paddingTop: 5,
    paddingBottom: 9,
    sizing: "border",
    width: 1,
    children: (0, import_jsx_runtime.jsx)(PresenceOverlay, {
      margins,
      children: (0, import_jsx_runtime.jsx)(Box, {
        as: "form",
        onSubmit: preventDefault,
        ref: setRef,
        children: ready ? formState === null ? (0, import_jsx_runtime.jsx)(Box, {
          padding: 2,
          children: (0, import_jsx_runtime.jsx)(Text, {
            children: "This form is hidden"
          })
        }) : (0, import_jsx_runtime.jsx)(FormBuilder, {
          __internal_fieldActions: fieldActions,
          __internal_patchChannel: patchChannel,
          collapsedFieldSets,
          collapsedPaths,
          focusPath: formState.focusPath,
          changed: formState.changed,
          focused: formState.focused,
          groups: formState.groups,
          id: "root",
          members: formState.members,
          onChange,
          onFieldGroupSelect: onSetActiveFieldGroup,
          onPathBlur: onBlur,
          onPathFocus: onFocus,
          onPathOpen,
          onSetFieldSetCollapsed: onSetCollapsedFieldSet,
          onSetPathCollapsed: onSetCollapsedPath,
          presence,
          readOnly: formState.readOnly,
          schemaType: formState.schemaType,
          validation,
          value: formState.value
        }) : (0, import_jsx_runtime.jsx)(Delay, {
          ms: 300,
          children: (0, import_jsx_runtime.jsxs)(Flex, {
            align: "center",
            direction: "column",
            height: "fill",
            justify: "center",
            children: [(0, import_jsx_runtime.jsx)(Spinner, {
              muted: true
            }), (0, import_jsx_runtime.jsx)(Box, {
              marginTop: 3,
              children: (0, import_jsx_runtime.jsx)(Text, {
                align: "center",
                muted: true,
                size: 1,
                children: "Loading document"
              })
            })]
          })
        })
      })
    })
  });
});
function prepareMutationEvent(event) {
  const patches = event.mutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "mutation",
    snapshot: event.document,
    patches: fromMutationPatches(event.origin, patches)
  };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map((mut) => mut.patch).filter(Boolean);
  const localPatches = event.localMutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "rebase",
    snapshot: event.document,
    patches: fromMutationPatches("remote", remotePatches).concat(fromMutationPatches("local", localPatches))
  };
}
function DocumentHeaderTabs() {
  const {
    activeViewId,
    paneKey,
    views
  } = useDocumentPane();
  const tabPanelId = "".concat(paneKey, "tabpanel");
  return (0, import_jsx_runtime.jsx)(TabList, {
    space: 1,
    children: views.map((view, index2) => {
      var _a2;
      return (0, import_jsx_runtime.jsx)(DocumentHeaderTab, {
        icon: view.icon,
        id: "".concat(paneKey, "tab-").concat(view.id),
        isActive: activeViewId === view.id,
        label: (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
          children: view.title
        }),
        tabPanelId,
        viewId: index2 === 0 ? null : (_a2 = view.id) != null ? _a2 : null
      }, view.id);
    })
  });
}
function DocumentHeaderTab(props) {
  const {
    isActive,
    tabPanelId,
    viewId,
    ...rest
  } = props;
  const {
    ready
  } = useDocumentPane();
  const {
    setView
  } = usePaneRouter();
  const handleClick = (0, import_react.useCallback)(() => setView(viewId), [setView, viewId]);
  return (0, import_jsx_runtime.jsx)(Tab, {
    ...rest,
    "aria-controls": tabPanelId,
    disabled: !ready,
    fontSize: 1,
    selected: isActive,
    onClick: handleClick
  });
}
function DocumentHeaderTitle() {
  const {
    connectionState,
    schemaType,
    title,
    value: documentValue
  } = useDocumentPane();
  const subscribed = Boolean(documentValue) && connectionState === "connected";
  const {
    error,
    value
  } = useDocumentPreview({
    enabled: subscribed,
    schemaType,
    value: documentValue
  });
  if (connectionState !== "connected") {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
  }
  if (title) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
      children: title
    });
  }
  if (!documentValue) {
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: ["New ", (schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)]
    });
  }
  if (error) {
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: ["Error: ", error.message]
    });
  }
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
    children: (value == null ? void 0 : value.title) || (0, import_jsx_runtime.jsx)("span", {
      style: {
        color: "var(--card-muted-fg-color)"
      },
      children: "Untitled"
    })
  });
}
var DocumentPanelHeader = (0, import_react.memo)((0, import_react.forwardRef)(function DocumentPanelHeader2(_props, ref) {
  const {
    onMenuAction,
    onPaneClose,
    onPaneSplit,
    menuItems,
    menuItemGroups,
    schemaType,
    timelineStore,
    ready,
    views,
    unstable_languageFilter
  } = useDocumentPane();
  const {
    features
  } = useDeskTool();
  const {
    index: index2,
    BackLink: BackLink2,
    hasGroupSiblings
  } = usePaneRouter();
  const {
    actions: fieldActions
  } = useFieldActions();
  const menuNodes = (0, import_react.useMemo)(() => resolveMenuNodes({
    actionHandler: onMenuAction,
    fieldActions,
    menuItems,
    menuItemGroups
  }), [onMenuAction, fieldActions, menuItemGroups, menuItems]);
  const menuButtonNodes = (0, import_react.useMemo)(() => menuNodes.filter(isMenuNodeButton), [menuNodes]);
  const contextMenuNodes = (0, import_react.useMemo)(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]);
  const showTabs = views.length > 1;
  const rev = useTimelineSelector(timelineStore, (state) => state.revTime);
  const {
    collapsed,
    isLast
  } = usePane();
  const tabIndex = isLast && !collapsed ? -1 : 0;
  const showSplitPaneButton = features.splitViews && onPaneSplit && views.length > 1;
  const showSplitPaneCloseButton = showSplitPaneButton && hasGroupSiblings;
  const showPaneGroupCloseButton = !showSplitPaneCloseButton && !features.backButton;
  return (0, import_jsx_runtime.jsx)(PaneHeader, {
    ref,
    loading: !ready,
    title: (0, import_jsx_runtime.jsx)(DocumentHeaderTitle, {}),
    tabs: showTabs && (0, import_jsx_runtime.jsx)(DocumentHeaderTabs, {}),
    tabIndex,
    backButton: features.backButton && index2 > 0 && (0, import_jsx_runtime.jsx)(Button, {
      as: BackLink2,
      "data-as": "a",
      icon: ArrowLeftIcon,
      mode: "bleed",
      padding: 2
    }),
    subActions: (0, import_jsx_runtime.jsx)(TimelineMenu, {
      chunk: rev,
      mode: "rev",
      placement: "bottom-end"
    }),
    actions: (0, import_jsx_runtime.jsxs)(Flex, {
      align: "center",
      gap: 1,
      children: [unstable_languageFilter.length > 0 && (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
        children: unstable_languageFilter.map((languageFilterComponent, idx) => {
          return (0, import_react.createElement)(languageFilterComponent, {
            // eslint-disable-next-line react/no-array-index-key
            key: "language-filter-".concat(idx),
            schemaType
          });
        })
      }), menuButtonNodes.map((item) => (0, import_jsx_runtime.jsx)(PaneHeaderActionButton, {
        node: item
      }, item.key)), (0, import_jsx_runtime.jsx)(PaneContextMenuButton, {
        nodes: contextMenuNodes
      }, "context-menu"), showSplitPaneButton && (0, import_jsx_runtime.jsx)(Tooltip, {
        content: (0, import_jsx_runtime.jsx)(Text, {
          size: 1,
          style: {
            whiteSpace: "nowrap"
          },
          children: "Split pane right"
        }),
        padding: 2,
        placement: "bottom",
        portal: true,
        children: (0, import_jsx_runtime.jsx)(Button, {
          "aria-label": "Split pane right",
          icon: SplitVerticalIcon,
          mode: "bleed",
          onClick: onPaneSplit
        }, "split-pane-button")
      }), showSplitPaneCloseButton && (0, import_jsx_runtime.jsx)(Button, {
        icon: CloseIcon,
        mode: "bleed",
        onClick: onPaneClose,
        title: "Close split pane"
      }, "close-view-button"), showPaneGroupCloseButton && (0, import_jsx_runtime.jsx)(Button, {
        icon: CloseIcon,
        mode: "bleed",
        title: "Close pane group",
        as: BackLink2
      }, "close-view-button")]
    })
  });
}));
var __freeze$5 = Object.freeze;
var __defProp$5 = Object.defineProperty;
var __template$5 = (cooked, raw) => __freeze$5(__defProp$5(cooked, "raw", {
  value: __freeze$5(raw || cooked.slice())
}));
var _a$5;
var DocumentBox = styled_components_browser_esm_default(Box)({
  position: "relative"
});
var Scroller = styled_components_browser_esm_default(ScrollContainer)((_ref16) => {
  let {
    $disabled
  } = _ref16;
  if ($disabled) {
    return {
      height: "100%"
    };
  }
  return Ae(_a$5 || (_a$5 = __template$5(["\n    height: 100%;\n    overflow: auto;\n    position: relative;\n    scroll-behavior: smooth;\n    outline: none;\n  "])));
});
var DocumentPanel = function DocumentPanel2(props) {
  const {
    footerHeight,
    isInspectOpen,
    rootElement,
    setDocumentPanelPortalElement
  } = props;
  const {
    activeViewId,
    displayed,
    documentId,
    editState,
    inspector,
    value,
    views,
    ready,
    schemaType,
    permissions,
    isPermissionsLoading,
    isDeleting,
    isDeleted,
    timelineStore,
    formState
  } = useDocumentPane();
  const {
    collapsed: layoutCollapsed
  } = usePaneLayout();
  const {
    collapsed
  } = usePane();
  const parentPortal = usePortal();
  const {
    features
  } = useDeskTool();
  const [headerElement, setHeaderElement] = (0, import_react.useState)(null);
  const headerRect = useElementRect(headerElement);
  const portalRef = (0, import_react.useRef)(null);
  const [documentScrollElement, setDocumentScrollElement] = (0, import_react.useState)(null);
  const formContainerElement = (0, import_react.useRef)(null);
  const requiredPermission = value._createdAt ? "update" : "create";
  const selectedGroup = (0, import_react.useMemo)(() => {
    if (!formState)
      return void 0;
    return formState.groups.find((group) => group.selected);
  }, [formState]);
  const activeView = (0, import_react.useMemo)(() => views.find((view) => view.id === activeViewId) || views[0] || {
    type: "form"
  }, [activeViewId, views]);
  const portalElement = features.splitPanes ? portalRef.current || parentPortal.element : parentPortal.element;
  const margins = (0, import_react.useMemo)(() => {
    if (layoutCollapsed) {
      return [(headerRect == null ? void 0 : headerRect.height) || 0, 0, footerHeight ? footerHeight + 2 : 2, 0];
    }
    return [0, 0, 2, 0];
  }, [layoutCollapsed, footerHeight, headerRect]);
  const formViewHidden = activeView.type !== "form";
  const activeViewNode = (0, import_react.useMemo)(() => activeView.type === "component" && activeView.component && (0, import_react.createElement)(activeView.component, {
    document: {
      draft: (editState == null ? void 0 : editState.draft) || null,
      displayed: displayed || value,
      historical: displayed,
      published: (editState == null ? void 0 : editState.published) || null
    },
    documentId,
    options: activeView.options,
    schemaType
  }), [activeView, displayed, documentId, editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, schemaType, value]);
  const lastNonDeletedRevId = useTimelineSelector(timelineStore, (state) => state.lastNonDeletedRevId);
  (0, import_react.useEffect)(() => {
    if (!(documentScrollElement == null ? void 0 : documentScrollElement.scrollTo))
      return;
    documentScrollElement.scrollTo(0, 0);
  }, [documentId, documentScrollElement]);
  (0, import_react.useEffect)(() => {
    if (portalElement) {
      setDocumentPanelPortalElement(portalElement);
    }
  }, [portalElement, setDocumentPanelPortalElement]);
  const inspectDialog = (0, import_react.useMemo)(() => {
    return isInspectOpen ? (0, import_jsx_runtime.jsx)(InspectDialog, {
      value: displayed || value
    }) : null;
  }, [isInspectOpen, displayed, value]);
  const showInspector = Boolean(!collapsed && inspector);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [(0, import_jsx_runtime.jsx)(DocumentPanelHeader, {
      ref: setHeaderElement
    }), (0, import_jsx_runtime.jsx)(PaneContent, {
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        height: "fill",
        children: [(features.resizablePanes || !showInspector) && (0, import_jsx_runtime.jsx)(DocumentBox, {
          flex: 2,
          overflow: "hidden",
          children: (0, import_jsx_runtime.jsx)(PortalProvider, {
            element: portalElement,
            __unstable_elements: {
              documentScrollElement
            },
            children: (0, import_jsx_runtime.jsx)(BoundaryElementProvider, {
              element: documentScrollElement,
              children: (0, import_jsx_runtime.jsxs)(VirtualizerScrollInstanceProvider, {
                scrollElement: documentScrollElement,
                containerElement: formContainerElement,
                children: [activeView.type === "form" && !isPermissionsLoading && ready && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
                  children: [(0, import_jsx_runtime.jsx)(PermissionCheckBanner, {
                    granted: Boolean(permissions == null ? void 0 : permissions.granted),
                    requiredPermission
                  }), !isDeleting && isDeleted && (0, import_jsx_runtime.jsx)(DeletedDocumentBanner, {
                    revisionId: lastNonDeletedRevId
                  }), (0, import_jsx_runtime.jsx)(ReferenceChangedBanner, {})]
                }), (0, import_jsx_runtime.jsxs)(Scroller, {
                  $disabled: layoutCollapsed || false,
                  "data-testid": "document-panel-scroller",
                  ref: setDocumentScrollElement,
                  children: [(0, import_jsx_runtime.jsx)(FormView, {
                    hidden: formViewHidden,
                    margins,
                    ref: formContainerElement
                  }, documentId + (ready ? "_ready" : "_pending")), activeViewNode]
                }, "".concat(selectedGroup == null ? void 0 : selectedGroup.name, "-").concat(documentId, "}")), inspectDialog, (0, import_jsx_runtime.jsx)("div", {
                  "data-testid": "document-panel-portal",
                  ref: portalRef
                })]
              })
            })
          })
        }), showInspector && (0, import_jsx_runtime.jsx)(BoundaryElementProvider, {
          element: rootElement,
          children: (0, import_jsx_runtime.jsx)(DocumentInspectorPanel, {
            documentId,
            documentType: schemaType.name,
            flex: 1
          })
        })]
      })
    })]
  });
};
var POPOVER_FALLBACK_PLACEMENTS = ["left", "bottom"];
var DIALOG_WIDTH_TO_UI_WIDTH = {
  small: 0,
  medium: 1,
  large: 2,
  full: "auto"
};
function ConfirmDialog(props) {
  const {
    dialog,
    referenceElement
  } = props;
  return (0, import_jsx_runtime.jsx)(Popover, {
    content: (0, import_jsx_runtime.jsx)(ConfirmDialogContent, {
      dialog
    }),
    fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
    open: true,
    placement: "top",
    portal: true,
    preventOverflow: true,
    referenceElement
  });
}
function ConfirmDialogContent(props) {
  const {
    dialog
  } = props;
  const {
    cancelButtonIcon,
    cancelButtonText,
    confirmButtonIcon,
    confirmButtonText,
    // color,
    message,
    onCancel,
    onConfirm,
    tone
  } = dialog;
  const {
    isTopLayer
  } = useLayer();
  const [element, setElement] = (0, import_react.useState)(null);
  const handleClickOutside = (0, import_react.useCallback)(() => {
    if (isTopLayer)
      onCancel();
  }, [isTopLayer, onCancel]);
  const handleGlobalKeyDown = (0, import_react.useCallback)((event) => {
    if (event.key === "Escape" && isTopLayer)
      onCancel();
  }, [isTopLayer, onCancel]);
  useClickOutside(handleClickOutside, [element]);
  useGlobalKeyDown(handleGlobalKeyDown);
  return (0, import_jsx_runtime.jsxs)(Flex, {
    direction: "column",
    ref: setElement,
    style: {
      minWidth: 320 - 16,
      maxWidth: 400
    },
    children: [(0, import_jsx_runtime.jsx)(Box, {
      flex: 1,
      overflow: "auto",
      padding: 4,
      children: (0, import_jsx_runtime.jsx)(Text, {
        children: message
      })
    }), (0, import_jsx_runtime.jsx)(Box, {
      paddingX: 4,
      paddingY: 3,
      style: {
        borderTop: "1px solid var(--card-border-color)"
      },
      children: (0, import_jsx_runtime.jsxs)(Grid, {
        columns: 2,
        gap: 2,
        children: [(0, import_jsx_runtime.jsx)(Button, {
          icon: cancelButtonIcon,
          onClick: onCancel,
          mode: "ghost",
          text: cancelButtonText || "Cancel"
        }), (0, import_jsx_runtime.jsx)(Button, {
          icon: confirmButtonIcon,
          onClick: onConfirm,
          text: confirmButtonText || "Confirm",
          tone
        })]
      })
    })]
  });
}
function ModalDialog(props) {
  const {
    dialog
  } = props;
  const dialogId = (0, import_react.useId)();
  const footer = dialog.footer && (0, import_jsx_runtime.jsx)(Box, {
    paddingX: 4,
    paddingY: 3,
    children: dialog.footer
  });
  return (0, import_jsx_runtime.jsx)(LegacyLayerProvider, {
    zOffset: "fullscreen",
    children: (0, import_jsx_runtime.jsx)(Dialog, {
      __unstable_hideCloseButton: dialog.showCloseButton === false,
      footer,
      header: dialog.header,
      id: dialogId,
      onClose: dialog.onClose,
      onClickOutside: dialog.onClose,
      width: dialog.width === void 0 ? 1 : DIALOG_WIDTH_TO_UI_WIDTH[dialog.width],
      children: (0, import_jsx_runtime.jsx)(Box, {
        padding: 4,
        children: dialog.content
      })
    })
  });
}
function PopoverDialog(props) {
  const {
    dialog,
    referenceElement
  } = props;
  return (0, import_jsx_runtime.jsx)(Popover, {
    content: (0, import_jsx_runtime.jsx)(PopoverDialogContent, {
      dialog
    }),
    fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
    open: true,
    placement: "top",
    portal: true,
    preventOverflow: true,
    referenceElement
  });
}
function PopoverDialogContent(props) {
  const {
    dialog
  } = props;
  const {
    content,
    onClose
  } = dialog;
  const {
    isTopLayer
  } = useLayer();
  const [element, setElement] = (0, import_react.useState)(null);
  const handleClickOutside = (0, import_react.useCallback)(() => {
    if (isTopLayer)
      onClose();
  }, [isTopLayer, onClose]);
  const handleGlobalKeyDown = (0, import_react.useCallback)((event) => {
    if (event.key === "Escape" && isTopLayer)
      onClose();
  }, [isTopLayer, onClose]);
  useClickOutside(handleClickOutside, [element]);
  useGlobalKeyDown(handleGlobalKeyDown);
  return (0, import_jsx_runtime.jsx)("div", {
    ref: setElement,
    children: content
  });
}
function DocumentActionPortalProvider(props) {
  const {
    children
  } = props;
  const {
    element,
    elements
  } = usePortal();
  const portalElement = (elements == null ? void 0 : elements[DOCUMENT_PANEL_PORTAL_ELEMENT]) || element;
  return (0, import_jsx_runtime.jsx)(PortalProvider, {
    element: portalElement,
    children
  });
}
function ActionStateDialog(props) {
  const {
    dialog,
    referenceElement = null
  } = props;
  const modalId = (0, import_react.useId)();
  if (dialog.type === "confirm") {
    return (0, import_jsx_runtime.jsx)(ConfirmDialog, {
      dialog,
      referenceElement
    });
  }
  if (dialog.type === "popover") {
    return (0, import_jsx_runtime.jsx)(PopoverDialog, {
      dialog,
      referenceElement
    });
  }
  if (dialog.type === "dialog" || !dialog.type) {
    return (0, import_jsx_runtime.jsx)(DocumentActionPortalProvider, {
      children: (0, import_jsx_runtime.jsx)(ModalDialog, {
        dialog
      })
    });
  }
  if (dialog.type === "custom") {
    return (0, import_jsx_runtime.jsx)(DocumentActionPortalProvider, {
      children: dialog == null ? void 0 : dialog.component
    });
  }
  const unknownModal = dialog;
  console.warn("Unsupported modal type ".concat(unknownModal.type));
  return (0, import_jsx_runtime.jsx)(Dialog, {
    id: modalId,
    onClose: unknownModal.onClose,
    onClickOutside: unknownModal.onClose,
    width: 2,
    children: (0, import_jsx_runtime.jsx)(Box, {
      padding: 4,
      children: unknownModal.content || (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
        children: ["Unexpected modal type (", (0, import_jsx_runtime.jsx)("code", {
          children: unknownModal.type
        }), ")"]
      })
    })
  });
}
function ActionMenuButton(props) {
  const {
    actionStates,
    disabled
  } = props;
  const idPrefix = (0, import_react.useId)();
  const buttonRef = (0, import_react.useRef)(null);
  const [actionIndex, setActionIndex] = (0, import_react.useState)(-1);
  const [referenceElement, setReferenceElement] = (0, import_react.useState)(null);
  const handleAction = (0, import_react.useCallback)((idx) => {
    setActionIndex(idx);
  }, []);
  const popoverProps = (0, import_react.useMemo)(() => ({
    placement: "top-end",
    portal: true,
    preventOverflow: true
  }), []);
  const currentAction = actionStates[actionIndex];
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [(0, import_jsx_runtime.jsx)(MenuButton, {
      id: "".concat(idPrefix, "-action-menu"),
      button: (0, import_jsx_runtime.jsx)(Button, {
        "data-testid": "action-menu-button",
        "aria-label": "Open document actions",
        disabled,
        icon: ChevronDownIcon,
        mode: "ghost",
        ref: buttonRef
      }),
      menu: (0, import_jsx_runtime.jsx)(Menu, {
        padding: 1,
        children: actionStates.map((actionState, idx) => (0, import_jsx_runtime.jsx)(ActionMenuListItem, {
          actionState,
          disabled,
          index: idx,
          onAction: handleAction
        }, idx))
      }),
      popover: popoverProps,
      ref: setReferenceElement
    }), currentAction && currentAction.dialog && (0, import_jsx_runtime.jsx)(LegacyLayerProvider, {
      zOffset: "paneFooter",
      children: (0, import_jsx_runtime.jsx)(ActionStateDialog, {
        dialog: currentAction.dialog,
        referenceElement
      })
    })]
  });
}
function ActionMenuListItem(props) {
  const {
    actionState,
    disabled,
    index: index2,
    onAction
  } = props;
  const {
    onHandle
  } = actionState;
  const handleClick = (0, import_react.useCallback)(() => {
    onAction(index2);
    if (onHandle)
      onHandle();
  }, [index2, onAction, onHandle]);
  const tooltipContent = actionState.title && (0, import_jsx_runtime.jsx)(Box, {
    padding: 2,
    children: (0, import_jsx_runtime.jsx)(Text, {
      size: 1,
      children: actionState.title
    })
  });
  return (0, import_jsx_runtime.jsx)(MenuItem, {
    "data-testid": "action-".concat(actionState.label.replace(" ", "")),
    disabled: disabled || Boolean(actionState.disabled),
    onClick: handleClick,
    padding: 0,
    tone: actionState.tone,
    children: (0, import_jsx_runtime.jsx)(Tooltip, {
      content: tooltipContent,
      disabled: !tooltipContent,
      fallbackPlacements: ["left", "bottom"],
      placement: "top",
      portal: true,
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        align: "center",
        paddingX: 3,
        children: [(0, import_jsx_runtime.jsxs)(Flex, {
          flex: 1,
          paddingY: 3,
          children: [actionState.icon && (0, import_jsx_runtime.jsx)(Box, {
            marginRight: 3,
            children: (0, import_jsx_runtime.jsxs)(Text, {
              children: [(0, import_react.isValidElement)(actionState.icon) && actionState.icon, (0, import_react_is.isValidElementType)(actionState.icon) && (0, import_react.createElement)(actionState.icon)]
            })
          }), (0, import_jsx_runtime.jsx)(Text, {
            children: actionState.label
          })]
        }), actionState.shortcut && (0, import_jsx_runtime.jsx)(Box, {
          marginLeft: 3,
          children: (0, import_jsx_runtime.jsx)(Hotkeys, {
            keys: String(actionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1))
          })
        })]
      })
    })
  });
}
function DocumentStatusBarActionsInner(props) {
  const {
    disabled,
    showMenu,
    states
  } = props;
  const [firstActionState, ...menuActionStates] = states;
  const [buttonElement, setButtonElement] = (0, import_react.useState)(null);
  const tooltipContent = (0, import_react.useMemo)(() => {
    if (!firstActionState || !firstActionState.title && !firstActionState.shortcut)
      return null;
    return (0, import_jsx_runtime.jsxs)(Flex, {
      padding: 2,
      style: {
        maxWidth: 300
      },
      align: "center",
      children: [(0, import_jsx_runtime.jsx)(Text, {
        size: 1,
        children: firstActionState.title
      }), firstActionState.shortcut && (0, import_jsx_runtime.jsx)(Box, {
        marginLeft: firstActionState.title ? 2 : 0,
        children: (0, import_jsx_runtime.jsx)(Hotkeys, {
          keys: String(firstActionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase())
        })
      })]
    });
  }, [firstActionState]);
  return (0, import_jsx_runtime.jsxs)(Flex, {
    children: [firstActionState && (0, import_jsx_runtime.jsx)(LayerProvider, {
      zOffset: 200,
      children: (0, import_jsx_runtime.jsx)(Tooltip, {
        disabled: !tooltipContent,
        content: tooltipContent,
        portal: true,
        placement: "top",
        children: (0, import_jsx_runtime.jsx)(Stack, {
          flex: 1,
          children: (0, import_jsx_runtime.jsx)(Button, {
            "data-testid": "action-".concat(firstActionState.label),
            disabled: disabled || Boolean(firstActionState.disabled),
            icon: firstActionState.icon,
            onClick: firstActionState.onHandle,
            ref: setButtonElement,
            text: firstActionState.label,
            tone: firstActionState.tone || "primary"
          })
        })
      })
    }), showMenu && menuActionStates.length > 0 && (0, import_jsx_runtime.jsx)(Box, {
      marginLeft: 1,
      children: (0, import_jsx_runtime.jsx)(ActionMenuButton, {
        actionStates: menuActionStates,
        disabled
      })
    }), firstActionState && firstActionState.dialog && (0, import_jsx_runtime.jsx)(ActionStateDialog, {
      dialog: firstActionState.dialog,
      referenceElement: buttonElement
    })]
  });
}
var DocumentStatusBarActions = (0, import_react.memo)(function DocumentStatusBarActions2() {
  const {
    actions,
    connectionState,
    documentId,
    editState
  } = useDocumentPane();
  if (!actions || !editState) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(RenderActionCollectionState, {
    actions,
    actionProps: editState,
    children: (_ref17) => {
      let {
        states
      } = _ref17;
      return (0, import_jsx_runtime.jsx)(DocumentStatusBarActionsInner, {
        disabled: connectionState !== "connected",
        showMenu: actions.length > 1,
        states
      }, documentId);
    }
  });
});
var HistoryStatusBarActions = (0, import_react.memo)(function HistoryStatusBarActions2() {
  const {
    connectionState,
    editState,
    timelineStore
  } = useDocumentPane();
  const revTime = useTimelineSelector(timelineStore, (state) => state.revTime);
  const revision = (revTime == null ? void 0 : revTime.id) || "";
  const disabled = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev === revision;
  const actionProps = (0, import_react.useMemo)(() => ({
    ...editState || {},
    revision
  }), [editState, revision]);
  const historyActions = (0, import_react.useMemo)(() => [HistoryRestoreAction], []);
  return (0, import_jsx_runtime.jsx)(RenderActionCollectionState, {
    actions: historyActions,
    actionProps,
    children: (_ref18) => {
      let {
        states
      } = _ref18;
      return (0, import_jsx_runtime.jsx)(DocumentStatusBarActionsInner, {
        disabled: connectionState !== "connected" || Boolean(disabled),
        showMenu: false,
        states
      });
    }
  });
});
var BADGE_TONES = {
  primary: "primary",
  success: "positive",
  warning: "caution",
  danger: "critical"
};
function DocumentBadgesInner(_ref19) {
  let {
    states
  } = _ref19;
  return (0, import_jsx_runtime.jsx)(Inline, {
    space: 1,
    children: states.map((badge, index2) => (0, import_jsx_runtime.jsx)(Tooltip, {
      content: badge.title && (0, import_jsx_runtime.jsx)(Box, {
        padding: 2,
        children: (0, import_jsx_runtime.jsx)(Text, {
          size: 1,
          children: badge.title
        })
      }),
      disabled: !badge.title,
      placement: "top",
      portal: true,
      children: (0, import_jsx_runtime.jsx)(Badge, {
        fontSize: 1,
        mode: "outline",
        paddingX: 2,
        paddingY: 1,
        radius: 4,
        tone: badge.color ? BADGE_TONES[badge.color] : void 0,
        style: {
          whiteSpace: "nowrap"
        },
        children: badge.label
      })
    }, String(index2)))
  });
}
function DocumentBadges() {
  const {
    badges,
    editState
  } = useDocumentPane();
  if (!editState || !badges)
    return null;
  return (0, import_jsx_runtime.jsx)(RenderBadgeCollectionState, {
    badges,
    badgeProps: editState,
    children: (_ref20) => {
      let {
        states
      } = _ref20;
      return (0, import_jsx_runtime.jsx)(DocumentBadgesInner, {
        states
      });
    }
  });
}
var __freeze$4 = Object.freeze;
var __defProp$4 = Object.defineProperty;
var __template$4 = (cooked, raw) => __freeze$4(__defProp$4(cooked, "raw", {
  value: __freeze$4(raw || cooked.slice())
}));
var _a$4;
var Root = styled_components_browser_esm_default(Flex)(_a$4 || (_a$4 = __template$4(["\n  cursor: default;\n"])));
function PublishStatus(props) {
  const {
    collapsed,
    disabled,
    lastPublished,
    lastUpdated,
    liveEdit
  } = props;
  const lastPublishedTimeAgo = useTimeAgo(lastPublished || "", {
    minimal: true,
    agoSuffix: true
  });
  const lastPublishedTime = useTimeAgo(lastPublished || "", {
    minimal: true
  });
  const lastUpdatedTimeAgo = useTimeAgo(lastUpdated || "", {
    minimal: true,
    agoSuffix: true
  });
  const lastUpdatedTime = useTimeAgo(lastUpdated || "", {
    minimal: true
  });
  const a11yUpdatedAgo = useTimeAgo(lastUpdated || "", {
    minimal: false,
    agoSuffix: true
  });
  const a11yPublishedAgo = useTimeAgo(lastPublished || "", {
    minimal: false,
    agoSuffix: true
  });
  const a11yLabel = liveEdit ? "Last updated ".concat(a11yUpdatedAgo) : "Last published ".concat(a11yPublishedAgo);
  return (0, import_jsx_runtime.jsx)(Root, {
    align: "center",
    "data-ui": "SessionLayout",
    sizing: "border",
    children: (0, import_jsx_runtime.jsx)(Tooltip, {
      placement: "top",
      portal: true,
      content: (0, import_jsx_runtime.jsx)(Stack, {
        padding: 3,
        space: 3,
        children: (0, import_jsx_runtime.jsx)(Text, {
          size: 1,
          children: liveEdit ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
            children: ["Last updated", " ", (0, import_jsx_runtime.jsx)("abbr", {
              "aria-label": lastUpdated ? a11yUpdatedAgo : a11yPublishedAgo,
              children: lastUpdated ? lastUpdatedTimeAgo : lastPublishedTimeAgo
            })]
          }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
            children: ["Last published ", (0, import_jsx_runtime.jsx)("abbr", {
              "aria-label": a11yPublishedAgo,
              children: lastPublishedTimeAgo
            })]
          })
        })
      }),
      children: (0, import_jsx_runtime.jsx)(Button, {
        mode: "bleed",
        tone: liveEdit ? "critical" : "positive",
        tabIndex: -1,
        disabled,
        "aria-label": a11yLabel,
        children: (0, import_jsx_runtime.jsxs)(Flex, {
          align: "center",
          children: [(0, import_jsx_runtime.jsx)(Box, {
            marginRight: collapsed ? 0 : 3,
            children: (0, import_jsx_runtime.jsx)(Text, {
              size: 2,
              "aria-hidden": "true",
              children: liveEdit ? (0, import_jsx_runtime.jsx)(PlayIcon, {}) : (0, import_jsx_runtime.jsx)(PublishIcon, {})
            })
          }), !collapsed && (0, import_jsx_runtime.jsx)(Text, {
            size: 1,
            weight: "medium",
            children: liveEdit ? (0, import_jsx_runtime.jsx)("abbr", {
              "aria-label": a11yLabel,
              children: lastUpdated ? lastUpdatedTime : lastPublishedTime
            }) : (0, import_jsx_runtime.jsx)("abbr", {
              "aria-label": a11yLabel,
              children: lastPublishedTime
            })
          })]
        })
      })
    })
  });
}
var __freeze$3 = Object.freeze;
var __defProp$3 = Object.defineProperty;
var __template$3 = (cooked, raw) => __freeze$3(__defProp$3(cooked, "raw", {
  value: __freeze$3(raw || cooked.slice())
}));
var _a$3;
var _b;
var _c;
var StyledMotionPath = styled_components_browser_esm_default(motion.path)(_a$3 || (_a$3 = __template$3(["\n  transform-origin: center;\n"])));
var Circle = (props) => (0, import_jsx_runtime.jsx)(motion.circle, {
  fill: "none",
  r: "8",
  cx: "12.5",
  cy: "12.5",
  strokeWidth: "1.2",
  ...props
});
var Arrows = (props) => (0, import_jsx_runtime.jsx)(StyledMotionPath, {
  fill: "none",
  d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811",
  ...props
});
var Checkmark = (props) => (0, import_jsx_runtime.jsx)(motion.path, {
  d: "M9.5 12.1316L11.7414 14.5L16 10",
  ...props
});
var Edit = (props) => (0, import_jsx_runtime.jsx)(motion.path, {
  d: "M15 7L18 10M6 19L7 15L17 5L20 8L10 18L6 19Z",
  ...props
});
var rotateAnimation = We(_b || (_b = __template$3(["\n  0% {\n    transform: rotate(0);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n"])));
var RotateGroup = styled_components_browser_esm_default.g(_c || (_c = __template$3(["\n  transform-origin: center;\n\n  &[data-rotate] {\n    animation: ", " 1s ease-in-out infinite;\n  }\n"])), rotateAnimation);
var root = {
  syncing: {
    scale: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    scale: [1, 0.8, 1.2, 0.9, 1.1, 0.95, 1.05, 0.99, 1],
    transition: {
      duration: 0.5,
      delay: 0.2
    }
  },
  changes: {
    transition: {
      duration: 0
    }
  }
};
var circle = {
  syncing: {
    strokeDasharray: "0, 0, 23, 3, 23, 3",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    strokeDasharray: "0, 0, 23, 0, 23, 0",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    strokeDasharray: "0, 60, 23, 0, 23, 0",
    strokeDashoffset: 0,
    opacity: 0,
    transition: {
      duration: 0.5
    }
  }
};
var arrows = {
  syncing: {
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    opacity: 0,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    opacity: 0
  }
};
var checkmark = {
  syncing: {
    pathLength: 0,
    transition: {
      duration: 0
    }
  },
  saved: {
    pathLength: 1,
    transition: {
      delay: 0.4,
      duration: 0.3
    }
  },
  changes: {
    pathLength: 0,
    transition: {
      duration: 0.2
    }
  }
};
var edit = {
  syncing: {
    pathLength: 0,
    transition: {
      duration: 0
    }
  },
  saved: {
    pathLength: 0,
    transition: {
      duration: 0
    }
  },
  changes: {
    pathLength: 1,
    transition: {
      duration: 0.4,
      delay: 0.5
    }
  }
};
function AnimatedStatusIcon(props) {
  const {
    status
  } = props;
  if (!status) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "1.2",
    "data-sanity-icon": "",
    children: (0, import_jsx_runtime.jsxs)(motion.g, {
      variants: root,
      initial: status,
      animate: status,
      children: [(0, import_jsx_runtime.jsxs)(RotateGroup, {
        "data-rotate": status === "changes" ? void 0 : "",
        children: [(0, import_jsx_runtime.jsx)(Arrows, {
          variants: arrows,
          initial: status,
          animate: status
        }), (0, import_jsx_runtime.jsx)(Circle, {
          variants: circle,
          initial: status,
          animate: status
        })]
      }), (0, import_jsx_runtime.jsx)(Checkmark, {
        variants: checkmark,
        initial: status,
        animate: status
      }), (0, import_jsx_runtime.jsx)(Edit, {
        variants: edit,
        initial: status,
        animate: status
      })]
    })
  });
}
var ReviewButton = import_react.default.forwardRef(function ReviewButton2(props, ref) {
  const {
    collapsed,
    status,
    lastUpdated,
    ...rest
  } = props;
  const lastUpdatedTime = useTimeAgo(lastUpdated || "", {
    minimal: true
  });
  const lastUpdatedTimeAgo = useTimeAgo(lastUpdated || "", {
    minimal: true,
    agoSuffix: true
  });
  const a11yUpdatedAgo = useTimeAgo(lastUpdated || "", {
    minimal: false,
    agoSuffix: true
  });
  const buttonProps = (0, import_react.useMemo)(() => {
    if (status === "syncing") {
      return {
        text: "Saving...",
        tone: void 0
      };
    }
    if (status === "changes") {
      return {
        text: lastUpdatedTime,
        tone: "caution"
      };
    }
    if (status === "saved") {
      return {
        text: "Saved!",
        tone: "positive"
      };
    }
    return {};
  }, [status, lastUpdatedTime]);
  if (!status) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(Tooltip, {
    placement: "top",
    portal: true,
    disabled: status !== "changes",
    content: (0, import_jsx_runtime.jsxs)(Stack, {
      padding: 3,
      space: 3,
      children: [(0, import_jsx_runtime.jsx)(Text, {
        size: 1,
        weight: "semibold",
        children: "Review changes"
      }), (0, import_jsx_runtime.jsxs)(Text, {
        size: 1,
        muted: true,
        children: ["Changes saved ", (0, import_jsx_runtime.jsx)("abbr", {
          "aria-label": a11yUpdatedAgo,
          children: lastUpdatedTimeAgo
        })]
      })]
    }),
    children: (0, import_jsx_runtime.jsx)(Button, {
      mode: "bleed",
      justify: "flex-start",
      tone: buttonProps == null ? void 0 : buttonProps.tone,
      ...rest,
      "data-testid": "review-changes-button",
      ref,
      "aria-label": "Review changes",
      children: (0, import_jsx_runtime.jsxs)(Flex, {
        align: "center",
        children: [(0, import_jsx_runtime.jsx)(Box, {
          marginRight: collapsed ? 0 : 3,
          "aria-hidden": "true",
          children: (0, import_jsx_runtime.jsx)(Text, {
            children: (0, import_jsx_runtime.jsx)(AnimatedStatusIcon, {
              status
            })
          })
        }), !collapsed && (0, import_jsx_runtime.jsx)(Text, {
          size: 1,
          weight: "medium",
          children: buttonProps == null ? void 0 : buttonProps.text
        })]
      })
    })
  });
});
var ReviewChangesButton = import_react.default.memo(ReviewButton);
var SYNCING_TIMEOUT = 1e3;
var SAVED_TIMEOUT = 3e3;
var DocumentSparkline = (0, import_react.memo)(function DocumentSparkline2() {
  var _a2;
  const {
    changesOpen,
    documentId,
    documentType,
    editState,
    onHistoryClose,
    onHistoryOpen,
    timelineStore,
    value
  } = useDocumentPane();
  const syncState = useSyncState(documentId, documentType);
  const lastUpdated = value == null ? void 0 : value._updatedAt;
  const lastPublished = (_a2 = editState == null ? void 0 : editState.published) == null ? void 0 : _a2._updatedAt;
  const liveEdit = Boolean(editState == null ? void 0 : editState.liveEdit);
  const published = Boolean(editState == null ? void 0 : editState.published);
  const changed = Boolean(editState == null ? void 0 : editState.draft);
  const [rootFlexElement, setRootFlexElement] = (0, import_react.useState)(null);
  const rootFlexRect = useElementRect(rootFlexElement);
  const collapsed = !rootFlexRect || (rootFlexRect == null ? void 0 : rootFlexRect.width) < 300;
  const [status, setStatus] = (0, import_react.useState)(null);
  const showingRevision = useTimelineSelector(timelineStore, (state) => state.onOlderRevision);
  (0, import_react.useEffect)(() => {
    if (status === "syncing" && !syncState.isSyncing) {
      const timerId = setTimeout(() => setStatus("saved"), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }
    if (status === "saved") {
      const timerId = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId);
    }
  }, [status, lastUpdated, syncState.isSyncing]);
  (0, import_react.useLayoutEffect)(() => {
    setStatus(null);
  }, [documentId]);
  (0, import_react.useLayoutEffect)(() => {
    if (syncState.isSyncing) {
      setStatus("syncing");
    }
  }, [syncState.isSyncing, lastUpdated]);
  const reviewButton = (0, import_react.useMemo)(() => (0, import_jsx_runtime.jsx)(ReviewChangesButton, {
    lastUpdated,
    status: status || (changed ? "changes" : void 0),
    onClick: changesOpen ? onHistoryClose : onHistoryOpen,
    disabled: showingRevision,
    selected: changesOpen,
    collapsed
  }), [changed, changesOpen, onHistoryClose, onHistoryOpen, lastUpdated, showingRevision, status, collapsed]);
  const publishStatus = (0, import_react.useMemo)(() => (liveEdit || published) && (0, import_jsx_runtime.jsx)(Box, {
    marginRight: 1,
    children: (0, import_jsx_runtime.jsx)(PublishStatus, {
      disabled: showingRevision,
      lastPublished,
      lastUpdated,
      liveEdit,
      collapsed
    })
  }), [collapsed, lastPublished, lastUpdated, liveEdit, published, showingRevision]);
  return (0, import_jsx_runtime.jsxs)(Flex, {
    align: "center",
    "data-ui": "DocumentSparkline",
    ref: setRootFlexElement,
    children: [publishStatus, (0, import_jsx_runtime.jsxs)(Flex, {
      align: "center",
      flex: 1,
      children: [reviewButton, !collapsed && (0, import_jsx_runtime.jsx)(Box, {
        marginLeft: 3,
        children: (0, import_jsx_runtime.jsx)(DocumentBadges, {})
      })]
    })]
  });
});
var __freeze$2 = Object.freeze;
var __defProp$2 = Object.defineProperty;
var __template$2 = (cooked, raw) => __freeze$2(__defProp$2(cooked, "raw", {
  value: __freeze$2(raw || cooked.slice())
}));
var _a$2;
var DocumentActionsBox = styled_components_browser_esm_default(Box)(_a$2 || (_a$2 = __template$2(["\n  min-width: 10em;\n  max-width: 16em;\n"])));
function DocumentStatusBar(props) {
  const {
    actionsBoxRef
  } = props;
  const {
    badges,
    timelineStore
  } = useDocumentPane();
  const showingRevision = useTimelineSelector(timelineStore, (state) => state.onOlderRevision);
  return (0, import_react.useMemo)(() => (0, import_jsx_runtime.jsx)(Box, {
    paddingLeft: 2,
    paddingRight: [2, 3],
    paddingY: 2,
    children: (0, import_jsx_runtime.jsxs)(Flex, {
      align: "center",
      children: [(0, import_jsx_runtime.jsx)(Box, {
        flex: [1, 2],
        children: badges && (0, import_jsx_runtime.jsx)(DocumentSparkline, {})
      }), (0, import_jsx_runtime.jsx)(DocumentActionsBox, {
        flex: 1,
        marginLeft: [1, 3],
        ref: actionsBoxRef,
        children: showingRevision ? (0, import_jsx_runtime.jsx)(HistoryStatusBarActions, {}) : (0, import_jsx_runtime.jsx)(DocumentStatusBarActions, {})
      })]
    })
  }), [actionsBoxRef, badges, showingRevision]);
}
function KeyboardShortcutResponder(props) {
  const {
    actionsBoxElement,
    activeIndex,
    as = "div",
    children,
    id,
    onActionStart,
    onKeyDown,
    rootRef,
    states,
    ...rest
  } = props;
  const activeAction = states[activeIndex];
  const handleKeyDown = (0, import_react.useCallback)((event) => {
    const matchingStates = states.filter((state) => state.shortcut && (0, import_is_hotkey.default)(state.shortcut, event));
    const matchingState = matchingStates[0];
    if (matchingStates.length > 1) {
      console.warn('Keyboard shortcut conflict: More than one document action matches the shortcut "'.concat(matchingState.shortcut, '"'));
    }
    if (matchingState && !matchingState.disabled && matchingState.onHandle) {
      event.preventDefault();
      matchingState.onHandle();
      onActionStart(states.indexOf(matchingState));
      return;
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [onActionStart, onKeyDown, states]);
  return (0, import_react.createElement)(as, {
    id,
    onKeyDown: handleKeyDown,
    tabIndex: -1,
    ...rest,
    ref: rootRef
  }, [children, activeAction && activeAction.dialog && (0, import_jsx_runtime.jsx)(LegacyLayerProvider, {
    zOffset: "paneFooter",
    children: (0, import_jsx_runtime.jsx)(ActionStateDialog, {
      dialog: activeAction.dialog,
      referenceElement: actionsBoxElement
    })
  })]);
}
var DocumentActionShortcuts = import_react.default.memo((props) => {
  const {
    actionsBoxElement,
    as = "div",
    children,
    ...rest
  } = props;
  const {
    actions,
    editState
  } = useDocumentPane();
  const [activeIndex, setActiveIndex] = (0, import_react.useState)(-1);
  const onActionStart = (0, import_react.useCallback)((idx) => {
    setActiveIndex(idx);
  }, []);
  const actionProps = (0, import_react.useMemo)(() => editState && {
    ...editState,
    // @todo: what to call here?
    onComplete: () => void 0,
    // @todo: get revision string
    revision: void 0
  }, [editState]);
  if (!actionProps || !actions)
    return null;
  return (0, import_jsx_runtime.jsx)(RenderActionCollectionState, {
    actionProps,
    actions,
    children: (_ref21) => {
      let {
        states
      } = _ref21;
      return (0, import_jsx_runtime.jsx)(KeyboardShortcutResponder, {
        ...rest,
        activeIndex,
        actionsBoxElement,
        as,
        onActionStart,
        states,
        children
      });
    }
  });
});
DocumentActionShortcuts.displayName = "DocumentActionShortcuts";
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1;
var DIALOG_PROVIDER_POSITION = [
  // We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
  "fixed",
  "fixed",
  // And we use the `position: absolute` strategy (within panes) on wide screens.
  "absolute"
];
var StyledChangeConnectorRoot = styled_components_browser_esm_default(ChangeConnectorRoot)(_a$1 || (_a$1 = __template$1(["\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  min-height: 0;\n  min-width: 0;\n"])));
var DocumentPane = (0, import_react.memo)(function DocumentPane2(props) {
  const {
    name: parentSourceName
  } = useSource();
  return (0, import_jsx_runtime.jsx)(SourceProvider, {
    name: props.pane.source || parentSourceName,
    children: (0, import_jsx_runtime.jsx)(DocumentPaneInner, {
      ...props
    })
  });
});
function DocumentPaneInner(props) {
  var _a2;
  const {
    pane,
    paneKey
  } = props;
  const {
    resolveNewDocumentOptions
  } = useSource().document;
  const paneRouter = usePaneRouter();
  const options = usePaneOptions(pane.options, paneRouter.params);
  const {
    documentType,
    isLoaded: isDocumentLoaded
  } = useDocumentType(options.id, options.type);
  const templateItems = (0, import_react.useMemo)(() => {
    return resolveNewDocumentOptions({
      type: "document",
      documentId: options.id,
      schemaType: options.type
    });
  }, [options.id, options.type, resolveNewDocumentOptions]);
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({
    templateItems
  });
  const isLoaded = isDocumentLoaded && !isTemplatePermissionsLoading;
  const providerProps = (0, import_react.useMemo)(() => {
    return isLoaded && documentType && options.type !== documentType ? mergeDocumentType(props, options, documentType) : props;
  }, [props, documentType, isLoaded, options]);
  const {
    ReferenceChildLink: ReferenceChildLink2,
    handleEditReference,
    groupIndex,
    routerPanesState
  } = paneRouter;
  const childParams = ((_a2 = routerPanesState[groupIndex + 1]) == null ? void 0 : _a2[0].params) || {};
  const routerPanesStateLength = routerPanesState.length;
  const {
    parentRefPath
  } = childParams;
  const activePath = (0, import_react.useMemo)(() => {
    return parentRefPath ? {
      path: fromString(parentRefPath),
      state: (
        // eslint-disable-next-line no-nested-ternary
        groupIndex >= routerPanesStateLength - 1 ? "none" : groupIndex >= routerPanesStateLength - 2 ? "selected" : "pressed"
      )
    } : {
      path: [],
      state: "none"
    };
  }, [parentRefPath, groupIndex, routerPanesStateLength]);
  if (options.type === "*" && !isLoaded) {
    return (0, import_jsx_runtime.jsx)(LoadingPane, {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: "Loading document…"
    });
  }
  if (!documentType) {
    return (0, import_jsx_runtime.jsx)(ErrorPane, {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
        children: "The document was not found"
      }),
      children: (0, import_jsx_runtime.jsx)(Stack, {
        space: 4,
        children: (0, import_jsx_runtime.jsxs)(Text, {
          as: "p",
          children: ["The document type is not defined, and a document with the ", (0, import_jsx_runtime.jsx)("code", {
            children: options.id
          }), " ", "identifier could not be found."]
        })
      })
    });
  }
  return (0, import_jsx_runtime.jsx)(DocumentPaneProvider, {
    ...providerProps,
    children: (0, import_jsx_runtime.jsx)(ReferenceInputOptionsProvider, {
      EditReferenceLinkComponent: ReferenceChildLink2,
      onEditReference: handleEditReference,
      initialValueTemplateItems: templatePermissions,
      activePath,
      children: (0, import_jsx_runtime.jsx)(InnerDocumentPane, {})
    })
  }, "".concat(documentType, "-").concat(options.id));
}
function usePaneOptions(options) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const templates = useTemplates();
  return (0, import_react.useMemo)(() => {
    if (options.type && options.type !== "*") {
      return options;
    }
    const templateName = options.template || params.template;
    const template = templateName ? templates.find((t) => t.id === templateName) : void 0;
    const documentType = template == null ? void 0 : template.schemaType;
    if (!documentType) {
      return options;
    }
    return {
      ...options,
      type: documentType
    };
  }, [options, params.template, templates]);
}
function mergeDocumentType(props, options, documentType) {
  return {
    ...props,
    pane: {
      ...props.pane,
      options: {
        ...options,
        type: documentType
      }
    }
  };
}
function InnerDocumentPane() {
  const {
    changesOpen,
    documentType,
    inspector,
    inspectOpen,
    onFocus,
    onPathOpen,
    onHistoryOpen,
    onKeyUp,
    paneKey,
    schemaType,
    value
  } = useDocumentPane();
  const {
    collapsed: layoutCollapsed
  } = usePaneLayout();
  const zOffsets = useZIndex();
  const [rootElement, setRootElement] = (0, import_react.useState)(null);
  const [footerElement, setFooterElement] = (0, import_react.useState)(null);
  const [actionsBoxElement, setActionsBoxElement] = (0, import_react.useState)(null);
  const [documentPanelPortalElement, setDocumentPanelPortalElement] = (0, import_react.useState)(null);
  const footerRect = useElementRect(footerElement);
  const footerH = footerRect == null ? void 0 : footerRect.height;
  const onConnectorSetFocus = (0, import_react.useCallback)((path) => {
    onPathOpen(path);
    onFocus(path);
  }, [onPathOpen, onFocus]);
  const currentMinWidth = DOCUMENT_PANEL_INITIAL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0);
  const minWidth = DOCUMENT_PANEL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0);
  if (!schemaType) {
    return (0, import_jsx_runtime.jsx)(ErrorPane, {
      currentMinWidth,
      flex: 2.5,
      minWidth,
      paneKey,
      title: (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
        children: ["Unknown document type: ", (0, import_jsx_runtime.jsx)("code", {
          children: documentType
        })]
      }),
      tone: "caution",
      children: (0, import_jsx_runtime.jsxs)(Stack, {
        space: 4,
        children: [documentType && (0, import_jsx_runtime.jsxs)(Text, {
          as: "p",
          children: ["This document has the schema type ", (0, import_jsx_runtime.jsx)("code", {
            children: documentType
          }), ", which is not defined as a type in the local content studio schema."]
        }), !documentType && (0, import_jsx_runtime.jsx)(Text, {
          as: "p",
          children: "This document does not exist, and no schema type was specified for it."
        }), isDev && value && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
          children: [(0, import_jsx_runtime.jsx)(Text, {
            as: "p",
            children: "Here is the JSON representation of the document:"
          }), (0, import_jsx_runtime.jsx)(Card, {
            padding: 3,
            overflow: "auto",
            radius: 2,
            shadow: 1,
            tone: "inherit",
            children: (0, import_jsx_runtime.jsx)(Code, {
              language: "json",
              size: [1, 1, 2],
              children: JSON.stringify(value, null, 2)
            })
          })]
        })]
      })
    });
  }
  return (0, import_jsx_runtime.jsxs)(DocumentActionShortcuts, {
    actionsBoxElement,
    as: Pane,
    currentMinWidth,
    "data-testid": "document-pane",
    flex: 2.5,
    id: paneKey,
    minWidth,
    onKeyUp,
    rootRef: setRootElement,
    children: [(0, import_jsx_runtime.jsx)(DialogProvider, {
      position: DIALOG_PROVIDER_POSITION,
      zOffset: zOffsets.portal,
      children: (0, import_jsx_runtime.jsx)(Flex, {
        direction: "column",
        flex: 1,
        height: layoutCollapsed ? void 0 : "fill",
        children: (0, import_jsx_runtime.jsx)(StyledChangeConnectorRoot, {
          "data-testid": "change-connector-root",
          isReviewChangesOpen: changesOpen,
          onOpenReviewChanges: onHistoryOpen,
          onSetFocus: onConnectorSetFocus,
          children: (0, import_jsx_runtime.jsx)(DocumentPanel, {
            footerHeight: footerH || null,
            isInspectOpen: inspectOpen,
            rootElement,
            setDocumentPanelPortalElement
          })
        })
      })
    }), (0, import_jsx_runtime.jsx)(PortalProvider, {
      __unstable_elements: {
        [DOCUMENT_PANEL_PORTAL_ELEMENT]: documentPanelPortalElement
      },
      children: (0, import_jsx_runtime.jsx)(DialogProvider, {
        position: DIALOG_PROVIDER_POSITION,
        zOffset: zOffsets.portal,
        children: (0, import_jsx_runtime.jsx)(PaneFooter, {
          ref: setFooterElement,
          children: (0, import_jsx_runtime.jsx)(DocumentStatusBar, {
            actionsBoxRef: setActionsBoxElement
          })
        })
      })
    }), (0, import_jsx_runtime.jsx)(DocumentOperationResults, {})]
  });
}
function NoDocumentTypesScreen() {
  return (0, import_jsx_runtime.jsx)(Card, {
    height: "fill",
    children: (0, import_jsx_runtime.jsx)(Flex, {
      align: "center",
      height: "fill",
      justify: "center",
      padding: 4,
      sizing: "border",
      children: (0, import_jsx_runtime.jsx)(Container, {
        width: 0,
        children: (0, import_jsx_runtime.jsx)(Card, {
          padding: 4,
          radius: 2,
          shadow: 1,
          tone: "caution",
          children: (0, import_jsx_runtime.jsxs)(Flex, {
            children: [(0, import_jsx_runtime.jsx)(Box, {
              children: (0, import_jsx_runtime.jsx)(Text, {
                size: 1,
                children: (0, import_jsx_runtime.jsx)(WarningOutlineIcon, {})
              })
            }), (0, import_jsx_runtime.jsxs)(Stack, {
              flex: 1,
              marginLeft: 3,
              space: 3,
              children: [(0, import_jsx_runtime.jsx)(Text, {
                as: "h1",
                size: 1,
                weight: "bold",
                children: "No document types"
              }), (0, import_jsx_runtime.jsx)(Text, {
                as: "p",
                muted: true,
                size: 1,
                children: "Please define at least one document type in your schema."
              }), (0, import_jsx_runtime.jsx)(Text, {
                as: "p",
                muted: true,
                size: 1,
                children: (0, import_jsx_runtime.jsx)("a", {
                  href: "https://www.sanity.io/docs/create-a-schema-and-configure-sanity-studio",
                  target: "_blank",
                  rel: "noreferrer",
                  children: "Learn how to add a document type →"
                })
              })]
            })]
          })
        })
      })
    })
  });
}
var DocumentTitle = (props) => {
  const {
    documentId,
    documentType
  } = props;
  const editState = useEditState(documentId, documentType);
  const schema = useSchema();
  const isNewDocument = !(editState == null ? void 0 : editState.published) && !(editState == null ? void 0 : editState.draft);
  const documentValue = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published);
  const schemaType = schema.get(documentType);
  const {
    value,
    isLoading: previewValueIsLoading
  } = useDocumentPreview({
    enabled: true,
    schemaType,
    value: documentValue
  });
  const documentTitle = isNewDocument ? "New ".concat((schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)) : (value == null ? void 0 : value.title) || "Untitled";
  const settled = editState.ready && !previewValueIsLoading;
  const newTitle = useConstructDocumentTitle(documentTitle);
  (0, import_react.useEffect)(() => {
    if (!settled)
      return;
    document.title = newTitle;
  }, [documentTitle, settled, newTitle]);
  return null;
};
var PassthroughTitle = (props) => {
  const {
    title
  } = props;
  const newTitle = useConstructDocumentTitle(title);
  (0, import_react.useEffect)(() => {
    document.title = newTitle;
  }, [newTitle, title]);
  return null;
};
var DeskTitle = (props) => {
  const {
    resolvedPanes
  } = props;
  if (!(resolvedPanes == null ? void 0 : resolvedPanes.length))
    return null;
  const lastPane = resolvedPanes[resolvedPanes.length - 1];
  if (isLoadingPane(lastPane)) {
    return (0, import_jsx_runtime.jsx)(PassthroughTitle, {});
  }
  if (isDocumentPane(lastPane)) {
    if (lastPane == null ? void 0 : lastPane.title) {
      return (0, import_jsx_runtime.jsx)(PassthroughTitle, {
        title: lastPane.title
      });
    }
    return (0, import_jsx_runtime.jsx)(DocumentTitle, {
      documentId: lastPane.options.id,
      documentType: lastPane.options.type
    });
  }
  return (0, import_jsx_runtime.jsx)(PassthroughTitle, {
    title: lastPane == null ? void 0 : lastPane.title
  });
};
function useConstructDocumentTitle(activeTitle) {
  const deskToolBaseTitle = useDeskTool().structureContext.title;
  return [activeTitle, deskToolBaseTitle].filter((title) => title).join(" | ");
}
function isDocumentPane(pane) {
  return pane !== LOADING_PANE && pane.type === "document";
}
function isLoadingPane(pane) {
  return pane === LOADING_PANE;
}
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a;
var StyledPaneLayout = styled_components_browser_esm_default(PaneLayout)(_a || (_a = __template(["\n  min-height: 100%;\n  min-width: 320px;\n"])));
var isSaveHotkey = (0, import_is_hotkey.default)("mod+s");
var DeskTool = (0, import_react.memo)(function DeskTool2(_ref22) {
  let {
    onPaneChange
  } = _ref22;
  var _a2;
  const {
    push: pushToast
  } = useToast();
  const schema = useSchema();
  const {
    layoutCollapsed,
    setLayoutCollapsed
  } = useDeskTool();
  const {
    paneDataItems,
    resolvedPanes
  } = useResolvedPanes();
  const isResolvingIntent = useRouterState((0, import_react.useCallback)((routerState) => typeof routerState.intent === "string", []));
  const {
    sanity: {
      media
    }
  } = useTheme();
  const [portalElement, setPortalElement] = (0, import_react.useState)(null);
  const handleRootCollapse = (0, import_react.useCallback)(() => setLayoutCollapsed(true), [setLayoutCollapsed]);
  const handleRootExpand = (0, import_react.useCallback)(() => setLayoutCollapsed(false), [setLayoutCollapsed]);
  (0, import_react.useEffect)(() => {
    if (resolvedPanes.length) {
      onPaneChange(resolvedPanes);
    }
  }, [onPaneChange, resolvedPanes]);
  (0, import_react.useEffect)(() => {
    const handleGlobalKeyDown = (event) => {
      if (isSaveHotkey(event)) {
        event.preventDefault();
        pushToast({
          closable: true,
          id: "auto-save-message",
          status: "info",
          title: "Your work is automatically saved!",
          duration: 4e3
        });
      }
    };
    window.addEventListener("keydown", handleGlobalKeyDown);
    return () => window.removeEventListener("keydown", handleGlobalKeyDown);
  }, [pushToast]);
  const hasDefinedDocumentTypes = (_a2 = schema._original) == null ? void 0 : _a2.types.some(_isCustomDocumentTypeDefinition);
  if (!hasDefinedDocumentTypes) {
    return (0, import_jsx_runtime.jsx)(NoDocumentTypesScreen, {});
  }
  return (0, import_jsx_runtime.jsxs)(PortalProvider, {
    element: portalElement || null,
    children: [(0, import_jsx_runtime.jsxs)(StyledPaneLayout, {
      flex: 1,
      height: layoutCollapsed ? void 0 : "fill",
      minWidth: media[1],
      onCollapse: handleRootCollapse,
      onExpand: handleRootExpand,
      children: [paneDataItems.map((_ref23) => {
        let {
          active,
          childItemId,
          groupIndex,
          itemId,
          key: paneKey,
          pane,
          index: paneIndex,
          params: paneParams,
          path,
          payload,
          siblingIndex,
          selected
        } = _ref23;
        return (0, import_jsx_runtime.jsx)(import_react.Fragment, {
          children: pane === LOADING_PANE ? (0, import_jsx_runtime.jsx)(LoadingPane, {
            paneKey,
            path,
            selected
          }) : (0, import_jsx_runtime.jsx)(DeskToolPane, {
            active,
            groupIndex,
            index: paneIndex,
            pane,
            childItemId,
            itemId,
            paneKey,
            params: paneParams,
            payload,
            path,
            selected,
            siblingIndex
          })
        }, "".concat(pane === LOADING_PANE ? "loading" : pane.type, "-").concat(paneIndex));
      }), paneDataItems.length <= 1 && isResolvingIntent && (0, import_jsx_runtime.jsx)(LoadingPane, {
        paneKey: "intent-resolver"
      })]
    }), (0, import_jsx_runtime.jsx)(DeskTitle, {
      resolvedPanes
    }), (0, import_jsx_runtime.jsx)("div", {
      "data-portal": "",
      ref: setPortalElement
    })]
  });
});
function DeskToolBoundary(_ref24) {
  let {
    tool: {
      options
    }
  } = _ref24;
  const {
    unstable_sources: sources
  } = useWorkspace();
  const [firstSource] = sources;
  const {
    source,
    defaultDocumentNode,
    structure
  } = options || {};
  (0, import_react.useEffect)(() => {
    setActivePanes([]);
    return () => setActivePanes([]);
  }, []);
  const [{
    error
  }, setError] = (0, import_react.useState)({
    error: null
  });
  if (error)
    return (0, import_jsx_runtime.jsx)(StructureError, {
      error
    });
  return (0, import_jsx_runtime.jsx)(ErrorBoundary, {
    onCatch: setError,
    children: (0, import_jsx_runtime.jsx)(SourceProvider, {
      name: source || firstSource.name,
      children: (0, import_jsx_runtime.jsxs)(DeskToolProvider, {
        defaultDocumentNode,
        structure,
        children: [(0, import_jsx_runtime.jsx)(DeskTool, {
          onPaneChange: setActivePanes
        }), (0, import_jsx_runtime.jsx)(IntentResolver, {})]
      })
    })
  });
}
var index = Object.freeze({
  __proto__: null,
  default: DeskToolBoundary
});

export {
  useDeskToolSetting,
  DocumentPane,
  index
};
//# sourceMappingURL=chunk-HWZQ7WXM.js.map
