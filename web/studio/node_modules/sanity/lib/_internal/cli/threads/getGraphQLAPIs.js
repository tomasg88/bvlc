'use strict';

var worker_threads = require('worker_threads');
var oneline = require('oneline');
var isPlainObject = require('lodash/isPlainObject.js');
var fs = require('fs');
var path = require('path');
var rxjs = require('rxjs');
var mockBrowserEnvironment = require('../../../_chunks/mockBrowserEnvironment-c2429216.js');
var sanity = require('sanity');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var oneline__default = /*#__PURE__*/_interopDefaultCompat(oneline);
var isPlainObject__default = /*#__PURE__*/_interopDefaultCompat(isPlainObject);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
const candidates = ["sanity.config.js", "sanity.config.jsx", "sanity.config.ts", "sanity.config.tsx"];
async function getStudioConfig(options) {
  let workspaces;
  const {
    basePath,
    configPath: cfgPath
  } = options;
  let cleanup;
  try {
    cleanup = mockBrowserEnvironment.mockBrowserEnvironment(basePath);
    let configPath = cfgPath;
    if (configPath && !fs__default.default.existsSync(configPath)) {
      throw new Error('Failed to find config at "'.concat(cfgPath, '"'));
    } else if (!configPath) {
      configPath = candidates.map(candidate => path__default.default.join(basePath, candidate)).find(candidate => fs__default.default.existsSync(candidate));
    }
    if (!configPath) {
      throw new Error('Failed to resolve sanity.config.(js|ts) for base path "'.concat(basePath, '"'));
    }
    let config;
    try {
      const mod = require(configPath);
      config = mod.__esModule && mod.default ? mod.default : mod;
    } catch (err) {
      throw new Error('Failed to load configuration file "'.concat(configPath, '":\n').concat(err.message));
    }
    if (!config) {
      throw new Error("Configuration did not export expected config shape");
    }
    workspaces = await rxjs.firstValueFrom(sanity.resolveConfig(config));
  } catch (error) {
    if (cleanup) {
      cleanup();
    }
    throw error;
  }
  cleanup();
  if (!workspaces) {
    throw new Error("Failed to resolve configuration");
  }
  return workspaces;
}
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a;
if (worker_threads.isMainThread || !worker_threads.parentPort) {
  throw new Error("This module must be run as a worker thread");
}
getGraphQLAPIsForked(worker_threads.parentPort);
async function getGraphQLAPIsForked(parent) {
  const {
    cliConfig,
    cliConfigPath,
    workDir
  } = worker_threads.workerData;
  const resolved = await resolveGraphQLApis({
    cliConfig,
    cliConfigPath,
    workDir
  });
  parent.postMessage(resolved);
}
async function resolveGraphQLApis(_ref) {
  let {
    cliConfig,
    cliConfigPath,
    workDir
  } = _ref;
  const workspaces = await getStudioConfig({
    basePath: workDir
  });
  const numSources = workspaces.reduce((count, workspace) => count + workspace.unstable_sources.length, 0);
  const multiSource = numSources > 1;
  const multiWorkspace = workspaces.length > 1;
  const hasGraphQLConfig = Boolean(cliConfig == null ? void 0 : cliConfig.graphql);
  if (workspaces.length === 0) {
    throw new Error("No studio configuration found");
  }
  if (numSources === 0) {
    throw new Error("No sources (project ID / dataset) configured");
  }
  if ((multiWorkspace || multiSource) && !hasGraphQLConfig) {
    throw new Error(oneline__default.default(_a || (_a = __template(["\n      Multiple workspaces/sources configured.\n      You must define an array of GraphQL APIs in ", "\n      and specify which workspace/source to use.\n    "])), cliConfigPath || "sanity.cli.js"));
  }
  if (!hasGraphQLConfig) {
    const {
      projectId,
      dataset,
      schema
    } = workspaces[0].unstable_sources[0];
    return [{
      schemaTypes: getStrippedSchemaTypes(schema),
      projectId,
      dataset
    }];
  }
  const apiDefs = validateCliConfig((cliConfig == null ? void 0 : cliConfig.graphql) || []);
  return resolveGraphQLAPIsFromConfig(apiDefs, workspaces);
}
function resolveGraphQLAPIsFromConfig(apiDefs, workspaces) {
  const resolvedApis = [];
  for (const apiDef of apiDefs) {
    const {
      workspace: workspaceName,
      source: sourceName
    } = apiDef;
    if (!workspaceName && workspaces.length > 1) {
      throw new Error("Must define `workspace` name in GraphQL API config when multiple workspaces are defined");
    }
    const workspace = !workspaceName && workspaces.length === 1 ? workspaces[0] : workspaces.find(space => space.name === (workspaceName || "default"));
    if (!workspace) {
      throw new Error('Workspace "'.concat(workspaceName || "default", '" not found'));
    }
    const source = !sourceName && workspace.unstable_sources.length === 1 ? workspace.unstable_sources[0] : workspace.unstable_sources.find(src => src.name === (sourceName || "default"));
    if (!source) {
      throw new Error('Source "'.concat(sourceName || "default", '" not found in workspace "').concat(workspaceName || "default", '"'));
    }
    resolvedApis.push({
      ...apiDef,
      dataset: source.dataset,
      projectId: source.projectId,
      schemaTypes: getStrippedSchemaTypes(source.schema)
    });
  }
  return resolvedApis;
}
function validateCliConfig(config) {
  let configPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "sanity.cli.js";
  if (!Array.isArray(config)) {
    throw new Error('"graphql" key in "'.concat(configPath, '" must be an array if defined'));
  }
  if (config.length === 0) {
    throw new Error('No GraphQL APIs defined in "'.concat(configPath, '"'));
  }
  return config;
}
function getStrippedSchemaTypes(schema) {
  const schemaDef = schema._original || {
    types: []
  };
  return schemaDef.types.map(type => stripType(type));
}
function stripType(input) {
  return strip(input);
}
function strip(input) {
  if (Array.isArray(input)) {
    return input.map(item => strip(item)).filter(item => typeof item !== "undefined");
  }
  if (isPlainishObject(input)) {
    return Object.keys(input).reduce((stripped, key) => {
      stripped[key] = strip(input[key]);
      return stripped;
    }, {});
  }
  return isBasicType(input) ? input : void 0;
}
function isPlainishObject(input) {
  return isPlainObject__default.default(input);
}
function isBasicType(input) {
  const type = typeof input;
  if (type === "boolean" || type === "number" || type === "string") {
    return true;
  }
  if (type !== "object") {
    return false;
  }
  return Array.isArray(input) || input === null || isPlainishObject(input);
}
//# sourceMappingURL=getGraphQLAPIs.js.map
