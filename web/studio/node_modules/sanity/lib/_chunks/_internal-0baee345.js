'use strict';

var debug$1 = require('debug');
var yargs = require('yargs/yargs');
var helpers = require('yargs/helpers');
var path = require('path');
var fs$1 = require('fs/promises');
var prettyMs = require('pretty-ms');
var fs = require('@sanity/util/fs');
var exportDataset = require('@sanity/export');
var fs$2 = require('fs');
var getIt = require('get-it');
var middleware = require('get-it/middleware');
var sanityImport = require('@sanity/import');
var padStart = require('lodash/padStart');
var EventSource = require('@sanity/eventsource');
var rxjs = require('rxjs');
var dateFns = require('date-fns');
var consoleTablePrinter = require('console-table-printer');
var oneline = require('oneline');
var tokenize = require('json-lexer');
var pluralize = require('pluralize-esm');
var os = require('os');
var json5 = require('json5');
var execa = require('execa');
var chokidar = require('chokidar');
var isPlainObject = require('lodash/isPlainObject.js');
var isEqual = require('lodash/isEqual.js');
var noop$1 = require('lodash/noop.js');
var uuid = require('@sanity/uuid');
var open = require('open');
var util = require('util');
var groupBy = require('lodash/groupBy.js');
var url = require('url');
var logSymbols = require('log-symbols');
var sortBy = require('lodash/sortBy.js');
var size = require('lodash/size.js');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var debug__default = /*#__PURE__*/_interopDefaultCompat(debug$1);
var yargs__default = /*#__PURE__*/_interopDefaultCompat(yargs);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs$1);
var prettyMs__default = /*#__PURE__*/_interopDefaultCompat(prettyMs);
var exportDataset__default = /*#__PURE__*/_interopDefaultCompat(exportDataset);
var fs__default$1 = /*#__PURE__*/_interopDefaultCompat(fs$2);
var sanityImport__default = /*#__PURE__*/_interopDefaultCompat(sanityImport);
var padStart__default = /*#__PURE__*/_interopDefaultCompat(padStart);
var EventSource__default = /*#__PURE__*/_interopDefaultCompat(EventSource);
var oneline__default = /*#__PURE__*/_interopDefaultCompat(oneline);
var tokenize__default = /*#__PURE__*/_interopDefaultCompat(tokenize);
var pluralize__default = /*#__PURE__*/_interopDefaultCompat(pluralize);
var os__default = /*#__PURE__*/_interopDefaultCompat(os);
var json5__default = /*#__PURE__*/_interopDefaultCompat(json5);
var execa__default = /*#__PURE__*/_interopDefaultCompat(execa);
var chokidar__default = /*#__PURE__*/_interopDefaultCompat(chokidar);
var isPlainObject__default = /*#__PURE__*/_interopDefaultCompat(isPlainObject);
var isEqual__default = /*#__PURE__*/_interopDefaultCompat(isEqual);
var noop__default = /*#__PURE__*/_interopDefaultCompat(noop$1);
var open__default = /*#__PURE__*/_interopDefaultCompat(open);
var groupBy__default = /*#__PURE__*/_interopDefaultCompat(groupBy);
var url__default = /*#__PURE__*/_interopDefaultCompat(url);
var logSymbols__default = /*#__PURE__*/_interopDefaultCompat(logSymbols);
var sortBy__default = /*#__PURE__*/_interopDefaultCompat(sortBy);
var size__default = /*#__PURE__*/_interopDefaultCompat(size);
const helpText$o = "\nOptions\n  --source-maps Enable source maps for built bundles (increases size of bundle)\n  --no-minify Skip minifying built JavaScript (speeds up build, increases size of bundle)\n  -y, --yes Use unattended mode, accepting defaults and using only flags for choices\n\nExamples\n  sanity build\n  sanity build --no-minify --source-maps\n";
const buildCommand = {
  name: "build",
  signature: "[OUTPUT_DIR]",
  description: "Builds the current Sanity configuration to a static bundle",
  action: async (args, context, overrides) => {
    const buildAction = await getBuildAction();
    return buildAction(args, context, overrides);
  },
  helpText: helpText$o
};
async function getBuildAction() {
  const mod = await Promise.resolve().then(function () {
    return require('./buildAction-51ccc980.js');
  });
  return mod.default;
}
const checkCommand = {
  name: "check",
  signature: "",
  description: "[deprecated]",
  helpText: "",
  hideFromHelp: true,
  action: (_args, context) => {
    const {
      output
    } = context;
    output.print("`sanity check` is deprecated and no longer has any effect");
    return Promise.resolve();
  }
};
const configCheckCommand = {
  name: "configcheck",
  signature: "",
  description: "Checks if the required configuration files for plugins exists and are up to date",
  helpText: "",
  hideFromHelp: true,
  action: async (args, context) => {
    context.output.error("`sanity configcheck` is no longer required/used");
    return Promise.resolve();
  }
};
var datasetGroup = {
  name: "dataset",
  signature: "[COMMAND]",
  isGroupRoot: true,
  description: "Interact with datasets in your project"
};
const helpText$n = "\nOptions\n  --source-maps Enable source maps for built bundles (increases size of bundle)\n  --no-minify Skip minifying built JavaScript (speeds up build, increases size of bundle)\n  --no-build Don't build the studio prior to deploy, instead deploying the version currently in `dist/`\n\nExamples\n  sanity deploy\n  sanity deploy --no-minify --source-maps\n";
const deployCommand = {
  name: "deploy",
  signature: "[SOURCE_DIR] [--no-build]  [--source-maps] [--no-minify]",
  description: "Deploys a statically built Sanity studio",
  action: async (args, context) => {
    const mod = await Promise.resolve().then(function () {
      return require('./deployAction-0abbde76.js');
    });
    return mod.default(args, context);
  },
  helpText: helpText$n
};
const helpText$m = "\nExamples\n  sanity undeploy\n";
const undeployCommand = {
  name: "undeploy",
  signature: "",
  description: "Removes the deployed studio from <hostname>.sanity.studio",
  action: async (args, context) => {
    const mod = await Promise.resolve().then(function () {
      return require('./undeployAction-1ad17480.js');
    });
    return mod.default(args, context);
  },
  helpText: helpText$m
};
const MAX_DATASET_NAME_LENGTH$1 = 64;
function validateDatasetAliasName(datasetName) {
  if (!datasetName) {
    return "Alias name is missing";
  }
  const name = "".concat(datasetName);
  if (name.toLowerCase() !== name) {
    return "Alias name must be all lowercase characters";
  }
  if (name.length < 2) {
    return "Alias name must be at least two characters long";
  }
  if (name.length > MAX_DATASET_NAME_LENGTH$1) {
    return "Alias name must be at most ".concat(MAX_DATASET_NAME_LENGTH$1, " characters");
  }
  if (!/^[a-z0-9~]/.test(name)) {
    return "Alias name must start with a letter or a number";
  }
  if (!/^[a-z0-9~][-_a-z0-9]+$/.test(name)) {
    return "Alias name must only contain letters, numbers, dashes and underscores";
  }
  if (/[-_]$/.test(name)) {
    return "Alias name must not end with a dash or an underscore";
  }
  return false;
}
const ALIAS_PREFIX = "~";
function listAliases(client) {
  return client.request({
    uri: "/aliases"
  });
}
function createAlias(client, aliasName, datasetName) {
  return modify(client, "PUT", aliasName, datasetName ? {
    datasetName
  } : void 0);
}
function updateAlias(client, aliasName, datasetName) {
  return modify(client, "PATCH", aliasName, datasetName ? {
    datasetName
  } : void 0);
}
function unlinkAlias(client, aliasName) {
  return modify(client, "PATCH", "".concat(aliasName, "/unlink"), {});
}
function removeAlias(client, aliasName) {
  return modify(client, "DELETE", aliasName);
}
function modify(client, method, aliasName, body) {
  return client.request({
    method,
    uri: "/aliases/".concat(aliasName),
    body
  });
}
const listAliasesHandler = async (args, context) => {
  const {
    apiClient,
    output
  } = context;
  const client = apiClient();
  const aliases = await listAliases(client);
  output.print(aliases.map(set => "".concat(ALIAS_PREFIX).concat(set.name, " -> ").concat(set.datasetName || "<unlinked>")).join("\n"));
};
const listDatasetsCommand = {
  name: "list",
  group: "dataset",
  helpText: "",
  signature: "",
  description: "List datasets of your project",
  action: async (args, context) => {
    const {
      apiClient,
      output
    } = context;
    const client = apiClient();
    const datasets = await client.datasets.list();
    output.print(datasets.map(set => set.name).join("\n"));
    await listAliasesHandler(args, context);
  }
};
const debug = debug__default.default("sanity:core");
const MAX_DATASET_NAME_LENGTH = 64;
function validateDatasetName(datasetName) {
  if (!datasetName) {
    return "Dataset name is missing";
  }
  const name = "".concat(datasetName);
  if (name.toLowerCase() !== name) {
    return "Dataset name must be all lowercase characters";
  }
  if (name.length < 2) {
    return "Dataset name must be at least two characters long";
  }
  if (name.length > MAX_DATASET_NAME_LENGTH) {
    return "Dataset name must be at most ".concat(MAX_DATASET_NAME_LENGTH, " characters");
  }
  if (!/^[a-z0-9]/.test(name)) {
    return "Dataset name must start with a letter or a number";
  }
  if (!/^[a-z0-9][-_a-z0-9]+$/.test(name)) {
    return "Dataset name must only contain letters, numbers, dashes and underscores";
  }
  if (/[-_]$/.test(name)) {
    return "Dataset name must not end with a dash or an underscore";
  }
  return false;
}
function promptForDatasetName(prompt) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return prompt.single({
    type: "input",
    message: "Dataset name:",
    validate: name => {
      const err = validateDatasetName(name);
      if (err) {
        return err;
      }
      return true;
    },
    ...options
  });
}
const helpText$l = "\nOptions\n  --visibility <mode> Set visibility for this dataset (public/private)\n\nExamples\n  sanity dataset create\n  sanity dataset create <name>\n  sanity dataset create <name> --visibility private\n";
const allowedModes = ["private", "public", "custom"];
const createDatasetCommand = {
  name: "create",
  group: "dataset",
  signature: "[NAME]",
  helpText: helpText$l,
  description: "Create a new dataset within your project",
  action: async (args, context) => {
    const {
      apiClient,
      output,
      prompt
    } = context;
    const flags = args.extOptions;
    const [dataset] = args.argsWithoutOptions;
    const client = apiClient();
    const nameError = dataset && validateDatasetName(dataset);
    if (nameError) {
      throw new Error(nameError);
    }
    const [datasets, projectFeatures] = await Promise.all([client.datasets.list().then(sets => sets.map(ds => ds.name)), client.request({
      uri: "/features"
    })]);
    if (flags.visibility && !allowedModes.includes(flags.visibility)) {
      throw new Error('Visibility mode "'.concat(flags.visibility, '" not allowed'));
    }
    const datasetName = await (dataset || promptForDatasetName(prompt));
    if (datasets.includes(datasetName)) {
      throw new Error('Dataset "'.concat(datasetName, '" already exists'));
    }
    const canCreatePrivate = projectFeatures.includes("privateDataset");
    debug("%s create private datasets", canCreatePrivate ? "Can" : "Cannot");
    const defaultAclMode = canCreatePrivate ? flags.visibility : "public";
    const aclMode = await (defaultAclMode || promptForDatasetVisibility(prompt, output));
    try {
      await client.datasets.create(datasetName, {
        aclMode
      });
      output.print("Dataset created successfully");
    } catch (err) {
      throw new Error("Dataset creation failed:\n".concat(err.message));
    }
  }
};
async function promptForDatasetVisibility(prompt, output) {
  const mode = await prompt.single({
    type: "list",
    message: "Dataset visibility",
    choices: [{
      value: "public",
      name: "Public (world readable)"
    }, {
      value: "private",
      name: "Private (Authenticated user or token needed)"
    }]
  });
  if (mode === "private") {
    output.print("Please note that while documents are private, assets (files and images) are still public\n");
  }
  return mode;
}
const datasetVisibilityCommand = {
  name: "visibility",
  group: "dataset",
  helpText: "",
  signature: "get/set [dataset] [mode]",
  description: "Set visibility of a dataset",
  action: async (args, context) => {
    const {
      apiClient,
      output
    } = context;
    const [action, ds, aclMode] = args.argsWithoutOptions;
    const client = apiClient();
    if (!client.datasets.edit) {
      throw new Error("@sanity/cli must be upgraded first:\n  npm install -g @sanity/cli");
    }
    if (!action) {
      throw new Error("Action must be provided (get/set)");
    }
    if (!["set", "get"].includes(action)) {
      throw new Error("Invalid action (only get/set allowed)");
    }
    if (!ds) {
      throw new Error("Dataset name must be provided");
    }
    if (action === "set" && !aclMode) {
      throw new Error("Please provide a visibility mode (public/private)");
    }
    const dataset = "".concat(ds);
    const dsError = validateDatasetName(dataset);
    if (dsError) {
      throw new Error(dsError);
    }
    const current = (await client.datasets.list()).find(curr => curr.name === dataset);
    if (!current) {
      throw new Error("Dataset not found");
    }
    if (action === "get") {
      output.print(current.aclMode);
      return;
    }
    if (current.aclMode === aclMode) {
      output.print('Dataset already in "'.concat(aclMode, '"-mode'));
      return;
    }
    if (aclMode === "private") {
      output.print("Please note that while documents are private, assets (files and images) are still public\n");
    }
    await client.datasets.edit(dataset, {
      aclMode
    });
    output.print("Dataset visibility changed");
  }
};
const helpText$k = "\nOptions\n  --force Do not prompt for delete confirmation - forcefully delete\n\nExamples\n  sanity dataset delete\n  sanity dataset delete my-dataset\n  sanity dataset delete my-dataset --force\n";
function parseCliFlags$4(args) {
  return yargs__default.default(helpers.hideBin(args.argv || process.argv).slice(2)).option("force", {
    type: "boolean"
  }).argv;
}
const deleteDatasetCommand = {
  name: "delete",
  group: "dataset",
  helpText: helpText$k,
  signature: "[datasetName]",
  description: "Delete a dataset within your project",
  action: async (args, context) => {
    const {
      apiClient,
      prompt,
      output
    } = context;
    const {
      force
    } = await parseCliFlags$4(args);
    const [ds] = args.argsWithoutOptions;
    if (!ds) {
      throw new Error("Dataset name must be provided");
    }
    const dataset = "".concat(ds);
    const dsError = validateDatasetName(dataset);
    if (dsError) {
      throw dsError;
    }
    if (force) {
      output.warn("'--force' used: skipping confirmation, deleting dataset \"".concat(dataset, '"'));
    } else {
      await prompt.single({
        type: "input",
        message: "Are you ABSOLUTELY sure you want to delete this dataset?\n  Type the name of the dataset to confirm delete:",
        filter: input => "".concat(input).trim(),
        validate: input => {
          return input === dataset || "Incorrect dataset name. Ctrl + C to cancel delete.";
        }
      });
    }
    await apiClient().datasets.delete(dataset);
    output.print("Dataset deleted successfully");
  }
};
async function chooseDatasetPrompt(context) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    apiClient,
    prompt
  } = context;
  const {
    message,
    allowCreation
  } = options;
  const client = apiClient();
  const datasets = await client.datasets.list();
  const hasProduction = datasets.find(dataset => dataset.name === "production");
  const datasetChoices = datasets.map(dataset => ({
    value: dataset.name
  }));
  const selected = await prompt.single({
    message: message || "Select dataset to use",
    type: "list",
    choices: allowCreation ? [{
      value: "new",
      name: "Create new dataset"
    }, new prompt.Separator(), ...datasetChoices] : datasetChoices
  });
  if (selected === "new") {
    debug("User wants to create a new dataset, prompting for name");
    const newDatasetName = await promptForDatasetName(prompt, {
      message: "Name your dataset:",
      default: hasProduction ? void 0 : "production"
    });
    await client.datasets.create(newDatasetName);
    return newDatasetName;
  }
  return selected;
}
const noop = () => null;
const helpText$j = "\nOptions\n  --raw                     Extract only documents, without rewriting asset references\n  --no-assets               Export only non-asset documents and remove references to image assets\n  --no-drafts               Export only published versions of documents\n  --no-compress             Skips compressing tarball entries (still generates a gzip file)\n  --types                   Defines which document types to export\n  --overwrite               Overwrite any file with the same name\n  --asset-concurrency <num> Concurrent number of asset downloads\n\nExamples\n  sanity dataset export moviedb localPath.tar.gz\n  sanity dataset export moviedb assetless.tar.gz --no-assets\n  sanity dataset export staging staging.tar.gz --raw\n  sanity dataset export staging staging.tar.gz --types products,shops\n";
function parseFlags$1(rawFlags) {
  const flags = {};
  if (rawFlags.types) {
    flags.types = "".concat(rawFlags.types).split(",");
  }
  if (rawFlags["asset-concurrency"]) {
    flags.assetConcurrency = parseInt(rawFlags["asset-concurrency"], 10);
  }
  if (typeof rawFlags.raw !== "undefined") {
    flags.raw = Boolean(rawFlags.raw);
  }
  if (typeof rawFlags.assets !== "undefined") {
    flags.assets = Boolean(rawFlags.assets);
  }
  if (typeof rawFlags.drafts !== "undefined") {
    flags.drafts = Boolean(rawFlags.drafts);
  }
  if (typeof rawFlags.compress !== "undefined") {
    flags.compress = Boolean(rawFlags.compress);
  }
  if (typeof rawFlags.overwrite !== "undefined") {
    flags.overwrite = Boolean(rawFlags.overwrite);
  }
  return flags;
}
const exportDatasetCommand = {
  name: "export",
  group: "dataset",
  signature: "[NAME] [DESTINATION]",
  description: "Export dataset to local filesystem as a gzipped tarball",
  helpText: helpText$j,
  action: async (args, context) => {
    const {
      apiClient,
      output,
      chalk,
      workDir,
      prompt
    } = context;
    const client = apiClient();
    const [targetDataset, targetDestination] = args.argsWithoutOptions;
    const flags = parseFlags$1(args.extOptions);
    let dataset = targetDataset ? "".concat(targetDataset) : null;
    if (!dataset) {
      dataset = await chooseDatasetPrompt(context, {
        message: "Select dataset to export"
      });
    }
    const dsError = validateDatasetName(dataset);
    if (dsError) {
      throw dsError;
    }
    const datasets = await client.datasets.list();
    if (!datasets.find(set => set.name === dataset)) {
      throw new Error('Dataset with name "'.concat(dataset, '" not found'));
    }
    let destinationPath = targetDestination;
    if (!destinationPath) {
      destinationPath = await prompt.single({
        type: "input",
        message: "Output path:",
        default: path__default.default.join(workDir, "".concat(dataset, ".tar.gz")),
        filter: fs.absolutify
      });
    }
    const outputPath = await getOutputPath(destinationPath, dataset, prompt, flags);
    if (!outputPath) {
      output.print("Cancelled");
      return;
    }
    if (outputPath !== "-") {
      output.print('Exporting dataset "'.concat(chalk.cyan(dataset), '" to "').concat(chalk.cyan(outputPath), '"'));
    }
    let currentStep = "Exporting documents...";
    let spinner = output.spinner(currentStep).start();
    const onProgress = progress => {
      if (progress.step !== currentStep) {
        spinner.succeed();
        spinner = output.spinner(progress.step).start();
      } else if (progress.step === currentStep && progress.update) {
        spinner.text = "".concat(progress.step, " (").concat(progress.current, "/").concat(progress.total, ")");
      }
      currentStep = progress.step;
    };
    const start = Date.now();
    try {
      await exportDataset__default.default({
        client,
        dataset,
        outputPath,
        onProgress,
        ...flags
      });
      spinner.succeed();
    } catch (err) {
      spinner.fail();
      throw err;
    }
    output.print("Export finished (".concat(prettyMs__default.default(Date.now() - start), ")"));
  }
};
async function getOutputPath(destination, dataset, prompt, flags) {
  if (destination === "-") {
    return "-";
  }
  const dstPath = path__default.default.isAbsolute(destination) ? destination : path__default.default.resolve(process.cwd(), destination);
  let dstStats = await fs__default.default.stat(dstPath).catch(noop);
  const looksLikeFile = dstStats ? dstStats.isFile() : path__default.default.basename(dstPath).indexOf(".") !== -1;
  if (!dstStats) {
    const createPath = looksLikeFile ? path__default.default.dirname(dstPath) : dstPath;
    await fs__default.default.mkdir(createPath, {
      recursive: true
    });
  }
  const finalPath = looksLikeFile ? dstPath : path__default.default.join(dstPath, "".concat(dataset, ".tar.gz"));
  dstStats = await fs__default.default.stat(finalPath).catch(noop);
  if (!flags.overwrite && dstStats && dstStats.isFile()) {
    const shouldOverwrite = await prompt.single({
      type: "confirm",
      message: 'File "'.concat(finalPath, '" already exists, would you like to overwrite it?'),
      default: false
    });
    if (!shouldOverwrite) {
      return false;
    }
  }
  return finalPath;
}
const yellow = str => "\x1B[33m".concat(str, "\x1B[39m");
const helpText$i = '\nOptions\n  --missing On duplicate document IDs, skip importing document in question\n  --replace On duplicate document IDs, replace existing document with imported document\n  --allow-failing-assets Skip assets that cannot be fetched/uploaded\n  --replace-assets Skip reuse of existing assets\n  --skip-cross-dataset-references Skips references to other datasets\n\nRarely used options (should generally not be used)\n  --allow-assets-in-different-dataset Allow asset documents to reference different project/dataset\n\nExamples\n  # Import "moviedb.ndjson" from the current directory to the dataset called "moviedb"\n  sanity dataset import moviedb.ndjson moviedb\n\n  # Import "moviedb.tar.gz" from the current directory to the dataset called "moviedb",\n  # replacing any documents encountered that have the same document IDs\n  sanity dataset import moviedb.tar.gz moviedb --replace\n\n  # Import from a folder containing an ndjson file, such as an extracted tarball\n  # retrieved through "sanity dataset export".\n  sanity dataset import ~/some/folder moviedb\n\n  # Import from a remote URL. Will download and extract the tarball to a temporary\n  # location before importing it.\n  sanity dataset import https://some.url/moviedb.tar.gz moviedb --replace\n';
function toBoolIfSet(flag) {
  return typeof flag === "undefined" ? void 0 : Boolean(flag);
}
function parseFlags(rawFlags) {
  const allowAssetsInDifferentDataset = toBoolIfSet(rawFlags["allow-assets-in-different-dataset"]);
  const allowFailingAssets = toBoolIfSet(rawFlags["allow-failing-assets"]);
  const assetConcurrency = toBoolIfSet(rawFlags["asset-concurrency"]);
  const replaceAssets = toBoolIfSet(rawFlags["replace-assets"]);
  const skipCrossDatasetReferences = toBoolIfSet(rawFlags["skip-cross-dataset-references"]);
  const replace = toBoolIfSet(rawFlags.replace);
  const missing = toBoolIfSet(rawFlags.missing);
  return {
    allowAssetsInDifferentDataset,
    allowFailingAssets,
    assetConcurrency,
    skipCrossDatasetReferences,
    replaceAssets,
    replace,
    missing
  };
}
const importDatasetCommand = {
  name: "import",
  group: "dataset",
  signature: "[FILE | FOLDER | URL] [TARGET_DATASET]",
  description: "Import documents to given dataset from ndjson file",
  helpText: helpText$i,
  // eslint-disable-next-line max-statements
  action: async (args, context) => {
    const {
      apiClient,
      output,
      chalk,
      fromInitCommand
    } = context;
    const flags = parseFlags(args.extOptions);
    const {
      allowAssetsInDifferentDataset,
      allowFailingAssets,
      assetConcurrency,
      replaceAssets
    } = flags;
    const operation = getMutationOperation(args.extOptions);
    const client = apiClient();
    const [file, target] = args.argsWithoutOptions;
    if (!file) {
      throw new Error('Source file name and target dataset must be specified ("sanity dataset import '.concat(chalk.bold("[file]"), ' [dataset]")'));
    }
    const targetDataset = await determineTargetDataset(target, context);
    debug('Target dataset has been set to "'.concat(targetDataset, '"'));
    const isUrl = /^https?:\/\//i.test(file);
    let inputStream;
    let assetsBase;
    let sourceIsFolder = false;
    if (isUrl) {
      debug("Input is a URL, streaming from source URL");
      inputStream = await getUrlStream(file);
    } else {
      const sourceFile = path__default.default.resolve(process.cwd(), file);
      const fileStats = await fs__default.default.stat(sourceFile).catch(() => null);
      if (!fileStats) {
        throw new Error("".concat(sourceFile, " does not exist or is not readable"));
      }
      sourceIsFolder = fileStats.isDirectory();
      if (sourceIsFolder) {
        inputStream = sourceFile;
      } else {
        assetsBase = path__default.default.dirname(sourceFile);
        inputStream = await fs$2.createReadStream(sourceFile);
      }
    }
    const importClient = client.clone().config({
      dataset: targetDataset
    });
    let currentStep;
    let currentProgress;
    let stepStart;
    let spinInterval = null;
    let percent;
    function onProgress(opts) {
      const lengthComputable = opts.total;
      const sameStep = opts.step == currentStep;
      percent = getPercentage(opts);
      if (lengthComputable && opts.total === opts.current) {
        if (spinInterval) {
          clearInterval(spinInterval);
        }
        spinInterval = null;
      }
      if (sameStep) {
        return;
      }
      const prevStep = currentStep;
      const prevStepStart = stepStart || Date.now();
      stepStart = Date.now();
      currentStep = opts.step;
      if (currentProgress && currentProgress.succeed) {
        const timeSpent = prettyMs__default.default(Date.now() - prevStepStart, {
          secondsDecimalDigits: 2
        });
        currentProgress.text = "[100%] ".concat(prevStep, " (").concat(timeSpent, ")");
        currentProgress.succeed();
      }
      currentProgress = output.spinner("[0%] ".concat(opts.step, " (0.00s)")).start();
      if (spinInterval) {
        clearInterval(spinInterval);
        spinInterval = null;
      }
      spinInterval = setInterval(() => {
        const timeSpent = prettyMs__default.default(Date.now() - prevStepStart, {
          secondsDecimalDigits: 2
        });
        if (currentProgress) {
          currentProgress.text = "".concat(percent).concat(opts.step, " (").concat(timeSpent, ")");
        }
      }, 60);
    }
    function endTask(_ref) {
      let {
        success
      } = _ref;
      if (spinInterval) {
        clearInterval(spinInterval);
      }
      spinInterval = null;
      if (success && stepStart && currentProgress) {
        const timeSpent = prettyMs__default.default(Date.now() - stepStart, {
          secondsDecimalDigits: 2
        });
        currentProgress.text = "[100%] ".concat(currentStep, " (").concat(timeSpent, ")");
        currentProgress.succeed();
      } else if (currentProgress) {
        currentProgress.fail();
      }
    }
    try {
      const {
        numDocs,
        warnings
      } = await sanityImport__default.default(inputStream, {
        client: importClient,
        assetsBase,
        operation,
        onProgress,
        allowFailingAssets,
        allowAssetsInDifferentDataset,
        assetConcurrency,
        replaceAssets
      });
      endTask({
        success: true
      });
      output.print('Done! Imported %d documents to dataset "%s"\n', numDocs, targetDataset);
      printWarnings(warnings, output);
    } catch (err) {
      endTask({
        success: false
      });
      const isNonRefConflict = !fromInitCommand && err.response && err.response.statusCode === 409 && err.step !== "strengthen-references";
      if (!isNonRefConflict) {
        throw err;
      }
      const message = [err.message, "", "You probably want either:", " --replace (replace existing documents with same IDs)", " --missing (only import documents that do not already exist)", ""].join("\n");
      const error = new Error(message);
      error.details = err.details;
      error.response = err.response;
      error.responseBody = err.responseBody;
      throw error;
    }
  }
};
async function determineTargetDataset(target, context) {
  const {
    apiClient,
    output,
    prompt
  } = context;
  const client = apiClient();
  if (target) {
    const dsError = validateDatasetName(target);
    if (dsError) {
      throw new Error(dsError);
    }
  }
  debug("Fetching available datasets");
  const spinner = output.spinner("Fetching available datasets").start();
  const datasets = await client.datasets.list();
  spinner.succeed("[100%] Fetching available datasets");
  let targetDataset = target ? "".concat(target) : null;
  if (!targetDataset) {
    targetDataset = await chooseDatasetPrompt(context, {
      message: "Select target dataset",
      allowCreation: true
    });
  } else if (!datasets.find(dataset => dataset.name === targetDataset)) {
    debug("Target dataset does not exist, prompting for creation");
    const shouldCreate = await prompt.single({
      type: "confirm",
      message: 'Dataset "'.concat(targetDataset, '" does not exist, would you like to create it?'),
      default: true
    });
    if (!shouldCreate) {
      throw new Error('Dataset "'.concat(targetDataset, '" does not exist'));
    }
    await client.datasets.create(targetDataset);
  }
  return targetDataset;
}
function getMutationOperation(flags) {
  const {
    replace,
    missing
  } = flags;
  if (replace && missing) {
    throw new Error("Cannot use both --replace and --missing");
  }
  if (flags.replace) {
    return "createOrReplace";
  }
  if (flags.missing) {
    return "createIfNotExists";
  }
  return "create";
}
function getPercentage(opts) {
  if (!opts.total || typeof opts.current === "undefined") {
    return "";
  }
  const percent = Math.floor(opts.current / opts.total * 100);
  return "[".concat(padStart__default.default("".concat(percent), 3, " "), "%] ");
}
function getUrlStream(url) {
  const request = getIt.getIt([middleware.promise({
    onlyBody: true
  })]);
  return request({
    url,
    stream: true
  });
}
function printWarnings(warnings, output) {
  const assetFails = warnings.filter(warn2 => warn2.type === "asset");
  if (!assetFails.length) {
    return;
  }
  const warn = (output.warn || output.print).bind(output);
  warn(yellow("\u26A0 Failed to import the following %s:"), assetFails.length > 1 ? "assets" : "asset");
  warnings.forEach(warning => {
    warn("  ".concat(warning.url));
  });
}
async function listDatasetCopyJobs(flags, context) {
  const {
    apiClient,
    output,
    chalk
  } = context;
  const client = apiClient();
  const projectId = client.config().projectId;
  const query = {};
  let response;
  if (flags.offset && flags.offset >= 0) {
    query.offset = "".concat(flags.offset);
  }
  if (flags.limit && flags.limit > 0) {
    query.limit = "".concat(flags.limit);
  }
  try {
    response = await client.request({
      method: "GET",
      uri: "/projects/".concat(projectId, "/datasets/copy"),
      query
    });
  } catch (error) {
    if (error.statusCode) {
      output.error("".concat(chalk.red("Dataset copy list failed:\n".concat(error.response.body.message)), "\n"));
    } else {
      output.error("".concat(chalk.red("Dataset copy list failed:\n".concat(error.message)), "\n"));
    }
  }
  if (response && response.length > 0) {
    const table = new consoleTablePrinter.Table({
      title: "Dataset copy jobs for this project in descending order",
      columns: [{
        name: "id",
        title: "Job ID",
        alignment: "left"
      }, {
        name: "sourceDataset",
        title: "Source Dataset",
        alignment: "left"
      }, {
        name: "targetDataset",
        title: "Target Dataset",
        alignment: "left"
      }, {
        name: "state",
        title: "State",
        alignment: "left"
      }, {
        name: "withHistory",
        title: "With history",
        alignment: "left"
      }, {
        name: "timeStarted",
        title: "Time started",
        alignment: "left"
      }, {
        name: "timeTaken",
        title: "Time taken",
        alignment: "left"
      }]
    });
    response.forEach(job => {
      const {
        id,
        state,
        createdAt,
        updatedAt,
        sourceDataset,
        targetDataset,
        withHistory
      } = job;
      let timeStarted = "";
      if (createdAt !== "") {
        timeStarted = dateFns.formatDistanceToNow(dateFns.parseISO(createdAt));
      }
      let timeTaken = "";
      if (updatedAt !== "") {
        timeTaken = dateFns.formatDistance(dateFns.parseISO(updatedAt), dateFns.parseISO(createdAt));
      }
      let color;
      switch (state) {
        case "completed":
          color = "green";
          break;
        case "failed":
          color = "red";
          break;
        case "pending":
          color = "yellow";
          break;
        default:
          color = "";
      }
      table.addRow({
        id,
        state,
        withHistory,
        timeStarted: "".concat(timeStarted, " ago"),
        timeTaken,
        sourceDataset,
        targetDataset
      }, {
        color
      });
    });
    table.printTable();
  } else {
    output.print("This project doesn't have any dataset copy jobs");
  }
}
const getClientUrl = function (client, uri) {
  let useCdn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const config = client.config();
  const base = useCdn ? config.cdnUrl : config.url;
  return "".concat(base, "/").concat(uri.replace(/^\//, ""));
};
const helpText$h = "\nOptions\n  --detach Start the copy without waiting for it to finish\n  --attach <job-id> Attach to the running copy process to show progress\n  --skip-history Don't preserve document history on copy\n  --list Lists all dataset copy jobs corresponding to a certain criteria.\n  --offset Start position in the list of jobs. Default 0. With --list.\n  --limit Maximum number of jobs returned. Default 10. Maximum 1000. With --list.\n\nExamples\n  sanity dataset copy\n  sanity dataset copy <source-dataset>\n  sanity dataset copy <source-dataset> <target-dataset>\n  sanity dataset copy --skip-history <source-dataset> <target-dataset>\n  sanity dataset copy --detach <source-dataset> <target-dataset>\n  sanity dataset copy --attach <job-id>\n  sanity dataset copy --list\n  sanity dataset copy --list --offset=2\n  sanity dataset copy --list --offset=2 --limit=10\n";
function parseCliFlags$3(args) {
  return yargs__default.default(helpers.hideBin(args.argv || process.argv).slice(2)).option("attach", {
    type: "string"
  }).option("list", {
    type: "boolean"
  }).option("limit", {
    type: "number"
  }).option("offset", {
    type: "number"
  }).option("skip-history", {
    type: "boolean"
  }).option("detach", {
    type: "boolean"
  }).argv;
}
const progress = url => {
  return new rxjs.Observable(observer => {
    let progressSource = new EventSource__default.default(url);
    let stopped = false;
    function onError(error) {
      if (progressSource) {
        progressSource.close();
      }
      debug("Error received: ".concat(error));
      if (stopped) {
        return;
      }
      observer.next({
        type: "reconnect"
      });
      progressSource = new EventSource__default.default(url);
    }
    function onChannelError(error) {
      stopped = true;
      progressSource.close();
      observer.error(error);
    }
    function onMessage(event) {
      const data = JSON.parse(event.data);
      if (data.state === "failed") {
        debug("Job failed. Data: %o", event);
        observer.error(event);
      } else if (data.state === "completed") {
        debug("Job succeeded. Data: %o", event);
        onComplete();
      } else {
        debug("Job progressed. Data: %o", event);
        observer.next(data);
      }
    }
    function onComplete() {
      progressSource.removeEventListener("error", onError);
      progressSource.removeEventListener("channel_error", onChannelError);
      progressSource.removeEventListener("job", onMessage);
      progressSource.removeEventListener("done", onComplete);
      progressSource.close();
      observer.complete();
    }
    progressSource.addEventListener("error", onError);
    progressSource.addEventListener("channel_error", onChannelError);
    progressSource.addEventListener("job", onMessage);
    progressSource.addEventListener("done", onComplete);
  });
};
const followProgress = (jobId, client, output) => {
  let currentProgress = 0;
  const spinner = output.spinner({}).start();
  const listenUrl = getClientUrl(client, "jobs/".concat(jobId, "/listen"));
  debug("Listening to ".concat(listenUrl));
  return new Promise((resolve, reject) => {
    progress(listenUrl).subscribe({
      next: event => {
        if (typeof event.progress === "number") {
          currentProgress = event.progress;
        }
        spinner.text = "Copy in progress: ".concat(currentProgress, "%");
      },
      error: err => {
        spinner.fail();
        reject(new Error("".concat(err.data)));
      },
      complete: () => {
        spinner.succeed("Copy finished.");
        resolve();
      }
    });
  });
};
const copyDatasetCommand = {
  name: "copy",
  group: "dataset",
  signature: "[SOURCE_DATASET] [TARGET_DATASET]",
  helpText: helpText$h,
  description: "Manages dataset copying, including starting a new copy job, listing copy jobs and following the progress of a running copy job",
  action: async (args, context) => {
    const {
      apiClient,
      output,
      prompt,
      chalk
    } = context;
    const flags = await parseCliFlags$3(args);
    const client = apiClient();
    if (flags.list) {
      await listDatasetCopyJobs(flags, context);
      return;
    }
    if (flags.attach) {
      const jobId = flags.attach;
      if (!jobId) {
        throw new Error("Please supply a jobId");
      }
      await followProgress(jobId, client, output);
      return;
    }
    const [sourceDataset, targetDataset] = args.argsWithoutOptions;
    const shouldSkipHistory = Boolean(flags["skip-history"]);
    const nameError = sourceDataset && validateDatasetName(sourceDataset);
    if (nameError) {
      throw new Error(nameError);
    }
    const existingDatasets = await client.datasets.list().then(datasets => datasets.map(ds => ds.name));
    const sourceDatasetName = await (sourceDataset || promptForDatasetName(prompt, {
      message: "Source dataset name:"
    }));
    if (!existingDatasets.includes(sourceDatasetName)) {
      throw new Error('Source dataset "'.concat(sourceDatasetName, "\" doesn't exist"));
    }
    const targetDatasetName = await (targetDataset || promptForDatasetName(prompt, {
      message: "Target dataset name:"
    }));
    if (existingDatasets.includes(targetDatasetName)) {
      throw new Error('Target dataset "'.concat(targetDatasetName, '" already exists'));
    }
    const err = validateDatasetName(targetDatasetName);
    if (err) {
      throw new Error(err);
    }
    try {
      const response = await client.request({
        method: "PUT",
        uri: "/datasets/".concat(sourceDatasetName, "/copy"),
        body: {
          targetDataset: targetDatasetName,
          skipHistory: shouldSkipHistory
        }
      });
      output.print("Copying dataset ".concat(chalk.green(sourceDatasetName), " to ").concat(chalk.green(targetDatasetName), "..."));
      if (!shouldSkipHistory) {
        output.print("Note: You can run this command with flag '--skip-history'. The flag will reduce copy time in larger datasets.");
      }
      output.print("Job ".concat(chalk.green(response.jobId), " started"));
      if (flags.detach) {
        return;
      }
      await followProgress(response.jobId, client, output);
      output.print("Job ".concat(chalk.green(response.jobId), " completed"));
    } catch (error) {
      if (error.statusCode) {
        output.print("".concat(chalk.red("Dataset copying failed:\n".concat(error.response.body.message)), "\n"));
      } else {
        output.print("".concat(chalk.red("Dataset copying failed:\n".concat(error.message)), "\n"));
      }
    }
  }
};
function promptForDatasetAliasName(prompt) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return prompt.single({
    type: "input",
    message: "Alias name:",
    validate: name => {
      const err = validateDatasetAliasName(name);
      if (err) {
        return err;
      }
      return true;
    },
    ...options
  });
}
const createAliasHandler = async (args, context) => {
  const {
    apiClient,
    output,
    prompt
  } = context;
  const [, alias, targetDataset] = args.argsWithoutOptions;
  const client = apiClient();
  const nameError = alias && validateDatasetAliasName(alias);
  if (nameError) {
    throw new Error(nameError);
  }
  const [datasets, aliases, projectFeatures] = await Promise.all([client.datasets.list().then(sets => sets.map(ds => ds.name)), listAliases(client).then(sets => sets.map(ds => ds.name)), client.request({
    uri: "/features"
  })]);
  let aliasName = await (alias || promptForDatasetAliasName(prompt));
  let aliasOutputName = aliasName;
  if (aliasName.startsWith(ALIAS_PREFIX)) {
    aliasName = aliasName.substring(1);
  } else {
    aliasOutputName = "".concat(ALIAS_PREFIX).concat(aliasName);
  }
  if (aliases.includes(aliasName)) {
    throw new Error('Dataset alias "'.concat(aliasOutputName, '" already exists'));
  }
  if (targetDataset) {
    const datasetErr = validateDatasetName(targetDataset);
    if (datasetErr) {
      throw new Error(datasetErr);
    }
  }
  const datasetName = await (targetDataset || promptForDatasetName(prompt));
  if (datasetName && !datasets.includes(datasetName)) {
    throw new Error('Dataset "'.concat(datasetName, '" does not exist '));
  }
  const canCreateAlias = projectFeatures.includes("advancedDatasetManagement");
  if (!canCreateAlias) {
    throw new Error("This project cannot create a dataset alias");
  }
  try {
    await createAlias(client, aliasName, datasetName);
    output.print("Dataset alias ".concat(aliasOutputName, " created ").concat(datasetName && "and linked to ".concat(datasetName), " successfully"));
  } catch (err) {
    throw new Error("Dataset alias creation failed:\n".concat(err.message));
  }
};
function parseCliFlags$2(args) {
  return yargs__default.default(helpers.hideBin(args.argv || process.argv).slice(2)).option("force", {
    type: "boolean"
  }).argv;
}
const deleteAliasHandler = async (args, context) => {
  const {
    apiClient,
    prompt,
    output
  } = context;
  const [, ds] = args.argsWithoutOptions;
  const {
    force
  } = await parseCliFlags$2(args);
  const client = apiClient();
  if (!ds) {
    throw new Error("Dataset alias name must be provided");
  }
  let aliasName = "".concat(ds);
  const dsError = validateDatasetAliasName(aliasName);
  if (dsError) {
    throw dsError;
  }
  aliasName = aliasName.startsWith(ALIAS_PREFIX) ? aliasName.substring(1) : aliasName;
  const [fetchedAliases] = await Promise.all([listAliases(client)]);
  const linkedAlias = fetchedAliases.find(elem => elem.name === aliasName);
  const message = linkedAlias && linkedAlias.datasetName ? "This dataset alias is linked to ".concat(linkedAlias.datasetName, ". ") : "";
  if (force) {
    output.warn("'--force' used: skipping confirmation, deleting alias \"".concat(aliasName, '"'));
  } else {
    await prompt.single({
      type: "input",
      message: "".concat(message, "Are you ABSOLUTELY sure you want to delete this dataset alias?\n  Type the name of the dataset alias to confirm delete: "),
      filter: input => "".concat(input).trim(),
      validate: input => {
        return input === aliasName || "Incorrect dataset alias name. Ctrl + C to cancel delete.";
      }
    });
  }
  return removeAlias(client, aliasName).then(() => {
    output.print("Dataset alias deleted successfully");
  });
};
function parseCliFlags$1(args) {
  return yargs__default.default(helpers.hideBin(args.argv || process.argv).slice(2)).option("force", {
    type: "boolean"
  }).argv;
}
const unlinkAliasHandler = async (args, context) => {
  const {
    apiClient,
    output,
    prompt
  } = context;
  const [, alias] = args.argsWithoutOptions;
  const {
    force
  } = await parseCliFlags$1(args);
  const client = apiClient();
  const nameError = alias && validateDatasetAliasName(alias);
  if (nameError) {
    throw new Error(nameError);
  }
  const fetchedAliases = await listAliases(client);
  let aliasName = await (alias || promptForDatasetAliasName(prompt));
  let aliasOutputName = aliasName;
  if (aliasName.startsWith(ALIAS_PREFIX)) {
    aliasName = aliasName.substring(1);
  } else {
    aliasOutputName = "".concat(ALIAS_PREFIX).concat(aliasName);
  }
  const linkedAlias = fetchedAliases.find(elem => elem.name === aliasName);
  if (!linkedAlias) {
    throw new Error('Dataset alias "'.concat(aliasOutputName, '" does not exist'));
  }
  if (!linkedAlias.datasetName) {
    throw new Error('Dataset alias "'.concat(aliasOutputName, '" is not linked to a dataset'));
  }
  if (force) {
    output.warn("'--force' used: skipping confirmation, unlinking alias \"".concat(aliasOutputName, '"'));
  } else {
    await prompt.single({
      type: "input",
      message: 'Are you ABSOLUTELY sure you want to unlink this alias from the "'.concat(linkedAlias.datasetName, '" dataset?\n        \n  Type YES/NO: '),
      filter: input => "".concat(input).toLowerCase(),
      validate: input => {
        return input === "yes" || "Ctrl + C to cancel dataset alias unlink.";
      }
    });
  }
  try {
    const result = await unlinkAlias(client, aliasName);
    output.print("Dataset alias ".concat(aliasOutputName, " unlinked from ").concat(result.datasetName, " successfully"));
  } catch (err) {
    throw new Error("Dataset alias unlink failed:\n".concat(err.message));
  }
};
const linkAliasHandler = async (args, context) => {
  const {
    apiClient,
    output,
    prompt
  } = context;
  const [, alias, targetDataset] = args.argsWithoutOptions;
  const flags = args.extOptions;
  const client = apiClient();
  const nameError = alias && validateDatasetAliasName(alias);
  if (nameError) {
    throw new Error(nameError);
  }
  const [datasets, fetchedAliases] = await Promise.all([client.datasets.list().then(sets => sets.map(ds => ds.name)), listAliases(client)]);
  const aliases = fetchedAliases.map(da => da.name);
  let aliasName = await (alias || promptForDatasetAliasName(prompt));
  let aliasOutputName = aliasName;
  if (aliasName.startsWith(ALIAS_PREFIX)) {
    aliasName = aliasName.substring(1);
  } else {
    aliasOutputName = "".concat(ALIAS_PREFIX).concat(aliasName);
  }
  if (!aliases.includes(aliasName)) {
    throw new Error('Dataset alias "'.concat(aliasOutputName, '" does not exist '));
  }
  const datasetName = await (targetDataset || promptForDatasetName(prompt));
  const datasetErr = validateDatasetName(datasetName);
  if (datasetErr) {
    throw new Error(datasetErr);
  }
  if (!datasets.includes(datasetName)) {
    throw new Error('Dataset "'.concat(datasetName, '" does not exist '));
  }
  const linkedAlias = fetchedAliases.find(elem => elem.name === aliasName);
  if (linkedAlias && linkedAlias.datasetName) {
    if (linkedAlias.datasetName === datasetName) {
      throw new Error("Dataset alias ".concat(aliasOutputName, " already linked to ").concat(datasetName));
    }
    if (!flags.force) {
      await prompt.single({
        type: "input",
        message: "This alias is linked to dataset <".concat(linkedAlias.datasetName, ">. Are you ABSOLUTELY sure you want to link this dataset alias to this dataset?\n        \n  Type YES/NO: "),
        filter: input => "".concat(input).toLowerCase(),
        validate: input => {
          return input === "yes" || "Ctrl + C to cancel dataset alias link.";
        }
      });
    }
  }
  try {
    await updateAlias(client, aliasName, datasetName);
    output.print("Dataset alias ".concat(aliasOutputName, " linked to ").concat(datasetName, " successfully"));
  } catch (err) {
    throw new Error("Dataset alias link failed:\n".concat(err.message));
  }
};
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1;
const helpText$g = "\nBelow are examples of the alias subcommand\n\nCreate Alias\n  sanity dataset alias create\n  sanity dataset alias create <alias-name>\n  sanity dataset alias create <alias-name> <target-dataset>\n\nDelete Alias\n  Options\n    --force Skips security prompt and forces link command\n\n  Usage\n    sanity dataset alias delete <alias-name>\n    sanity dataset alias delete <alias-name> --force\n\nLink Alias\n  Options\n    --force Skips security prompt and forces link command\n\n  Usage\n    sanity dataset alias link\n    sanity dataset alias link <alias-name>\n    sanity dataset alias link <alias-name> <target-dataset>\n    sanity dataset alias link <alias-name> <target-dataset> --force\n\nUn-link Alias\n  Options\n    --force Skips security prompt and forces link command\n\n  Usage\n    sanity dataset alias unlink\n    sanity dataset alias unlink <alias-name>\n    sanity dataset alias unlink <alias-name> --force\n";
const aliasCommand = {
  name: "alias",
  group: "dataset",
  signature: "SUBCOMMAND [ALIAS_NAME, TARGET_DATASET]",
  helpText: helpText$g,
  description: "You can manage your dataset alias using this command.",
  action: async (args, context) => {
    const [verb] = args.argsWithoutOptions;
    switch (verb) {
      case "create":
        await createAliasHandler(args, context);
        break;
      case "delete":
        await deleteAliasHandler(args, context);
        break;
      case "unlink":
        await unlinkAliasHandler(args, context);
        break;
      case "link":
        await linkAliasHandler(args, context);
        break;
      default:
        throw new Error(oneline__default.default(_a$1 || (_a$1 = __template$1(["\n          Invalid command provided. Available commands are: create, delete, link and unlink.\n          For more guide run the help command 'sanity dataset alias --help'\n        "]))));
    }
  }
};
const documentsGroup = {
  name: "documents",
  signature: "[COMMAND]",
  isGroupRoot: true,
  description: "Interact with documents in your project"
};
const identity = inp => inp;
function colorizeJson(input, chalk) {
  const formatters = {
    punctuator: chalk.white,
    key: chalk.white,
    string: chalk.green,
    number: chalk.yellow,
    literal: chalk.bold,
    whitespace: identity
  };
  const json = JSON.stringify(input, null, 2);
  return tokenize__default.default(json).map((token, i, arr) => {
    const prevToken = i === 0 ? token : arr[i - 1];
    if (token.type === "string" && prevToken.type === "whitespace" && /^\n\s+$/.test(prevToken.value)) {
      return {
        ...token,
        type: "key"
      };
    }
    return token;
  }).map(token => {
    const formatter = formatters[token.type] || identity;
    return formatter(token.raw);
  }).join("");
}
const helpText$f = "\nGet and print a document from the projects configured dataset\n\nOptions\n  --pretty colorized JSON output\n  --dataset NAME to override dataset\n\nExamples\n  # Get the document with the ID \"myDocId\"\n  sanity documents get myDocId\n\n  # ID wrapped in double or single quote works equally well\n  sanity documents get 'myDocId'\n";
const getDocumentsCommand = {
  name: "get",
  group: "documents",
  signature: "[DOCUMENT_ID]",
  helpText: helpText$f,
  description: "Get and print a document by ID",
  action: async (args, context) => {
    const {
      apiClient,
      output,
      chalk
    } = context;
    const {
      pretty,
      dataset
    } = args.extOptions;
    const [docId] = args.argsWithoutOptions.map(str => "".concat(str));
    if (!docId) {
      throw new Error("Document ID must be specified");
    }
    const client = dataset ? apiClient().clone().config({
      dataset
    }) : apiClient();
    try {
      const doc = await client.getDocument(docId);
      if (!doc) {
        throw new Error("Document not found");
      }
      output.print(pretty ? colorizeJson(doc, chalk) : JSON.stringify(doc, null, 2));
    } catch (err) {
      throw new Error("Failed to fetch document:\n".concat(err.message));
    }
  }
};
const defaultApiVersion = "v2022-06-01";
const helpText$e = "\nRun a query against the projects configured dataset\n\nOptions\n  --pretty colorized JSON output\n  --dataset NAME to override dataset\n  --project PROJECT to override project ID\n  --anonymous Send the query without any authorization token\n  --api-version API version to use (defaults to `".concat(defaultApiVersion, '`)\n\nEnvironment variables\n  `SANITY_CLI_QUERY_API_VERSION` - will use the defined API version,\n  unless `--api-version` is specified.\n\nExamples\n  # Fetch 5 documents of type "movie"\n  sanity documents query \'*[_type == "movie"][0..4]\'\n\n  # Fetch title of the oldest movie in the dataset named "staging"\n  sanity documents query \'*[_type == "movie"]|order(releaseDate asc)[0]{title}\' --dataset staging\n\n  # Use API version v2021-06-07 and do a query\n  sanity documents query --api-version v2021-06-07 \'*[_id == "header"] { "headerText": pt::text(body) }\'\n');
var queryDocumentsCommand = {
  name: "query",
  group: "documents",
  signature: "[QUERY]",
  helpText: helpText$e,
  description: "Query for documents",
  action: async (args, context) => {
    var _a, _b;
    const {
      pretty,
      dataset,
      project,
      anonymous,
      "api-version": apiVersion
    } = await parseCliFlags(args);
    const {
      apiClient,
      output,
      chalk,
      cliConfig
    } = context;
    const [query] = args.argsWithoutOptions;
    if (!query) {
      throw new Error("Query must be specified");
    }
    if (!apiVersion) {
      output.warn(chalk.yellow("--api-version not specified, using `".concat(defaultApiVersion, "`")));
    }
    const requireDataset = !dataset;
    const requireProject = !project;
    const requireUser = !anonymous;
    if (requireProject && !((_a = cliConfig == null ? void 0 : cliConfig.api) == null ? void 0 : _a.projectId)) {
      throw new Error("No project configured in CLI config - either configure one, or use `--project` flag");
    }
    if (requireDataset && !((_b = cliConfig == null ? void 0 : cliConfig.api) == null ? void 0 : _b.dataset)) {
      throw new Error("No dataset configured in CLI config - either configure one, or use `--dataset` flag");
    }
    const baseClient = apiClient({
      requireProject,
      requireUser
    }).clone();
    const {
      dataset: originalDataset,
      projectId: originalProjectId
    } = baseClient.config();
    const client = baseClient.config({
      projectId: project || originalProjectId,
      dataset: dataset || originalDataset,
      apiVersion: apiVersion || defaultApiVersion
    });
    try {
      const docs = await client.fetch(query);
      if (!docs) {
        throw new Error("Query returned no results");
      }
      output.print(pretty ? colorizeJson(docs, chalk) : JSON.stringify(docs, null, 2));
    } catch (err) {
      throw new Error("Failed to run query:\n".concat(err.message));
    }
  }
};
function parseCliFlags(args) {
  const fallbackApiVersion = process.env.SANITY_CLI_QUERY_API_VERSION;
  return yargs__default.default(helpers.hideBin(args.argv || process.argv).slice(2)).option("pretty", {
    type: "boolean",
    default: false
  }).option("dataset", {
    type: "string"
  }).option("project", {
    type: "string"
  }).option("anonymous", {
    type: "boolean",
    default: false
  }).option("api-version", {
    type: "string",
    default: fallbackApiVersion
  }).argv;
}
const helpText$d = '\nDelete a document from the projects configured dataset\n\nOptions\n  --dataset NAME to override dataset\n\nExample\n  # Delete the document with the ID "myDocId"\n  sanity documents delete myDocId\n\n  # ID wrapped in double or single quote works equally well\n  sanity documents delete \'myDocId\'\n\n  # Delete document with ID "someDocId" from dataset "blog"\n  sanity documents delete --dataset=blog someDocId\n\n  # Delete the document with ID "doc1" and "doc2"\n  sanity documents delete doc1 doc2\n';
const deleteDocumentsCommand = {
  name: "delete",
  group: "documents",
  signature: "[ID] [...IDS]",
  helpText: helpText$d,
  description: "Delete a document by ID",
  action: async (args, context) => {
    const {
      apiClient,
      output,
      chalk
    } = context;
    const {
      dataset
    } = args.extOptions;
    const ids = args.argsWithoutOptions.map(str => "".concat(str));
    if (!ids.length) {
      throw new Error("Document ID must be specified");
    }
    const client = dataset ? apiClient().clone().config({
      dataset
    }) : apiClient();
    const transaction = ids.reduce((trx, id) => trx.delete(id), client.transaction());
    try {
      const {
        results
      } = await transaction.commit();
      const deleted = results.filter(res => res.operation === "delete").map(res => res.id);
      const notFound = ids.filter(id => !deleted.includes(id));
      if (deleted.length > 0) {
        output.print("Deleted ".concat(deleted.length, " ").concat(pluralize__default.default("document", deleted.length)));
      }
      if (notFound.length > 0) {
        output.error(chalk.red("".concat(pluralize__default.default("Document", notFound.length), " not found: ").concat(notFound.join(", "))));
      }
    } catch (err) {
      throw new Error("Failed to delete ".concat(pluralize__default.default("document", ids.length), ":\n").concat(err.message));
    }
  }
};
const helpText$c = '\nOptions\n  --replace On duplicate document IDs, replace existing document with specified document(s)\n  --missing On duplicate document IDs, don\'t modify the target document(s)\n  --watch   Write the documents whenever the target file or buffer changes\n  --json5   Use JSON5 file type to allow a "simplified" version of JSON\n  --id <id> Specify a document ID to use. Will fetch remote document ID and populate editor.\n  --dataset NAME to override dataset\n\nExamples\n  # Create the document specified in "myDocument.json".\n  sanity documents create myDocument.json\n\n  # Open configured $EDITOR and create the specified document(s)\n  sanity documents create\n\n  # Fetch document with the ID "myDocId" and open configured $EDITOR with the\n  # current document content (if any). Replace document with the edited version\n  # when the editor closes\n  sanity documents create --id myDocId --replace\n\n  # Open configured $EDITOR and replace the document with the given content\n  # on each save. Use JSON5 file extension and parser for simplified syntax.\n  sanity documents create --id myDocId --watch --replace --json5\n';
const createDocumentsCommand = {
  name: "create",
  group: "documents",
  signature: "[FILE]",
  helpText: helpText$c,
  description: "Create one or more documents",
  // eslint-disable-next-line complexity
  action: async (args, context) => {
    const {
      apiClient,
      output
    } = context;
    const {
      replace,
      missing,
      watch,
      id,
      dataset
    } = args.extOptions;
    const [file] = args.argsWithoutOptions;
    const useJson5 = args.extOptions.json5;
    const client = dataset ? apiClient().clone().config({
      dataset
    }) : apiClient();
    if (replace && missing) {
      throw new Error("Cannot use both --replace and --missing");
    }
    if (id && file) {
      throw new Error("Cannot use --id when specifying a file path");
    }
    let operation = "create";
    if (replace || missing) {
      operation = replace ? "createOrReplace" : "createIfNotExists";
    }
    if (file) {
      const contentPath = path__default.default.resolve(process.cwd(), file);
      const content = json5__default.default.parse(await fs__default.default.readFile(contentPath, "utf8"));
      const result = await writeDocuments(content, operation, client);
      output.print(getResultMessage(result, operation));
      return;
    }
    const docId = id || uuid.uuid();
    const ext = useJson5 ? "json5" : "json";
    const tmpFile = path__default.default.join(os__default.default.tmpdir(), "sanity-cli", "".concat(docId, ".").concat(ext));
    const stringify = useJson5 ? json5__default.default.stringify : JSON.stringify;
    const defaultValue = id && (await client.getDocument(id)) || {
      _id: docId,
      _type: "specify-me"
    };
    await fs__default.default.mkdir(path__default.default.join(os__default.default.tmpdir(), "sanity-cli"), {
      recursive: true
    });
    await fs__default.default.writeFile(tmpFile, stringify(defaultValue, null, 2), "utf8");
    const editor = getEditor();
    if (watch) {
      registerUnlinkOnSigInt(tmpFile);
      output.print("Watch mode: ".concat(tmpFile));
      output.print("Watch mode: Will write documents on each save.");
      output.print("Watch mode: Press Ctrl + C to cancel watch mode.");
      chokidar__default.default.watch(tmpFile).on("change", () => {
        output.print("");
        return readAndPerformCreatesFromFile(tmpFile);
      });
      execa__default.default(editor.bin, editor.args.concat(tmpFile), {
        stdio: "inherit"
      });
    } else {
      execa__default.default.sync(editor.bin, editor.args.concat(tmpFile), {
        stdio: "inherit"
      });
      await readAndPerformCreatesFromFile(tmpFile);
      await fs__default.default.unlink(tmpFile).catch(noop__default.default);
    }
    async function readAndPerformCreatesFromFile(filePath) {
      let content;
      try {
        content = json5__default.default.parse(await fs__default.default.readFile(filePath, "utf8"));
      } catch (err) {
        output.error("Failed to read input: ".concat(err.message));
        return;
      }
      if (isEqual__default.default(content, defaultValue)) {
        output.print("Value not modified, doing nothing.");
        output.print("Modify document to trigger creation.");
        return;
      }
      try {
        const writeResult = await writeDocuments(content, operation, client);
        output.print(getResultMessage(writeResult, operation));
      } catch (err) {
        output.error("Failed to write documents: ".concat(err.message));
        if (err.message.includes("already exists")) {
          output.error("Perhaps you want to use `--replace` or `--missing`?");
        }
      }
    }
  }
};
function registerUnlinkOnSigInt(tmpFile) {
  process.on("SIGINT", async () => {
    await fs__default.default.unlink(tmpFile).catch(noop__default.default);
    process.exit(130);
  });
}
function writeDocuments(documents, operation, client) {
  const docs = Array.isArray(documents) ? documents : [documents];
  if (docs.length === 0) {
    throw new Error("No documents provided");
  }
  const mutations = docs.map((doc, index) => {
    validateDocument(doc, index, docs);
    if (operation === "create") {
      return {
        create: doc
      };
    }
    if (operation === "createIfNotExists") {
      if (isIdentifiedSanityDocument(doc)) {
        return {
          createIfNotExists: doc
        };
      }
      throw new Error("Missing required _id attribute for ".concat(operation));
    }
    if (operation === "createOrReplace") {
      if (isIdentifiedSanityDocument(doc)) {
        return {
          createOrReplace: doc
        };
      }
      throw new Error("Missing required _id attribute for ".concat(operation));
    }
    throw new Error("Unsupported operation ".concat(operation));
  });
  return client.transaction(mutations).commit();
}
function validateDocument(doc, index, arr) {
  const isSingle = arr.length === 1;
  if (!isPlainObject__default.default(doc)) {
    throw new Error(getErrorMessage("must be an object", index, isSingle));
  }
  if (!isSanityDocumentish(doc)) {
    throw new Error(getErrorMessage("must have a `_type` property of type string", index, isSingle));
  }
}
function isSanityDocumentish(doc) {
  return doc !== null && typeof doc === "object" && "_type" in doc && typeof doc._type === "string";
}
function isIdentifiedSanityDocument(doc) {
  return isSanityDocumentish(doc) && "_id" in doc;
}
function getErrorMessage(message, index, isSingle) {
  return isSingle ? "Document ".concat(message) : "Document at index ".concat(index, " ").concat(message);
}
function getResultMessage(result, operation) {
  const joiner = "\n  - ";
  if (operation === "createOrReplace") {
    return "Upserted:\n  - ".concat(result.results.map(res => res.id).join(joiner));
  }
  if (operation === "create") {
    return "Created:\n  - ".concat(result.results.map(res => res.id).join(joiner));
  }
  const created = [];
  const skipped = [];
  for (const res of result.results) {
    if (res.operation === "update") {
      skipped.push(res.id);
    } else {
      created.push(res.id);
    }
  }
  if (created.length > 0 && skipped.length > 0) {
    return ["Created:\n  - ".concat(created.join(joiner)), "Skipped (already exists):".concat(joiner).concat(skipped.join(joiner))].join("\n\n");
  } else if (created.length > 0) {
    return "Created:\n  - ".concat(created.join(joiner));
  }
  return "Skipped (already exists):\n  - ".concat(skipped.join(joiner));
}
function getEditor() {
  const defaultEditor = /^win/.test(process.platform) ? "notepad" : "vim";
  const editor = process.env.VISUAL || process.env.EDITOR || defaultEditor;
  const args = editor.split(/\s+/);
  const bin = args.shift() || "";
  return {
    bin,
    args
  };
}
const helpText$b = '\nNotes\n  Changing the hostname or port number might require a new entry to the CORS-origins allow list.\n\nOptions\n  --port <port> TCP port to start server on. [default: 3333]\n  --host <host> The local network interface at which to listen. [default: "127.0.0.1"]\n\nExamples\n  sanity dev --host=0.0.0.0\n  sanity dev --port=1942\n';
const devCommand = {
  name: "dev",
  signature: "[--port <port>] [--host <host>]",
  description: "Starts a development server for the Sanity Studio",
  action: async (args, context) => {
    const devAction = await getDevAction();
    return devAction(args, context);
  },
  helpText: helpText$b
};
async function getDevAction() {
  const mod = await Promise.resolve().then(function () {
    return require('./devAction-81690fad.js');
  });
  return mod.default;
}
const isInteractive = process.stdout.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env);
const helpText$a = '\nNotes\n  Changing the hostname or port number might require a new CORS-entry to be added.\n\nOptions\n  --port <port> TCP port to start server on. [default: 3333]\n  --host <host> The local network interface at which to listen. [default: "127.0.0.1"]\n\nExamples\n  sanity start --host=0.0.0.0\n  sanity start --port=1942\n  sanity start some/build-output-dir\n';
const startCommand = {
  name: "start",
  signature: "[BUILD_OUTPUT_DIR] [--port <port>] [--host <host>]",
  description: "Alias of `sanity preview`",
  action: async (args, context) => {
    const {
      output,
      chalk,
      prompt
    } = context;
    const previewAction = await getPreviewAction$1();
    const warn = msg => output.warn(chalk.yellow.bgBlack(msg));
    const error = msg => output.warn(chalk.red.bgBlack(msg));
    warn("\u256D\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256E");
    warn("\u2502                                                           \u2502");
    warn("\u2502  You're running Sanity Studio v3. In this version the     \u2502");
    warn("\u2502  [start] command is used to preview static builds.        |");
    warn("\u2502                                                           \u2502");
    warn("\u2502  To run a development server, use the [npm run dev] or    |");
    warn("\u2502  [npx sanity dev] command instead. For more information,  \u2502");
    warn("\u2502  see https://www.sanity.io/help/studio-v2-vs-v3           \u2502");
    warn("\u2502                                                           \u2502");
    warn("\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256F");
    warn("");
    try {
      await previewAction(args, context);
    } catch (err) {
      if (err.name !== "BUILD_NOT_FOUND") {
        throw err;
      }
      error(err.message);
      error("\n");
      const shouldRunDevServer = isInteractive && (await prompt.single({
        message: "Do you want to start a development server instead?",
        type: "confirm"
      }));
      if (shouldRunDevServer) {
        const devAction = await getDevAction();
        await devAction(args, context);
      } else {
        process.exit(1);
      }
    }
  },
  helpText: helpText$a
};
async function getPreviewAction$1() {
  const mod = await Promise.resolve().then(function () {
    return require('./previewAction-2b414fa4.js');
  });
  return mod.default;
}
const helpText$9 = '\nNotes\n  Changing the hostname or port number might require a new entry to the CORS-origins allow list.\n\nOptions\n  --port <port> TCP port to start server on. [default: 3333]\n  --host <host> The local network interface at which to listen. [default: "127.0.0.1"]\n\nExamples\n  sanity preview --host=0.0.0.0\n  sanity preview --port=1942\n  sanity preview some/build-output-dir\n';
const previewCommand = {
  name: "preview",
  signature: "[BUILD_OUTPUT_DIR] [--port <port>] [--host <host>]",
  description: "Starts a local web server for previewing production build",
  action: async (args, context) => {
    const previewAction = await getPreviewAction();
    return previewAction(args, context);
  },
  helpText: helpText$9
};
async function getPreviewAction() {
  const mod = await Promise.resolve().then(function () {
    return require('./previewAction-2b414fa4.js');
  });
  return mod.default;
}
const uninstallCommand = {
  name: "uninstall",
  signature: "[plugin]",
  helpText: "",
  description: "Removes a Sanity plugin from the current Sanity configuration",
  hideFromHelp: true,
  action: async (args, context) => {
    await context.output.error("`sanity uninstall` is no longer supported - use npm/yarn");
  }
};
const hookGroup = {
  name: "hook",
  signature: "[COMMAND]",
  isGroupRoot: true,
  description: "Interact with hooks in your project"
};
const createHookCommand = {
  name: "create",
  group: "hook",
  signature: "",
  helpText: "",
  description: "Create a new hook for the given dataset",
  action: async (args, context) => {
    const {
      apiClient,
      output
    } = context;
    const client = apiClient();
    const {
      projectId
    } = client.config();
    if (!projectId) {
      throw new Error("No project ID found");
    }
    const projectInfo = (await client.projects.getById(projectId)) || {};
    const organizationId = projectInfo.organizationId || "personal";
    const manageUrl = "https://www.sanity.io/organizations/".concat(organizationId, "/project/").concat(projectId, "/api/webhooks/new");
    output.print("Opening ".concat(manageUrl));
    open__default.default(manageUrl);
  }
};
const deleteHookCommand = {
  name: "delete",
  group: "hook",
  signature: "[NAME]",
  helpText: "",
  description: "Delete a hook within your project",
  action: async (args, context) => {
    const {
      apiClient
    } = context;
    const [name] = args.argsWithoutOptions;
    const client = apiClient();
    const hookId = await promptForHook$1(name, context);
    try {
      await client.clone().config({
        apiVersion: "2021-10-04"
      }).request({
        method: "DELETE",
        uri: "/hooks/".concat(hookId)
      });
    } catch (err) {
      throw new Error("Hook deletion failed:\n".concat(err.message));
    }
  }
};
async function promptForHook$1(specified, context) {
  const specifiedName = specified && specified.toLowerCase();
  const {
    prompt,
    apiClient
  } = context;
  const client = apiClient();
  const hooks = await client.clone().config({
    apiVersion: "2021-10-04"
  }).request({
    uri: "/hooks",
    json: true
  });
  if (specifiedName) {
    const selected = hooks.filter(hook => hook.name.toLowerCase() === specifiedName)[0];
    if (!selected) {
      throw new Error('Hook with name "'.concat(specified, ' not found"'));
    }
    return selected.id;
  }
  const choices = hooks.map(hook => ({
    value: hook.id,
    name: hook.name
  }));
  return prompt.single({
    message: "Select hook to delete",
    type: "list",
    choices
  });
}
const listHooksCommand = {
  name: "list",
  group: "hook",
  signature: "",
  helpText: "",
  description: "List hooks for a given project",
  action: async (args, context) => {
    const {
      apiClient,
      output
    } = context;
    const client = apiClient();
    let hooks;
    try {
      hooks = await client.clone().config({
        apiVersion: "2021-10-04"
      }).request({
        uri: "/hooks"
      });
    } catch (err) {
      throw new Error("Hook list retrieval failed:\n".concat(err.message));
    }
    hooks.forEach(hook => {
      output.print("Name: ".concat(hook.name));
      output.print("Dataset: ".concat(hook.dataset));
      output.print("URL: ".concat(hook.url));
      if (hook.type === "document") {
        output.print("HTTP method: ".concat(hook.httpMethod));
        if (hook.description) {
          output.print("Description: ".concat(hook.description));
        }
      }
      output.print("");
    });
  }
};
const printHookAttemptCommand = {
  name: "attempt",
  group: "hook",
  signature: "ATTEMPT_ID",
  helpText: "",
  description: "Print details of a given webhook delivery attempt",
  action: async (args, context) => {
    const {
      apiClient,
      output
    } = context;
    const [attemptId] = args.argsWithoutOptions;
    const client = apiClient();
    let attempt;
    try {
      attempt = await client.request({
        uri: "/hooks/attempts/".concat(attemptId)
      });
    } catch (err) {
      throw new Error("Hook attempt retrieval failed:\n".concat(err.message));
    }
    const {
      createdAt,
      resultCode,
      resultBody,
      failureReason,
      inProgress
    } = attempt;
    output.print("Date: ".concat(createdAt));
    output.print("Status: ".concat(getStatus(attempt)));
    output.print("Status code: ".concat(resultCode));
    if (attempt.isFailure) {
      output.print("Failure: ".concat(formatFailure(attempt)));
    }
    if (!inProgress && (!failureReason || failureReason === "http")) {
      const body = resultBody ? "\n---\n".concat(resultBody, "\n---\n") : "<empty>";
      output.print("Response body: ".concat(body));
    }
  }
};
function formatFailure(attempt) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    includeHelp
  } = options;
  const {
    id,
    failureReason,
    resultCode
  } = attempt;
  const help = includeHelp ? "(run `sanity hook attempt ".concat(id, "` for details)") : "";
  switch (failureReason) {
    case "http":
      return "HTTP ".concat(resultCode, " ").concat(help);
    case "timeout":
      return "Request timed out";
    case "network":
      return "Network error";
  }
  return "Unknown error";
}
function getStatus(attempt) {
  if (attempt.isFailure) {
    return "Failed";
  }
  if (attempt.inProgress) {
    return "In progress";
  }
  return "Delivered";
}
const listHookLogsCommand = {
  name: "logs",
  group: "hook",
  signature: "[NAME]",
  helpText: "",
  description: "List latest log entries for a given hook",
  action: async (args, context) => {
    const {
      apiClient
    } = context;
    const flags = args.extOptions;
    const [name] = args.argsWithoutOptions;
    const client = apiClient();
    const hookId = await promptForHook(name, context);
    let messages;
    let attempts;
    try {
      messages = await client.request({
        uri: "/hooks/".concat(hookId, "/messages")
      });
      attempts = await client.request({
        uri: "/hooks/".concat(hookId, "/attempts")
      });
    } catch (err) {
      throw new Error("Hook logs retrieval failed:\n".concat(err.message));
    }
    const groupedAttempts = groupBy__default.default(attempts, "messageId");
    const populated = messages.map(msg => ({
      ...msg,
      attempts: groupedAttempts[msg.id]
    }));
    const totalMessages = messages.length - 1;
    populated.forEach((message, i) => {
      printMessage(message, context, {
        detailed: flags.detailed
      });
      printSeparator(context, totalMessages === i);
    });
  }
};
async function promptForHook(specified, context) {
  const specifiedName = specified && specified.toLowerCase();
  const {
    prompt,
    apiClient
  } = context;
  const client = apiClient();
  const hooks = await client.clone().config({
    apiVersion: "2021-10-04"
  }).request({
    uri: "/hooks",
    json: true
  });
  if (specifiedName) {
    const selected = hooks.filter(hook => hook.name.toLowerCase() === specifiedName)[0];
    if (!selected) {
      throw new Error('Hook with name "'.concat(specified, ' not found"'));
    }
    return selected.id;
  }
  if (hooks.length === 0) {
    throw new Error("No hooks currently registered");
  }
  if (hooks.length === 1) {
    return hooks[0].id;
  }
  const choices = hooks.map(hook => ({
    value: hook.id,
    name: hook.name
  }));
  return prompt.single({
    message: "Select hook to list logs for",
    type: "list",
    choices
  });
}
function printSeparator(context, skip) {
  if (!skip) {
    context.output.print("---\n");
  }
}
function printMessage(message, context, options) {
  const {
    detailed
  } = options;
  const {
    output,
    chalk
  } = context;
  output.print("Date: ".concat(message.createdAt));
  output.print("Status: ".concat(message.status));
  output.print("Result code: ".concat(message.resultCode));
  if (message.failureCount > 0) {
    output.print("Failures: ".concat(message.failureCount));
  }
  if (detailed) {
    output.print("Payload:");
    output.print(util.inspect(JSON.parse(message.payload), {
      colors: true
    }));
  }
  if (detailed && message.attempts) {
    output.print("Attempts:");
    message.attempts.forEach(attempt => {
      const date = attempt.createdAt.replace(/\.\d+Z$/, "Z");
      const prefix = "  [".concat(date, "]");
      if (attempt.inProgress) {
        output.print("".concat(prefix, " ").concat(chalk.yellow("Pending")));
      } else if (attempt.isFailure) {
        const failure = formatFailure(attempt, {
          includeHelp: true
        });
        output.print("".concat(prefix, " ").concat(chalk.yellow("Failure: ".concat(failure))));
      } else {
        output.print("".concat(prefix, " Success: HTTP ").concat(attempt.resultCode, " (").concat(attempt.duration, "ms)"));
      }
    });
  }
  output.print("");
}
const helpText$8 = "\nOptions\n  --with-user-token Prime access token from CLI config into getCliClient()\n  --mock-browser-env Mocks a browser-like environment using jsdom\n\nExamples\n  # Run the script at some/script.js in Sanity context\n  sanity exec some/script.js\n\n  # Run the script at migrations/fullname.ts and configure `getCliClient()`\n  # from `sanity/cli`to include the current user's token\n  sanity exec migrations/fullname.ts --with-user-token\n\n  # Run the script at scripts/browserScript.js in a mock browser environment\n  sanity exec scripts/browserScript.js --mock-browser-env\n\n  # Pass arbitrary arguments to scripts by separating them with a `--`.\n  # Arguments are available in `process.argv` as they would in regular node scripts\n  # eg the following command would yield a `process.argv` of:\n  # ['/path/to/node', '/path/to/myscript.js', '--dry-run', 'positional-argument']\n  sanity exec --mock-browser-env myscript.js -- --dry-run positional-argument\n";
const execCommand = {
  name: "exec",
  signature: "SCRIPT",
  description: "Runs a script in Sanity context",
  helpText: helpText$8,
  action: async (args, context) => {
    const mod = await Promise.resolve().then(function () {
      return require('./execScript-aa6f7f6b.js');
    });
    return mod.default(args, context);
  }
};
const corsGroup = {
  name: "cors",
  signature: "[COMMAND]",
  isGroupRoot: true,
  description: "Interact with CORS-entries for your project"
};
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a, _b, _c, _d;
const wildcardReplacement = "a-wild-card-r3pl4c3m3n7-a";
const portReplacement = ":7777777";
async function addCorsOrigin(givenOrigin, flags, context) {
  const {
    apiClient,
    prompt,
    output
  } = context;
  const origin = await (givenOrigin ? filterAndValidateOrigin(givenOrigin) : promptForOrigin$1(prompt));
  const hasWildcard = origin.includes("*");
  if (hasWildcard && !(await promptForWildcardConfirmation(origin, context))) {
    return false;
  }
  const allowCredentials = typeof flags.credentials === "undefined" ? await promptForCredentials(hasWildcard, context) : Boolean(flags.credentials);
  if (givenOrigin !== origin) {
    output.print("Normalized origin to ".concat(origin));
  }
  const client = apiClient({
    requireUser: true,
    requireProject: true
  });
  await client.request({
    method: "POST",
    url: "/cors",
    body: {
      origin,
      allowCredentials
    },
    maxRedirects: 0
  });
  return true;
}
function promptForCredentials(hasWildcard, context) {
  const {
    prompt,
    output,
    chalk
  } = context;
  output.print("");
  if (hasWildcard) {
    output.print(oneline__default.default(_a || (_a = __template(["\n      ", "\n      We ", " recommend NOT allowing credentials\n      on origins containing wildcards. If you are logged in to a studio, people will\n      be able to send requests ", " to read and modify\n      data, from any matching origin. Please tread carefully!\n    "])), chalk.yellow("".concat(logSymbols__default.default.warning, " Warning:")), chalk.red(chalk.underline("HIGHLY")), chalk.underline("on your behalf")));
  } else {
    output.print(oneline__default.default(_b || (_b = __template(["\n      ", "\n      Should this origin be allowed to send requests using authentication tokens or\n      session cookies? Be aware that any script on this origin will be able to send\n      requests ", ' to read and modify data if you\n      are logged in to a Sanity studio. If this origin hosts a studio, you will need\n      this, otherwise you should probably answer "No" (n).\n    '])), chalk.yellow("".concat(logSymbols__default.default.warning, " Warning:")), chalk.underline("on your behalf")));
  }
  output.print("");
  return prompt.single({
    type: "confirm",
    message: oneline__default.default(_c || (_c = __template(["\n      Allow credentials to be sent from this origin? Please read the warning above.\n    "]))),
    default: false
  });
}
function promptForWildcardConfirmation(origin, context) {
  const {
    prompt,
    output,
    chalk
  } = context;
  output.print("");
  output.print(chalk.yellow("".concat(logSymbols__default.default.warning, " Warning: Examples of allowed origins:")));
  if (origin === "*") {
    output.print("- http://www.some-malicious.site");
    output.print("- https://not.what-you-were-expecting.com");
    output.print("- https://high-traffic-site.com");
    output.print("- http://192.168.1.1:8080");
  } else {
    output.print("- ".concat(origin.replace(/:\*/, ":1234").replace(/\*/g, "foo")));
    output.print("- ".concat(origin.replace(/:\*/, ":3030").replace(/\*/g, "foo.bar")));
  }
  output.print("");
  return prompt.single({
    type: "confirm",
    message: oneline__default.default(_d || (_d = __template(["\n      Using wildcards can be ", ".\n      Are you ", " you want to allow this origin?"])), chalk.red("risky"), chalk.underline("absolutely sure")),
    default: false
  });
}
function promptForOrigin$1(prompt) {
  return prompt.single({
    type: "input",
    message: "Origin (including protocol):",
    filter: filterOrigin,
    validate: origin => validateOrigin(origin, origin)
  });
}
function filterOrigin(origin) {
  if (origin === "*" || origin === "file:///*" || origin === "null") {
    return origin;
  }
  try {
    const example = origin.replace(/([^:])\*/g, "$1".concat(wildcardReplacement)).replace(/:\*/, portReplacement);
    const parsed = url__default.default.parse(example);
    let host = parsed.host || "";
    if (/^https?:$/.test(parsed.protocol || "")) {
      host = host.replace(/:(80|443)$/, "");
    }
    host = host.replace(portReplacement, ":*").replace(new RegExp(wildcardReplacement, "g"), "*");
    return "".concat(parsed.protocol, "//").concat(host);
  } catch (err) {
    return null;
  }
}
function validateOrigin(origin, givenOrigin) {
  if (origin === "*" || origin === "file:///*" || origin === "null") {
    return true;
  }
  try {
    url__default.default.parse(origin || 0);
    return true;
  } catch (err) {}
  if (/^file:\/\//.test(givenOrigin)) {
    return "Only a local file wildcard is currently allowed: file:///*";
  }
  return 'Invalid origin "'.concat(givenOrigin, '", must include protocol (https://some.host)');
}
function filterAndValidateOrigin(givenOrigin) {
  const origin = filterOrigin(givenOrigin);
  const result = validateOrigin(origin, givenOrigin);
  if (result !== true) {
    throw new Error(result);
  }
  if (!origin) {
    throw new Error("Invalid origin");
  }
  return origin;
}
const helpText$7 = "\nOptions\n  --credentials Allow credentials (token/cookie) to be sent from this origin\n  --no-credentials Disallow credentials (token/cookie) to be sent from this origin\n\nExamples\n  sanity cors add\n  sanity cors add http://localhost:3000 --no-credentials\n";
const addCorsOriginCommand = {
  name: "add",
  group: "cors",
  signature: "[ORIGIN]",
  helpText: helpText$7,
  description: "Allow a new origin to use your project API through CORS",
  action: async (args, context) => {
    const {
      output
    } = context;
    const [origin] = args.argsWithoutOptions;
    if (!origin) {
      throw new Error("No origin specified, use `sanity cors add <origin-url>`");
    }
    const flags = args.extOptions;
    const isFile = fs__default$1.default.existsSync(path__default.default.join(process.cwd(), origin));
    if (isFile) {
      output.warn('Origin "'.concat(origin, '?" Remember to quote values (sanity cors add "*")'));
    }
    const success = await addCorsOrigin(origin, flags, context);
    if (success) {
      output.print("CORS origin added successfully");
    }
  }
};
const helpText$6 = "\nExamples\n  sanity cors list\n";
const listCorsOriginsCommand = {
  name: "list",
  group: "cors",
  signature: "",
  helpText: helpText$6,
  description: "List all origins allowed to access the API for this project",
  action: async (args, context) => {
    const {
      output
    } = context;
    const {
      apiClient
    } = context;
    const client = apiClient({
      requireUser: true,
      requireProject: true
    });
    const origins = await client.request({
      url: "/cors"
    });
    output.print(origins.map(origin => origin.origin).join("\n"));
  }
};
const helpText$5 = "\nExamples\n  sanity cors delete\n  sanity cors delete http://localhost:3000\n";
const deleteCorsOriginCommand = {
  name: "delete",
  group: "cors",
  signature: "[ORIGIN]",
  helpText: helpText$5,
  description: "Delete an existing CORS-origin from your project",
  action: async (args, context) => {
    const {
      output,
      apiClient
    } = context;
    const [origin] = args.argsWithoutOptions;
    const client = apiClient({
      requireUser: true,
      requireProject: true
    });
    const originId = await promptForOrigin(origin, context);
    try {
      await client.request({
        method: "DELETE",
        uri: "/cors/".concat(originId)
      });
      output.print("Origin deleted");
    } catch (err) {
      throw new Error("Origin deletion failed:\n".concat(err.message));
    }
  }
};
async function promptForOrigin(specified, context) {
  const specifiedOrigin = specified && specified.toLowerCase();
  const {
    prompt,
    apiClient
  } = context;
  const client = apiClient({
    requireUser: true,
    requireProject: true
  });
  const origins = await client.request({
    url: "/cors"
  });
  if (specifiedOrigin) {
    const selected = origins.filter(origin => origin.origin.toLowerCase() === specifiedOrigin)[0];
    if (!selected) {
      throw new Error('Origin "'.concat(specified, ' not found"'));
    }
    return selected.id;
  }
  const choices = origins.map(origin => ({
    value: origin.id,
    name: origin.origin
  }));
  return prompt.single({
    message: "Select origin to delete",
    type: "list",
    choices
  });
}
const graphqlGroup = {
  name: "graphql",
  signature: "[COMMAND]",
  isGroupRoot: true,
  description: "Interact with GraphQL APIs"
};
const helpText$4 = "\nExamples\n  sanity graphql list\n";
const listGraphQLAPIsCommand = {
  name: "list",
  signature: "",
  group: "graphql",
  description: "Lists all the GraphQL endpoints deployed for this project",
  action: async (args, context) => {
    const mod = await Promise.resolve().then(function () {
      return require('./listApisAction-3c707c4d.js');
    });
    return mod.default(args, context);
  },
  helpText: helpText$4
};
const helpText$3 = "\nOptions\n  --dry-run Validate defined APIs, exiting with an error on breaking changes\n  --force Deploy API without confirming breaking changes\n  --api <api-id> Only deploy API with this ID. Can be specified multiple times.\n\nThe following options will override any setting from the CLI configuration file\n(sanity.cli.js/sanity.cli.ts) - and applies to ALL defined APIs defined in that\nconfiguration file. Tread with caution!\n\n  --tag Deploy API(s) to given tag (defaults to 'default')\n  --dataset <name> Deploy API for the given dataset\n  --generation <gen1|gen2|gen3> API generation to deploy (defaults to 'gen3')\n  --non-null-document-fields Use non-null document fields (_id, _type etc)\n  --playground Enable GraphQL playground for easier debugging\n  --no-playground Disable GraphQL playground\n\nExamples\n  # Deploy all defined GraphQL APIs\n  sanity graphql deploy\n\n  # Validate defined GraphQL APIs, check for breaking changes, skip deploy\n  sanity graphql deploy --dry-run\n\n  # Deploy only the GraphQL APIs with the IDs \"staging\" and \"ios\"\n  sanity graphql deploy --api staging --api ios\n\n  # Deploy all defined GraphQL APIs, overriding any playground setting\n  sanity graphql deploy --playground\n";
const deployGraphQLAPICommand = {
  name: "deploy",
  signature: "",
  group: "graphql",
  description: "Deploy a GraphQL API from the current Sanity schema",
  action: async (args, context) => {
    const mod = await Promise.resolve().then(function () {
      return require('./deployApiAction-6520d1c8.js');
    });
    return mod.default(args, context);
  },
  helpText: helpText$3
};
const helpText$2 = "\nOptions\n  --api <api-id> Undeploy API with this ID (project, dataset and tag flags takes preference)\n  --project <projectId> Project ID to delete GraphQL API for\n  --dataset <dataset> Delete GraphQL API for the given dataset\n  --tag <tag> Delete GraphQL API for the given tag (defaults to 'default')\n  --force Skip confirmation prompt, forcefully undeploying the GraphQL API\n\nExamples\n  sanity graphql undeploy\n  sanity graphql undeploy --api ios\n  sanity graphql undeploy --dataset staging\n  sanity graphql undeploy --dataset staging --tag next\n";
const deleteGraphQLAPICommand = {
  name: "undeploy",
  group: "graphql",
  signature: "",
  description: "Remove a deployed GraphQL API",
  action: async (args, context) => {
    const mod = await Promise.resolve().then(function () {
      return require('./deleteApiAction-789322a4.js');
    });
    return mod.default(args, context);
  },
  helpText: helpText$2
};
const usersGroup = {
  name: "users",
  signature: "[COMMAND]",
  isGroupRoot: true,
  description: "Manage users of your project"
};
function prettifyQuotaError(message) {
  return err => {
    if (err.statusCode === 402) {
      err.message = message;
      throw err;
    }
    throw err;
  };
}
const helpText$1 = '\nOptions\n  --role Role to invite the user as\n\nExamples\n  # Invite a new user to the project (prompt for details)\n  sanity users invite\n\n  # Send a new user invite to the email "pippi@sanity.io", prompt for role\n  sanity users invite pippi@sanity.io\n\n  # Send a new user invite to the email "pippi@sanity.io", as administrator\n  sanity users invite pippi@sanity.io --role administrator\n';
const inviteUserCommand = {
  name: "invite",
  group: "users",
  signature: "[EMAIL]",
  helpText: helpText$1,
  description: "Invite a new user to the project",
  action: async (args, context) => {
    const {
      apiClient,
      output,
      prompt
    } = context;
    const [selectedEmail] = args.argsWithoutOptions;
    const flags = args.extOptions;
    const client = apiClient().clone().config({
      useProjectHostname: false,
      apiVersion: "2021-06-07"
    });
    const {
      projectId
    } = client.config();
    const roles = (await client.request({
      uri: "/projects/".concat(projectId, "/roles")
    })).filter(role2 => role2.appliesToUsers);
    const email = selectedEmail || (await promptForEmail(prompt));
    const selectedRole = flags.role || (await promptForRole(prompt, roles));
    const role = roles.find(_ref2 => {
      let {
        name
      } = _ref2;
      return name.toLowerCase() === selectedRole.toLowerCase();
    });
    if (!role) {
      throw new Error('Role name "'.concat(selectedRole, '" not found'));
    }
    await client.clone().request({
      method: "POST",
      uri: "/invitations/project/".concat(projectId),
      body: {
        email,
        role: role.name
      },
      useGlobalApi: true,
      maxRedirects: 0
    }).catch(prettifyQuotaError("Project is already at user quota, add billing details to the project in order to allow overage charges."));
    output.print("Invitation sent to ".concat(email));
  }
};
function promptForEmail(prompt) {
  return prompt.single({
    type: "input",
    message: "Email to invite:",
    filter: val => val.trim(),
    validate: name => {
      if (!name || !name.includes("@")) {
        return "Invalid email";
      }
      return true;
    }
  });
}
function promptForRole(prompt, roles) {
  return prompt.single({
    type: "list",
    message: "Which role should the user have?",
    choices: roles.map(role => ({
      value: role.name,
      name: "".concat(role.title, " (").concat(role.description, ")")
    }))
  });
}
const sortFields = ["id", "name", "role", "date"];
const helpText = "\nOptions\n  --no-invitations Don't include pending invitations\n  --no-robots Don't include robots (token users)\n  --sort <field> Sort users by specified column: ".concat(sortFields.join(", "), "\n  --order <asc/desc> Sort output ascending/descending\n\nExamples\n  # List all users of the project\n  sanity users list\n\n  # List all users of the project, but exclude pending invitations and robots\n  sanity users list --no-invitations --no-robots\n\n  # List all users, sorted by role\n  sanity users list --sort role\n");
const listUsersCommand = {
  name: "list",
  group: "users",
  signature: "",
  helpText,
  description: "List all users of the project",
  action: async (args, context) => {
    const {
      apiClient,
      output,
      chalk
    } = context;
    const {
      sort,
      order,
      robots,
      invitations
    } = {
      sort: "date",
      order: "asc",
      robots: true,
      invitations: true,
      ...args.extOptions
    };
    if (!sortFields.includes(sort)) {
      throw new Error("Can't sort by field \"".concat(sort, '". Must be one of ').concat(sortFields.join(", ")));
    }
    if (order !== "asc" && order !== "desc") {
      throw new Error('Unknown sort order "'.concat(order, '", must be either "asc" or "desc"'));
    }
    const client = apiClient();
    const globalClient = client.clone().config({
      useProjectHostname: false
    });
    const {
      projectId
    } = client.config();
    const useGlobalApi = true;
    const [pendingInvitations, project] = await Promise.all([invitations ? globalClient.request({
      uri: "/invitations/project/".concat(projectId),
      useGlobalApi
    }).then(getPendingInvitations) : [], globalClient.request({
      uri: "/projects/".concat(projectId),
      useGlobalApi
    })]);
    const memberIds = project.members.map(member => member.id);
    const users = await globalClient.request({
      uri: "/users/".concat(memberIds.join(",")),
      useGlobalApi
    }).then(user => Array.isArray(user) ? user : [user]);
    const projectMembers = project.members.map(member => ({
      ...member,
      ...getUserProps(users.find(candidate => candidate.id === member.id))
    })).filter(member => !member.isRobot || robots);
    const members = [...projectMembers, ...pendingInvitations];
    const ordered = sortBy__default.default(members.map(_ref3 => {
      let {
        id,
        name,
        role,
        date
      } = _ref3;
      return [id, name, role, date];
    }), [sortFields.indexOf(sort)]);
    const rows = order === "asc" ? ordered : ordered.reverse();
    const maxWidths = rows.reduce((max, row) => row.map((current, index) => Math.max(size__default.default(current), max[index])), sortFields.map(str => size__default.default(str)));
    const printRow = row => {
      const isInvite = row[0] === "<pending>";
      const textRow = row.map((col, i) => "".concat(col).padEnd(maxWidths[i])).join("   ");
      return isInvite ? chalk.dim(textRow) : textRow;
    };
    output.print(chalk.cyan(printRow(sortFields)));
    rows.forEach(row => output.print(printRow(row)));
  }
};
function getUserProps(user) {
  const {
    displayName: name,
    createdAt: date
  } = user || {};
  return {
    name: name || "",
    date: date || ""
  };
}
function getPendingInvitations(invitations) {
  return invitations.filter(invite => !invite.isAccepted && !invite.isRevoked && !invite.acceptedByUserId).map(invite => ({
    id: "<pending>",
    name: invite.email,
    role: invite.role,
    date: invite.createdAt
  }));
}
const commands = [buildCommand, checkCommand, configCheckCommand, datasetGroup, deployCommand, undeployCommand, listDatasetsCommand, createDatasetCommand, datasetVisibilityCommand, exportDatasetCommand, importDatasetCommand, deleteDatasetCommand, copyDatasetCommand, aliasCommand, corsGroup, listCorsOriginsCommand, addCorsOriginCommand, deleteCorsOriginCommand, usersGroup, inviteUserCommand, listUsersCommand, hookGroup, listHooksCommand, createHookCommand, deleteHookCommand, listHookLogsCommand, printHookAttemptCommand, documentsGroup, getDocumentsCommand, queryDocumentsCommand, deleteDocumentsCommand, createDocumentsCommand, graphqlGroup, listGraphQLAPIsCommand, deployGraphQLAPICommand, deleteGraphQLAPICommand, devCommand, startCommand, previewCommand, uninstallCommand, execCommand];
const cliProjectCommands = {
  requiredCliVersionRange: "^3.0.0",
  commands
};
exports.cliProjectCommands = cliProjectCommands;
exports.debug = debug;
exports.getClientUrl = getClientUrl;
//# sourceMappingURL=_internal-0baee345.js.map
