'use strict';

var path = require('path');
var util = require('util');
var chalk = require('chalk');
var rimrafCallback = require('rimraf');
var previewServer = require('./previewServer-e5d785d0.js');
require('vite');
require('@vitejs/plugin-react');
require('read-pkg-up');
require('debug');
require('resolve-from');
require('./runtime-45c735c0.js');
require('fs');
require('connect-history-api-fallback');
require('fs/promises');
require('@sanity/cli');
var timing = require('./timing-cfdcd9fd.js');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var rimrafCallback__default = /*#__PURE__*/_interopDefaultCompat(rimrafCallback);
const rimraf = util.promisify(rimrafCallback__default.default);
async function buildSanityStudio(args, context, overrides) {
  var _a;
  const timer = timing.getTimer();
  const {
    output,
    prompt,
    workDir,
    cliConfig
  } = context;
  const flags = {
    minify: true,
    stats: false,
    "source-maps": false,
    ...args.extOptions
  };
  const unattendedMode = Boolean(flags.yes || flags.y);
  const defaultOutputDir = path__default.default.resolve(path__default.default.join(workDir, "dist"));
  const outputDir = path__default.default.resolve(args.argsWithoutOptions[0] || defaultOutputDir);
  await timing.checkStudioDependencyVersions(workDir);
  if ((await timing.checkRequiredDependencies(context)).didInstall) {
    return {
      didCompile: false
    };
  }
  const envVarKeys = getSanityEnvVars();
  if (envVarKeys.length > 0) {
    output.print("\nIncluding the following environment variables as part of the JavaScript bundle:");
    envVarKeys.forEach(key => output.print("- ".concat(key)));
    output.print("");
  }
  let shouldClean = true;
  if (outputDir !== defaultOutputDir && !unattendedMode) {
    shouldClean = await prompt.single({
      type: "confirm",
      message: "Do you want to delete the existing directory (".concat(outputDir, ") first?"),
      default: true
    });
  }
  let basePath = "/";
  const envBasePath = process.env.SANITY_STUDIO_BASEPATH;
  const configBasePath = (_a = cliConfig == null ? void 0 : cliConfig.project) == null ? void 0 : _a.basePath;
  if (overrides == null ? void 0 : overrides.basePath) {
    basePath = overrides.basePath;
  } else if (envBasePath) {
    basePath = envBasePath;
  } else if (configBasePath) {
    basePath = configBasePath;
  }
  if (envBasePath && configBasePath) {
    output.warn("Overriding configured base path (".concat(configBasePath, ") with value from environment variable (").concat(envBasePath, ")"));
  }
  let spin;
  if (shouldClean) {
    timer.start("cleanOutputFolder");
    spin = output.spinner("Clean output folder").start();
    await rimraf(outputDir);
    const cleanDuration = timer.end("cleanOutputFolder");
    spin.text = "Clean output folder (".concat(cleanDuration.toFixed(), "ms)");
    spin.succeed();
  }
  spin = output.spinner("Build Sanity Studio").start();
  try {
    timer.start("bundleStudio");
    const bundle = await previewServer.buildStaticFiles({
      cwd: workDir,
      outputDir,
      basePath,
      sourceMap: Boolean(flags["source-maps"]),
      minify: Boolean(flags.minify),
      vite: cliConfig && "vite" in cliConfig ? cliConfig.vite : void 0
    });
    const buildDuration = timer.end("bundleStudio");
    spin.text = "Build Sanity Studio (".concat(buildDuration.toFixed(), "ms)");
    spin.succeed();
    if (flags.stats) {
      output.print("\nLargest module files:");
      output.print(formatModuleSizes(sortModulesBySize(bundle.chunks).slice(0, 15)));
    }
  } catch (err) {
    spin.fail();
    throw err;
  }
  return {
    didCompile: true
  };
}
function getSanityEnvVars() {
  let env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.env;
  return Object.keys(env).filter(key => key.toUpperCase().startsWith("SANITY_STUDIO_"));
}
function sortModulesBySize(chunks) {
  return chunks.flatMap(chunk => chunk.modules).sort((modA, modB) => modB.renderedLength - modA.renderedLength);
}
function formatModuleSizes(modules) {
  const lines = [];
  for (const mod of modules) {
    lines.push(" - ".concat(formatModuleName(mod.name), " (").concat(formatSize(mod.renderedLength), ")"));
  }
  return lines.join("\n");
}
function formatModuleName(modName) {
  const delimiter = "/node_modules/";
  const nodeIndex = modName.lastIndexOf(delimiter);
  return nodeIndex === -1 ? modName : modName.slice(nodeIndex + delimiter.length);
}
function formatSize(bytes) {
  return chalk__default.default.cyan("".concat((bytes / 1024).toFixed(), " kB"));
}
exports.default = buildSanityStudio;
//# sourceMappingURL=buildAction-51ccc980.js.map
