import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import React, { useMemo, useCallback, useState, useEffect, createElement, memo, lazy, Suspense, useRef, forwardRef, useId, isValidElement, useLayoutEffect, Fragment as Fragment$1 } from 'react';
import { useElementRect, Box, Card, Container, Heading, Stack, Label, Code, Text, Button, Flex, _raf2, Spinner, useToast, rem, TextInput, Dialog, TabList, Tab, TabPanel, focusFirstDescendant, Tooltip, usePortal, PortalProvider, BoundaryElementProvider, Popover, useLayer, useClickOutside, useGlobalKeyDown, Grid, MenuButton, Menu, MenuItem, LayerProvider, Inline, Badge, DialogProvider, useTheme, ErrorBoundary } from '@sanity/ui';
import { usePaneLayout, ChildLink, BackLink, ReferenceChildLink, ParameterizedLink, PaneRouterContext, PANE_DEFAULT_MIN_WIDTH, PANE_COLLAPSED_WIDTH, PaneLayoutContext, Root as Root$4, usePane, useDocumentPane, useDeskTool, Resizable, DOCUMENT_INSPECTOR_MAX_WIDTH, DOCUMENT_INSPECTOR_MIN_WIDTH, LOADING_PANE, SerializeError, Pane, PaneHeader, PaneContent, usePaneRouter, DocTitle, Delay, resolveMenuNodes, isMenuNodeButton, isNotMenuNodeButton, TimelineMenu, PaneHeaderActionButton, PaneContextMenuButton, DOCUMENT_PANEL_PORTAL_ELEMENT, HistoryRestoreAction, DocumentPaneProvider, PaneFooter, DOCUMENT_PANEL_INITIAL_MIN_WIDTH, DOCUMENT_PANEL_MIN_WIDTH, setActivePanes, DeskToolProvider } from './desk-08e4184f.js';
import omit from 'lodash/omit.js';
import { isObservable, from, of, firstValueFrom, NEVER, concat, ReplaySubject, merge } from 'rxjs';
import { nanoid } from 'nanoid';
import { switchMap, publishReplay, refCount, map, startWith, pairwise, scan, distinctUntilChanged, mapTo, delay, debounceTime, tap } from 'rxjs/operators';
import { GetHookCollectionState, isRecord, useDocumentStore, isDev, useDocumentOperationEvent, useSettingsStore, isString, useDocumentOperation, useDocumentPreviewStore, getPublishedId, useCurrentUser, useDocumentPresence, createPatchChannel, PresenceOverlay, FormBuilder, fromMutationPatches, unstable_useValuePreview, useFieldActions, useTimelineSelector, ScrollContainer, VirtualizerScrollInstanceProvider, LegacyLayerProvider, Hotkeys, useTimeAgo, useSyncState, ChangeConnectorRoot, useSource, SourceProvider, useDocumentType, useTemplatePermissions, ReferenceInputOptionsProvider, useTemplates, useZIndex, useEditState, useSchema, _isCustomDocumentTypeDefinition, useWorkspace } from 'sanity';
import { generateHelpUrl } from '@sanity/generate-help-url';
import isEqual from 'lodash/isEqual.js';
import { useRouter, useRouterState } from 'sanity/router';
import { uuid } from '@sanity/uuid';
import styled, { css, keyframes } from 'styled-components';
import { SyncIcon, SearchIcon, ReadOnlyIcon, WarningOutlineIcon, CloseIcon, ArrowLeftIcon, SplitVerticalIcon, ChevronDownIcon, PlayIcon, PublishIcon } from '@sanity/icons';
import 'lodash/camelCase.js';
import 'speakingurl';
import 'lodash/uniq.js';
import 'lodash/kebabCase.js';
import 'lodash/pickBy.js';
import 'lodash/find.js';
import 'lodash/uniqueId.js';
import { isValidElementType } from 'react-is';
import 'lodash/startCase.js';
import isHotkey from 'is-hotkey';
import { toString, fromString, get } from '@sanity/util/paths';
import '@sanity/types';
import 'lodash/isNumber.js';
import 'lodash/isString.js';
import { useMemoObservable } from 'react-rx';
import JSONInspector from '@rexxars/react-json-inspector';
import HLRU from 'hashlru';
import { motion } from 'framer-motion';
const RenderActionCollectionState = props => {
  const {
    actions,
    children,
    actionProps,
    onActionComplete
  } = props;
  return /* @__PURE__ */jsx(GetHookCollectionState, {
    onReset: onActionComplete,
    hooks: actions,
    args: actionProps,
    children
  });
};
const RenderBadgeCollectionState = props => {
  const {
    badges,
    children,
    badgeProps,
    ...rest
  } = props;
  return /* @__PURE__ */jsx(GetHookCollectionState, {
    ...rest,
    hooks: badges,
    args: badgeProps,
    children
  });
};
const emptyArray = [];
function PaneRouterProvider(props) {
  const {
    children,
    flatIndex,
    index,
    params,
    payload,
    siblingIndex
  } = props;
  const {
    navigate,
    navigateIntent,
    resolvePathFromState
  } = useRouter();
  const routerState = useRouterState();
  const {
    panes,
    expand
  } = usePaneLayout();
  const routerPaneGroups = useMemo(() => (routerState == null ? void 0 : routerState.panes) || emptyArray, [routerState == null ? void 0 : routerState.panes]);
  const lastPane = useMemo(() => panes == null ? void 0 : panes[panes.length - 2], [panes]);
  const groupIndex = index - 1;
  const createNextRouterState = useCallback(modifier => {
    const currentGroup = routerPaneGroups[groupIndex] || [];
    const currentItem = currentGroup[siblingIndex];
    const nextGroup = modifier(currentGroup, currentItem);
    const nextPanes = [...routerPaneGroups.slice(0, groupIndex), nextGroup, ...routerPaneGroups.slice(groupIndex + 1)];
    const nextRouterState = {
      ...(routerState || {}),
      panes: nextPanes
    };
    return nextRouterState;
  }, [groupIndex, routerPaneGroups, routerState, siblingIndex]);
  const modifyCurrentGroup = useCallback(modifier => {
    const nextRouterState = createNextRouterState(modifier);
    setTimeout(() => navigate(nextRouterState), 0);
    return nextRouterState;
  }, [createNextRouterState, navigate]);
  const createPathWithParams = useCallback(nextParams => {
    const nextRouterState = createNextRouterState((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      params: nextParams
    }, ...siblings.slice(siblingIndex + 1)]);
    return resolvePathFromState(nextRouterState);
  }, [createNextRouterState, resolvePathFromState, siblingIndex]);
  const setPayload = useCallback(nextPayload => {
    modifyCurrentGroup((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      payload: nextPayload
    }, ...siblings.slice(siblingIndex + 1)]);
  }, [modifyCurrentGroup, siblingIndex]);
  const setParams = useCallback(nextParams => {
    modifyCurrentGroup((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      params: nextParams
    }, ...siblings.slice(siblingIndex + 1)]);
  }, [modifyCurrentGroup, siblingIndex]);
  const handleEditReference = useCallback(_ref => {
    let {
      id,
      parentRefPath,
      type,
      template
    } = _ref;
    navigate({
      panes: [...routerPaneGroups.slice(0, groupIndex + 1), [{
        id,
        params: {
          template: template.id,
          parentRefPath: toString(parentRefPath),
          type
        },
        payload: template.params
      }]]
    });
  }, [groupIndex, navigate, routerPaneGroups]);
  const ctx = useMemo(() => ({
    // Zero-based index (position) of pane, visually
    index: flatIndex,
    // Zero-based index of pane group (within URL structure)
    groupIndex,
    // Zero-based index of pane within sibling group
    siblingIndex,
    // Payload of the current pane
    payload,
    // Params of the current pane
    params,
    // Whether or not the pane has any siblings (within the same group)
    hasGroupSiblings: routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length > 1 : false,
    // The length of the current group
    groupLength: routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length : 0,
    // Current router state for the "panes" property
    routerPanesState: routerPaneGroups,
    // Curried StateLink that passes the correct state automatically
    ChildLink,
    // Curried StateLink that pops off the last pane group
    BackLink,
    // A specialized `ChildLink` that takes in the needed props to open a
    // referenced document to the right
    ReferenceChildLink,
    // Similar to `ReferenceChildLink` expect without the wrapping component
    handleEditReference,
    // Curried StateLink that passed the correct state, but merges params/payload
    ParameterizedLink,
    // Replaces the current pane with a new one
    replaceCurrent: function () {
      let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      modifyCurrentGroup(() => [{
        id: opts.id || "",
        payload: opts.payload,
        params: opts.params || {}
      }]);
    },
    // Removes the current pane from the group
    closeCurrent: () => {
      modifyCurrentGroup((siblings, item) => siblings.length > 1 ? siblings.filter(sibling => sibling !== item) : siblings);
    },
    // Removes all panes to the right including current
    closeCurrentAndAfter: function () {
      let expandLast = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (expandLast && lastPane) {
        expand(lastPane.element);
      }
      navigate({
        panes: [...routerPaneGroups.slice(0, groupIndex)]
      }, {
        replace: true
      });
    },
    // Duplicate the current pane, with optional overrides for payload, parameters
    duplicateCurrent: options => {
      modifyCurrentGroup((siblings, item) => {
        const duplicatedItem = {
          ...item,
          payload: (options == null ? void 0 : options.payload) || item.payload,
          params: (options == null ? void 0 : options.params) || item.params
        };
        return [...siblings.slice(0, siblingIndex), duplicatedItem, ...siblings.slice(siblingIndex)];
      });
    },
    // Set the view for the current pane
    setView: viewId => {
      const restParams = omit(params, "view");
      return setParams(viewId ? {
        ...restParams,
        view: viewId
      } : restParams);
    },
    // Set the parameters for the current pane
    setParams,
    // Set the payload for the current pane
    setPayload,
    // A function that returns a path with the given parameters
    createPathWithParams,
    // Proxied navigation to a given intent. Consider just exposing `router` instead?
    navigateIntent
  }), [flatIndex, groupIndex, siblingIndex, payload, params, routerPaneGroups, handleEditReference, setParams, setPayload, createPathWithParams, navigateIntent, modifyCurrentGroup, lastPane, navigate, expand]);
  return /* @__PURE__ */jsx(PaneRouterContext.Provider, {
    value: ctx,
    children
  });
}
function _calcPaneResize(cache, left, right, deltaX) {
  var _a, _b;
  const sum = {
    flex: cache.left.flex + cache.right.flex,
    width: cache.left.width + cache.right.width
  };
  const leftMinWidth = (_a = left.minWidth) != null ? _a : PANE_DEFAULT_MIN_WIDTH;
  const rightMinWidth = (_b = right.minWidth) != null ? _b : PANE_DEFAULT_MIN_WIDTH;
  const leftMaxWidth = Math.min(left.maxWidth || Infinity, sum.width - rightMinWidth);
  const rightMaxWidth = Math.min(right.maxWidth || Infinity, sum.width - leftMinWidth);
  let minDeltaX = leftMinWidth - cache.left.width;
  const rightMinDeltaX = cache.right.width - rightMaxWidth;
  if (minDeltaX < rightMinDeltaX) {
    minDeltaX = rightMinDeltaX;
  }
  let maxDeltaX = cache.right.width - rightMinWidth;
  const leftMaxDeltaX = leftMaxWidth - cache.left.width;
  if (maxDeltaX > leftMaxDeltaX) {
    maxDeltaX = leftMaxDeltaX;
  }
  const _deltaX = Math.min(Math.max(deltaX, minDeltaX), maxDeltaX);
  const leftW = cache.left.width + _deltaX;
  const rightW = cache.right.width - _deltaX;
  const leftFlex = leftW / sum.width * sum.flex;
  const rightFlex = rightW / sum.width * sum.flex;
  return {
    leftFlex,
    leftW,
    rightFlex,
    rightW
  };
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  while (e !== rootElement) {
    const parentElement = e.parentElement;
    if (!parentElement) return path;
    const children = Array.from(parentElement.childNodes);
    const index = children.indexOf(e);
    path.unshift(index);
    if (parentElement === rootElement) {
      return path;
    }
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  const map = /* @__PURE__ */new WeakMap();
  for (const element of elements) {
    map.set(element, _getDOMPath(rootElement, element));
  }
  const _sortByElementPath = (a, b) => {
    const _a = map.get(a) || EMPTY_PATH;
    const _b = map.get(b) || EMPTY_PATH;
    const len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1;
      const bIndex = _b[i] || -1;
      if (aIndex !== bIndex) {
        return aIndex - bIndex;
      }
    }
    return 0;
  };
  elements.sort(_sortByElementPath);
}
function createPaneLayoutController() {
  const observers = [];
  const elements = [];
  const optionsMap = /* @__PURE__ */new WeakMap();
  const userCollapsedElementSet = /* @__PURE__ */new Set();
  const cache = {};
  let rootElement = null;
  let rootWidth = 0;
  let expandedElement = null;
  let resizeDataMap = /* @__PURE__ */new Map();
  let resizing = false;
  function collapse(element) {
    userCollapsedElementSet.add(element);
    if (expandedElement === element) {
      expandedElement = null;
    }
    _notifyObservers();
  }
  function expand(element) {
    userCollapsedElementSet.delete(element);
    expandedElement = element;
    _notifyObservers();
  }
  function mount(element, options) {
    optionsMap.set(element, {
      ...options,
      original: options
    });
    elements.push(element);
    if (rootElement) {
      _sortElements(rootElement, elements);
    }
    expand(element);
    return () => {
      const idx = elements.indexOf(element);
      if (idx > -1) {
        elements.splice(idx, 1);
      }
      optionsMap.delete(element);
      _notifyObservers();
    };
  }
  function resize(type, leftElement, deltaX) {
    var _a, _b, _c, _d;
    const leftIndex = elements.indexOf(leftElement);
    const leftOptions = optionsMap.get(leftElement);
    if (!leftOptions) return;
    const rightElement = elements[leftIndex + 1];
    const rightOptions = optionsMap.get(rightElement);
    if (!rightOptions) return;
    if (type === "start") {
      resizing = true;
      cache.left = {
        element: leftElement,
        flex: leftOptions.flex || 1,
        width: leftElement.offsetWidth
      };
      cache.right = {
        element: rightElement,
        flex: rightOptions.flex || 1,
        width: rightElement.offsetWidth
      };
      _notifyObservers();
    }
    if (type === "move" && cache.left && cache.right) {
      resizeDataMap = /* @__PURE__ */new Map();
      const {
        leftW,
        rightW,
        leftFlex,
        rightFlex
      } = _calcPaneResize(cache, leftOptions, rightOptions, deltaX);
      resizeDataMap.set(leftElement, {
        flex: leftFlex,
        width: leftW
      });
      resizeDataMap.set(rightElement, {
        flex: rightFlex,
        width: rightW
      });
      _notifyObservers();
    }
    if (type === "end") {
      resizing = false;
      const leftResizeData = resizeDataMap.get(leftElement);
      const rightResizeData = resizeDataMap.get(rightElement);
      optionsMap.set(leftElement, {
        ...leftOptions,
        currentMinWidth: 0,
        currentMaxWidth: (_a = leftOptions.maxWidth) != null ? _a : Infinity,
        flex: (_b = leftResizeData == null ? void 0 : leftResizeData.flex) != null ? _b : leftOptions.flex
      });
      optionsMap.set(rightElement, {
        ...rightOptions,
        currentMinWidth: 0,
        currentMaxWidth: (_c = leftOptions.maxWidth) != null ? _c : Infinity,
        flex: (_d = rightResizeData == null ? void 0 : rightResizeData.flex) != null ? _d : rightOptions.flex
      });
      resizeDataMap = /* @__PURE__ */new Map();
      delete cache.left;
      delete cache.right;
      _notifyObservers();
    }
  }
  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }
  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth;
    _notifyObservers();
  }
  function subscribe(observer) {
    observers.push(observer);
    return () => {
      const idx = observers.push(observer);
      if (idx > -1) {
        observers.splice(idx, 1);
      }
    };
  }
  return {
    collapse,
    expand,
    mount,
    resize,
    setRootElement,
    setRootWidth,
    subscribe
  };
  function _notifyObservers() {
    var _a, _b, _c, _d;
    if (!rootWidth) return;
    const _elements = [];
    for (const element of elements) {
      if (element !== expandedElement) {
        _elements.unshift(element);
      }
    }
    if (expandedElement) {
      _elements.unshift(expandedElement);
    }
    const dataMap = /* @__PURE__ */new WeakMap();
    const len = _elements.length;
    const lastElement = _elements[0];
    const collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;
    for (const element of _elements) {
      const options = optionsMap.get(element);
      if (!options) {
        continue;
      }
      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH;
      const isLast = element === lastElement;
      const userCollapsed = userCollapsedElementSet.has(element);
      const sizeCollapsed = minWidth > remaingWidth;
      const collapsed = isLast ? false : userCollapsed || sizeCollapsed;
      const resizeData = resizeDataMap.get(element);
      dataMap.set(element, {
        element,
        collapsed,
        currentMinWidth: (_a = resizeData == null ? void 0 : resizeData.width) != null ? _a : options.currentMinWidth,
        currentMaxWidth: (_b = resizeData == null ? void 0 : resizeData.width) != null ? _b : options.currentMaxWidth,
        flex: (_d = (_c = resizeData == null ? void 0 : resizeData.flex) != null ? _c : options.flex) != null ? _d : 1
      });
      if (collapsed) {
        remaingWidth -= PANE_COLLAPSED_WIDTH;
      } else {
        remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
      }
    }
    const panes = [];
    for (const element of elements) {
      const data = dataMap.get(element);
      if (data) panes.push(data);
    }
    for (const observer of observers) {
      observer({
        expandedElement: expandedElement || elements[elements.length - 1] || null,
        panes,
        resizing
      });
    }
  }
}
function PaneLayout(props) {
  const {
    children,
    minWidth,
    onCollapse,
    onExpand,
    ...restProps
  } = props;
  const controller = useMemo(() => createPaneLayoutController(), []);
  const [rootElement, setRootElement] = useState(null);
  const rootRect = useElementRect(rootElement);
  const width = (rootRect == null ? void 0 : rootRect.width) || 0;
  const collapsed = width === void 0 || !minWidth ? void 0 : width < minWidth;
  const [state, setState] = useState({
    expandedElement: null,
    panes: [],
    resizing: false
  });
  useEffect(() => controller.setRootElement(rootElement), [controller, rootElement]);
  useEffect(() => controller.setRootWidth(width), [controller, width]);
  useEffect(() => controller.subscribe(setState), [controller]);
  useEffect(() => {
    if (collapsed === void 0) return;
    if (collapsed && onCollapse) onCollapse();
    if (!collapsed && onExpand) onExpand();
  }, [collapsed, onCollapse, onExpand]);
  const paneLayout = useMemo(() => ({
    collapse: controller.collapse,
    collapsed,
    expand: controller.expand,
    expandedElement: state.expandedElement,
    mount: controller.mount,
    panes: state.panes,
    resize: controller.resize,
    resizing: state.resizing
  }), [collapsed, controller, state.expandedElement, state.panes, state.resizing]);
  return /* @__PURE__ */jsx(PaneLayoutContext.Provider, {
    value: paneLayout,
    children: /* @__PURE__ */jsx(Root$4, {
      "data-ui": "PaneLayout",
      ...restProps,
      "data-collapsed": collapsed ? "" : void 0,
      "data-resizing": state.resizing ? "" : void 0,
      "data-mounted": width ? "" : void 0,
      ref: setRootElement,
      children
    })
  });
}
function DocumentInspectorPanel(props) {
  const {
    documentId,
    documentType,
    flex
  } = props;
  const {
    collapsed
  } = usePane();
  const {
    closeInspector,
    inspector
  } = useDocumentPane();
  const {
    features
  } = useDeskTool();
  const handleClose = useCallback(() => {
    if (inspector) closeInspector(inspector.name);
  }, [closeInspector, inspector]);
  if (collapsed || !inspector) return null;
  const element = createElement(inspector.component, {
    onClose: handleClose,
    documentId,
    documentType
  });
  if (features.resizablePanes) {
    return /* @__PURE__ */jsx(Resizable, {
      as: "aside",
      "data-ui": "DocumentInspectorPanel",
      flex,
      maxWidth: DOCUMENT_INSPECTOR_MAX_WIDTH,
      minWidth: DOCUMENT_INSPECTOR_MIN_WIDTH,
      children: element
    });
  }
  return /* @__PURE__ */jsx(Box, {
    as: "aside",
    "data-ui": "DocumentInspectorPanel",
    flex,
    children: element
  });
}
var __defProp$c = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp$c(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class PaneResolutionError extends Error {
  constructor(_ref2) {
    let {
      message,
      context,
      helpId,
      cause
    } = _ref2;
    super(message);
    __publicField(this, "cause");
    __publicField(this, "context");
    __publicField(this, "helpId");
    this.context = context;
    this.helpId = helpId;
    this.cause = cause;
  }
}
const randomIdCache = /* @__PURE__ */new WeakMap();
function assignId(obj) {
  const cachedValue = randomIdCache.get(obj);
  if (cachedValue) return cachedValue;
  const id = nanoid();
  randomIdCache.set(obj, id);
  return id;
}
const bindCache = /* @__PURE__ */new WeakMap();
function memoBind(obj, methodKey) {
  const boundMethods = bindCache.get(obj) || /* @__PURE__ */new Map();
  if (boundMethods) {
    const bound2 = boundMethods.get(methodKey);
    if (bound2) return bound2;
  }
  const method = obj[methodKey];
  if (typeof method !== "function") {
    throw new Error("Expected property `".concat(methodKey, "` to be a function but got ").concat(typeof method, " instead."));
  }
  const bound = method.bind(obj);
  boundMethods.set(methodKey, bound);
  bindCache.set(obj, boundMethods);
  return bound;
}
const isPromise = thing => {
  return !!thing && typeof (thing == null ? void 0 : thing.then) === "function";
};
const isSerializable = thing => {
  if (!isRecord(thing)) return false;
  return typeof thing.serialize === "function";
};
const rethrowWithPaneResolutionErrors = next => (unresolvedPane, context, flatIndex) => {
  try {
    return next(unresolvedPane, context, flatIndex);
  } catch (e) {
    if (e instanceof PaneResolutionError) {
      throw e;
    }
    throw new PaneResolutionError({
      message: typeof (e == null ? void 0 : e.message) === "string" ? e.message : "",
      context,
      cause: e
    });
  }
};
const wrapWithPublishReplay = next => function () {
  return next(...arguments).pipe(
  // need to add publishReplay + refCount to ensure new subscribers always
  // get an emission. without this, memoized observables may get stuck
  // waiting for their first emissions resulting in a loading pane
  publishReplay(1), refCount());
};
function createPaneResolver(middleware) {
  const resolvePane = rethrowWithPaneResolutionErrors(wrapWithPublishReplay(middleware((unresolvedPane, context, flatIndex) => {
    if (!unresolvedPane) {
      throw new PaneResolutionError({
        message: "Pane returned no child",
        context,
        helpId: "structure-item-returned-no-child"
      });
    }
    if (isPromise(unresolvedPane) || isObservable(unresolvedPane)) {
      return from(unresolvedPane).pipe(switchMap(result => resolvePane(result, context, flatIndex)));
    }
    if (isSerializable(unresolvedPane)) {
      return resolvePane(unresolvedPane.serialize(context), context, flatIndex);
    }
    if (typeof unresolvedPane === "function") {
      return resolvePane(unresolvedPane(context.id, context), context, flatIndex);
    }
    return of(unresolvedPane);
  })));
  return resolvePane;
}
async function resolveIntent(options) {
  const resolvedPaneCache = /* @__PURE__ */new Map();
  const memoize = nextFn => (unresolvedPane, context, flatIndex) => {
    const key = unresolvedPane && "".concat(assignId(unresolvedPane), "-").concat(context.path.join("__"));
    const cachedResolvedPane = key && resolvedPaneCache.get(key);
    if (cachedResolvedPane) return cachedResolvedPane;
    const result = nextFn(unresolvedPane, context, flatIndex);
    if (key) resolvedPaneCache.set(key, result);
    return result;
  };
  const resolvePane = createPaneResolver(memoize);
  const fallbackEditorPanes = [[{
    id: "__edit__".concat(options.params.id),
    params: {
      ...omit(options.params, ["id"]),
      type: options.params.type
    },
    payload: options.payload
  }]];
  async function traverse(_ref3) {
    let {
      currentId,
      flatIndex,
      intent,
      params,
      parent,
      path,
      payload,
      unresolvedPane,
      levelIndex,
      structureContext
    } = _ref3;
    var _a;
    if (!unresolvedPane) return [];
    const {
      id: targetId,
      type: schemaTypeName,
      ...otherParams
    } = params;
    const context = {
      id: currentId,
      splitIndex: 0,
      parent,
      path,
      index: flatIndex,
      params: {},
      payload: void 0,
      structureContext
    };
    const resolvedPane = await firstValueFrom(resolvePane(unresolvedPane, context, flatIndex));
    if (resolvedPane.type === "document" && resolvedPane.id === targetId) {
      return [{
        panes: [...path.slice(0, path.length - 1).map(i => [{
          id: i
        }]), [{
          id: targetId,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }
    if (
    // if the resolve pane's `canHandleIntent` returns true, then resolve
    ((_a = resolvedPane.canHandleIntent) == null ? void 0 : _a.call(resolvedPane, intent, params, {
      pane: resolvedPane,
      index: flatIndex
    })) ||
    // if the pane's `canHandleIntent` did not return true, then match against
    // this default case. we will resolve the intent if:
    resolvedPane.type === "documentList" &&
    // 1. the schema type matches (this required for the document to render)
    resolvedPane.schemaTypeName === schemaTypeName &&
    // 2. the filter is the default filter.
    //
    // NOTE: this case is to prevent false positive matches where the user
    // has configured a more specific filter for a particular type. In that
    // case, the user can implement their own `canHandleIntent` function
    resolvedPane.options.filter === "_type == $type") {
      return [{
        panes: [
        // map the current path to router panes
        ...path.map(id => [{
          id
        }]),
        // then augment with the intents IDs and params
        [{
          id: params.id,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }
    if (resolvedPane.type === "list" && resolvedPane.child && resolvedPane.items) {
      return (await Promise.all(resolvedPane.items.map((item, nextLevelIndex) => {
        if (item.type === "divider") return Promise.resolve([]);
        return traverse({
          currentId: item._id || item.id,
          flatIndex: flatIndex + 1,
          intent,
          params,
          parent: resolvedPane,
          path: [...path, item.id],
          payload,
          unresolvedPane: typeof resolvedPane.child === "function" ? memoBind(resolvedPane, "child") : resolvedPane.child,
          levelIndex: nextLevelIndex,
          structureContext
        });
      }))).flat();
    }
    return [];
  }
  const matchingPanes = await traverse({
    currentId: "root",
    flatIndex: 0,
    levelIndex: 0,
    intent: options.intent,
    params: options.params,
    parent: null,
    path: [],
    payload: options.payload,
    unresolvedPane: options.rootPaneNode,
    structureContext: options.structureContext
  });
  const closestPaneToRoot = matchingPanes.sort((a, b) => {
    if (a.depthIndex === b.depthIndex) return a.levelIndex - b.levelIndex;
    return a.depthIndex - b.depthIndex;
  })[0];
  if (closestPaneToRoot) {
    return closestPaneToRoot.panes;
  }
  return fallbackEditorPanes;
}
const fallbackEditorChild = (nodeId, context) => {
  const id = nodeId.replace(/^__edit__/, "");
  const {
    params,
    payload,
    structureContext: {
      resolveDocumentNode
    }
  } = context;
  const {
    type,
    template
  } = params;
  if (!type) {
    throw new Error("Document type for document with ID ".concat(id, " was not provided in the router params."));
  }
  let defaultDocumentBuilder = resolveDocumentNode({
    schemaType: type,
    documentId: id
  }).id("editor");
  if (template) {
    defaultDocumentBuilder = defaultDocumentBuilder.initialValueTemplate(template, payload);
  }
  return defaultDocumentBuilder.serialize();
};
function hashContext(context) {
  var _a, _b;
  return "contextHash(".concat(JSON.stringify({
    id: context.id,
    parentId: parent && assignId(parent),
    path: context.path,
    index: context.index,
    splitIndex: context.splitIndex,
    serializeOptionsIndex: (_a = context.serializeOptions) == null ? void 0 : _a.index,
    serializeOptionsPath: (_b = context.serializeOptions) == null ? void 0 : _b.path
  }), ")");
}
const hashResolvedPaneMeta = meta => {
  const normalized = {
    type: meta.type,
    id: meta.routerPaneSibling.id,
    params: meta.routerPaneSibling.params || {},
    payload: meta.routerPaneSibling.payload || null,
    flatIndex: meta.flatIndex,
    groupIndex: meta.groupIndex,
    siblingIndex: meta.siblingIndex,
    path: meta.path,
    paneNode: meta.type === "resolvedMeta" ? assignId(meta.paneNode) : null
  };
  return "metaHash(".concat(JSON.stringify(normalized), ")");
};
function resolvePaneTree(_ref4) {
  let {
    unresolvedPane,
    flattenedRouterPanes,
    parent: parent2,
    path,
    resolvePane,
    structureContext
  } = _ref4;
  const [current, ...rest] = flattenedRouterPanes;
  const next = rest[0];
  const context = {
    id: current.routerPaneSibling.id,
    splitIndex: current.siblingIndex,
    parent: parent2,
    path: [...path, current.routerPaneSibling.id],
    index: current.flatIndex,
    params: current.routerPaneSibling.params || {},
    payload: current.routerPaneSibling.payload,
    structureContext
  };
  try {
    return resolvePane(unresolvedPane, context, current.flatIndex).pipe(
    // this switch map receives a resolved pane
    switchMap(paneNode => {
      const resolvedPaneMeta = {
        type: "resolvedMeta",
        ...current,
        paneNode,
        path: context.path
      };
      const loadingPanes = rest.map((i, restIndex) => {
        const loadingPanePath = [...context.path, ...rest.slice(restIndex).map((_, currentIndex) => "[".concat(i.flatIndex + currentIndex, "]"))];
        const loadingPane = {
          type: "loading",
          path: loadingPanePath,
          paneNode: null,
          ...i
        };
        return loadingPane;
      });
      if (!rest.length) {
        return of([resolvedPaneMeta]);
      }
      let nextStream;
      if (
      // the fallback editor case
      next == null ? void 0 : next.routerPaneSibling.id.startsWith("__edit__")) {
        nextStream = resolvePaneTree({
          unresolvedPane: fallbackEditorChild,
          flattenedRouterPanes: rest,
          parent: parent2,
          path: context.path,
          resolvePane,
          structureContext
        });
      } else if (current.groupIndex === (next == null ? void 0 : next.groupIndex)) {
        nextStream = resolvePaneTree({
          unresolvedPane,
          flattenedRouterPanes: rest,
          parent: parent2,
          path,
          resolvePane,
          structureContext
        });
      } else {
        nextStream = resolvePaneTree({
          unresolvedPane: typeof paneNode.child === "function" ? memoBind(paneNode, "child") : paneNode.child,
          flattenedRouterPanes: rest,
          parent: paneNode,
          path: context.path,
          resolvePane,
          structureContext
        });
      }
      return concat(
      // we emit the loading panes first in a concat (this emits immediately)
      of([resolvedPaneMeta, ...loadingPanes]),
      // then whenever the next stream is done, the results will be combined.
      nextStream.pipe(map(nextResolvedPanes => [resolvedPaneMeta, ...nextResolvedPanes])));
    }));
  } catch (e) {
    if (e instanceof PaneResolutionError) {
      if (e.context) {
        console.warn("Pane resolution error at index ".concat(e.context.index).concat(e.context.splitIndex > 0 ? " for split pane index ".concat(e.context.splitIndex) : "", ": ").concat(e.message).concat(e.helpId ? " - see ".concat(generateHelpUrl(e.helpId)) : ""), e);
      }
      if (e.helpId === "structure-item-returned-no-child") {
        return of([]);
      }
    }
    throw e;
  }
}
function createResolvedPaneNodeStream(_ref5) {
  let {
    routerPanesStream,
    rootPaneNode,
    initialCacheState = {
      cacheKeysByFlatIndex: [],
      flattenedRouterPanes: [],
      resolvedPaneCache: /* @__PURE__ */new Map(),
      resolvePane: () => NEVER
    },
    structureContext
  } = _ref5;
  const resolvedPanes$ = routerPanesStream.pipe(
  // add in implicit "root" router pane
  map(rawRouterPanes => [[{
    id: "root"
  }], ...rawRouterPanes]),
  // create flattened router panes
  map(routerPanes => {
    const flattenedRouterPanes = routerPanes.flatMap((routerPaneGroup, groupIndex) => routerPaneGroup.map((routerPaneSibling, siblingIndex) => ({
      routerPaneSibling,
      groupIndex,
      siblingIndex
    }))).map((i, index) => ({
      ...i,
      flatIndex: index
    }));
    return flattenedRouterPanes;
  }),
  // calculate a "diffIndex" used for clearing the memo cache
  startWith([]), pairwise(), map(_ref6 => {
    let [prev, curr] = _ref6;
    for (let i = 0; i < curr.length; i++) {
      const prevValue = prev[i];
      const currValue = curr[i];
      if (!isEqual(prevValue, currValue)) {
        return {
          flattenedRouterPanes: curr,
          diffIndex: i
        };
      }
    }
    return {
      flattenedRouterPanes: curr,
      diffIndex: curr.length
    };
  }),
  // create the memoized `resolvePane` function and manage the memo cache
  scan((acc, next) => {
    const {
      cacheKeysByFlatIndex,
      resolvedPaneCache
    } = acc;
    const {
      flattenedRouterPanes,
      diffIndex
    } = next;
    const beforeDiffIndex = cacheKeysByFlatIndex.slice(0, diffIndex + 1);
    const afterDiffIndex = cacheKeysByFlatIndex.slice(diffIndex + 1);
    const keysToKeep = new Set(beforeDiffIndex.flatMap(keySet => Array.from(keySet)));
    const keysToDelete = afterDiffIndex.flatMap(keySet => Array.from(keySet)).filter(key => !keysToKeep.has(key));
    for (const key of keysToDelete) {
      resolvedPaneCache.delete(key);
    }
    const memoize = nextFn => (unresolvedPane, context, flatIndex) => {
      const key = unresolvedPane && "".concat(assignId(unresolvedPane), "-").concat(hashContext(context));
      const cachedResolvedPane = key && resolvedPaneCache.get(key);
      if (cachedResolvedPane) return cachedResolvedPane;
      const result = nextFn(unresolvedPane, context, flatIndex);
      if (!key) return result;
      const cacheKeySet = cacheKeysByFlatIndex[flatIndex] || /* @__PURE__ */new Set();
      cacheKeySet.add(key);
      cacheKeysByFlatIndex[flatIndex] = cacheKeySet;
      resolvedPaneCache.set(key, result);
      return result;
    };
    return {
      flattenedRouterPanes,
      cacheKeysByFlatIndex,
      resolvedPaneCache,
      resolvePane: createPaneResolver(memoize)
    };
  }, initialCacheState),
  // run the memoized, recursive resolving
  switchMap(_ref7 => {
    let {
      flattenedRouterPanes,
      resolvePane
    } = _ref7;
    return resolvePaneTree({
      unresolvedPane: rootPaneNode,
      flattenedRouterPanes,
      parent: null,
      path: [],
      resolvePane,
      structureContext
    });
  }));
  return resolvedPanes$.pipe(
  // this diffs the previous emission with the current one. if there is a new
  // loading pane at the same position where a previous pane already had a
  // resolved value (looking at the IDs to compare), then return the previous
  // pane instead of the loading pane
  scan((prev, next) => next.map((nextPane, index) => {
    const prevPane = prev[index];
    if (!prevPane) return nextPane;
    if (nextPane.type !== "loading") return nextPane;
    if (prevPane.routerPaneSibling.id === nextPane.routerPaneSibling.id) {
      return prevPane;
    }
    return nextPane;
  }), []),
  // this prevents duplicate emissions
  distinctUntilChanged((prev, next) => {
    if (prev.length !== next.length) return false;
    for (let i = 0; i < next.length; i++) {
      const prevValue = prev[i];
      const nextValue = next[i];
      if (hashResolvedPaneMeta(prevValue) !== hashResolvedPaneMeta(nextValue)) {
        return false;
      }
    }
    return true;
  }));
}
function useRouterPanesStream() {
  const routerStateSubject = useMemo(() => new ReplaySubject(1), []);
  const routerPanes$ = useMemo(() => routerStateSubject.asObservable().pipe(map(_routerState => (_routerState == null ? void 0 : _routerState.panes) || [])), [routerStateSubject]);
  const {
    state: routerState
  } = useRouter();
  useEffect(() => {
    routerStateSubject.next(routerState);
  }, [routerState, routerStateSubject]);
  return routerPanes$;
}
function useResolvedPanes() {
  const [error, setError] = useState();
  if (error) throw error;
  const {
    structureContext,
    rootPaneNode
  } = useDeskTool();
  const [data, setData] = useState({
    paneDataItems: [],
    resolvedPanes: [],
    routerPanes: []
  });
  const routerPanesStream = useRouterPanesStream();
  useEffect(() => {
    const resolvedPanes$ = createResolvedPaneNodeStream({
      rootPaneNode,
      routerPanesStream,
      structureContext
    }).pipe(map(resolvedPanes => {
      const routerPanes = resolvedPanes.reduce((acc, next) => {
        const currentGroup = acc[next.groupIndex] || [];
        currentGroup[next.siblingIndex] = next.routerPaneSibling;
        acc[next.groupIndex] = currentGroup;
        return acc;
      }, []);
      const groupsLen = routerPanes.length;
      const paneDataItems = resolvedPanes.map(pane => {
        var _a;
        const {
          groupIndex,
          flatIndex,
          siblingIndex,
          routerPaneSibling,
          path
        } = pane;
        const itemId = routerPaneSibling.id;
        const nextGroup = routerPanes[groupIndex + 1];
        const paneDataItem = {
          active: groupIndex === groupsLen - 2,
          childItemId: (_a = nextGroup == null ? void 0 : nextGroup[0].id) != null ? _a : null,
          index: flatIndex,
          itemId: routerPaneSibling.id,
          groupIndex,
          key: "".concat(pane.type === "loading" ? "unknown" : pane.paneNode.id, "-").concat(itemId, "-").concat(siblingIndex),
          pane: pane.type === "loading" ? LOADING_PANE : pane.paneNode,
          params: routerPaneSibling.params || {},
          path: path.join(";"),
          payload: routerPaneSibling.payload,
          selected: flatIndex === resolvedPanes.length - 1,
          siblingIndex
        };
        return paneDataItem;
      });
      return {
        paneDataItems,
        routerPanes,
        resolvedPanes: paneDataItems.map(pane => pane.pane)
      };
    }));
    const subscription = resolvedPanes$.subscribe({
      next: result => setData(result),
      error: e => setError(e)
    });
    return () => subscription.unsubscribe();
  }, [rootPaneNode, routerPanesStream, structureContext]);
  return data;
}
async function ensureDocumentIdAndType(documentStore, id, type) {
  if (id && type) return {
    id,
    type
  };
  if (!id && type) return {
    id: uuid(),
    type
  };
  if (id && !type) {
    const resolvedType = await firstValueFrom(documentStore.resolveTypeForDocument(id));
    return {
      id,
      type: resolvedType
    };
  }
  throw new PaneResolutionError({
    message: "Neither document `id` or `type` was provided when trying to resolve intent."
  });
}
const EMPTY_RECORD = {};
const IntentResolver = memo(function IntentResolver2() {
  const {
    navigate
  } = useRouter();
  const maybeIntent = useRouterState(useCallback(routerState => {
    const intentName = typeof routerState.intent === "string" ? routerState.intent : void 0;
    return intentName ? {
      intent: intentName,
      params: isRecord(routerState.params) ? routerState.params : EMPTY_RECORD,
      payload: routerState.payload
    } : void 0;
  }, []));
  const {
    rootPaneNode,
    structureContext
  } = useDeskTool();
  const documentStore = useDocumentStore();
  const [error, setError] = useState(null);
  if (error) throw error;
  useEffect(() => {
    if (maybeIntent) {
      const {
        intent,
        params,
        payload
      } = maybeIntent;
      let cancelled = false;
      async function effect() {
        const {
          id,
          type
        } = await ensureDocumentIdAndType(documentStore, typeof params.id === "string" ? params.id : void 0, typeof params.type === "string" ? params.type : void 0);
        if (cancelled) return;
        const panes = await resolveIntent({
          intent,
          params: {
            ...params,
            id,
            type
          },
          payload,
          rootPaneNode,
          structureContext
        });
        if (cancelled) return;
        navigate({
          panes
        }, {
          replace: true
        });
      }
      effect().catch(setError);
      return () => {
        cancelled = true;
      };
    }
  }, [documentStore, maybeIntent, navigate, rootPaneNode, structureContext]);
  return null;
});
var __freeze$b = Object.freeze;
var __defProp$b = Object.defineProperty;
var __template$b = (cooked, raw) => __freeze$b(__defProp$b(cooked, "raw", {
  value: __freeze$b(raw || cooked.slice())
}));
var _a$b;
const PathSegment = styled.span(_a$b || (_a$b = __template$b(["\n  &:not(:last-child)::after {\n    content: ' \u279D ';\n    opacity: 0.5;\n  }\n"])));
function formatStack(stack) {
  return stack.replace(/\(\.\.\.\)\./g, "(...)\n  .").replace(/__WEBPACK_IMPORTED_MODULE_\d+_+/g, "").replace(/___default\./g, ".").replace(new RegExp(" \\(https?:\\/\\/".concat(window.location.host), "g"), " (");
}
function StructureError(_ref8) {
  let {
    error
  } = _ref8;
  if (!(error instanceof PaneResolutionError)) {
    throw error;
  }
  const {
    cause
  } = error;
  const stack = (cause == null ? void 0 : cause.stack) || error.stack;
  const showStack = stack && !(cause instanceof SerializeError) && !error.message.includes("Module build failed:");
  const path = cause instanceof SerializeError ? cause.path : [];
  const helpId = cause instanceof SerializeError && cause.helpId || error.helpId;
  const handleReload = useCallback(() => {
    window.location.reload();
  }, []);
  return /* @__PURE__ */jsx(Card, {
    height: "fill",
    overflow: "auto",
    padding: 4,
    sizing: "border",
    tone: "critical",
    children: /* @__PURE__ */jsxs(Container, {
      children: [/* @__PURE__ */jsx(Heading, {
        as: "h2",
        children: "Encountered an error while reading structure"
      }), /* @__PURE__ */jsxs(Card, {
        marginTop: 4,
        padding: 4,
        radius: 2,
        overflow: "auto",
        shadow: 1,
        tone: "inherit",
        children: [path.length > 0 && /* @__PURE__ */jsxs(Stack, {
          space: 2,
          children: [/* @__PURE__ */jsx(Label, {
            children: "Structure path"
          }), /* @__PURE__ */jsx(Code, {
            children: path.slice(1).map((segment, i) =>
            // eslint-disable-next-line react/no-array-index-key
            /* @__PURE__ */
            jsx(PathSegment, {
              children: segment
            }, "".concat(segment, "-").concat(i)))
          })]
        }), /* @__PURE__ */jsxs(Stack, {
          marginTop: 4,
          space: 2,
          children: [/* @__PURE__ */jsx(Label, {
            children: "Error"
          }), /* @__PURE__ */jsx(Code, {
            children: showStack ? formatStack(stack) : error.message
          })]
        }), helpId && /* @__PURE__ */jsx(Box, {
          marginTop: 4,
          children: /* @__PURE__ */jsx(Text, {
            children: /* @__PURE__ */jsx("a", {
              href: generateHelpUrl(helpId),
              rel: "noopener noreferrer",
              target: "_blank",
              children: "View documentation"
            })
          })
        }), /* @__PURE__ */jsx(Box, {
          marginTop: 4,
          children: /* @__PURE__ */jsx(Button, {
            text: "Reload",
            icon: SyncIcon,
            tone: "primary",
            onClick: handleReload
          })
        })]
      })]
    })
  });
}
function UnknownPane(props) {
  const {
    isSelected,
    pane,
    paneKey
  } = props;
  const type = isRecord(pane) && pane.type || null;
  return /* @__PURE__ */jsxs(Pane, {
    id: paneKey,
    selected: isSelected,
    children: [/* @__PURE__ */jsx(PaneHeader, {
      title: "Unknown pane type"
    }), /* @__PURE__ */jsx(PaneContent, {
      children: /* @__PURE__ */jsx(Box, {
        padding: 4,
        children: typeof type === "string" ? /* @__PURE__ */jsxs(Text, {
          as: "p",
          muted: true,
          children: ["Structure item of type ", /* @__PURE__ */jsx("code", {
            children: type
          }), " is not a known entity."]
        }) : /* @__PURE__ */jsxs(Text, {
          as: "p",
          muted: true,
          children: ["Structure item is missing required ", /* @__PURE__ */jsx("code", {
            children: "type"
          }), " property."]
        })
      })
    })]
  });
}
function getWaitMessages(path) {
  const thresholds = [{
    ms: 300,
    message: "Loading\u2026"
  }, {
    ms: 5e3,
    message: "Still loading\u2026"
  }];
  if (isDev) {
    const message = ["Check console for errors?", "Is your observable/promise resolving?", path.length > 0 ? "Structure path: ".concat(path.join(" \u279D ")) : ""];
    thresholds.push({
      ms: 1e4,
      message: message.join("\n")
    });
  }
  const src = of(null);
  return merge(...thresholds.map(_ref9 => {
    let {
      ms,
      message
    } = _ref9;
    return src.pipe(mapTo(message), delay(ms));
  }));
}
var __freeze$a = Object.freeze;
var __defProp$a = Object.defineProperty;
var __template$a = (cooked, raw) => __freeze$a(__defProp$a(cooked, "raw", {
  value: __freeze$a(raw || cooked.slice())
}));
var _a$a;
const DEFAULT_MESSAGE = "Loading\u2026";
const Content = styled(Flex)(_a$a || (_a$a = __template$a(["\n  opacity: 0;\n  transition: opacity 200ms;\n\n  &[data-mounted] {\n    opacity: 1;\n  }\n"])));
const LoadingPane = memo(props => {
  const {
    delay = 300,
    flex,
    message: messageProp = getWaitMessages,
    minWidth,
    paneKey,
    path,
    selected,
    title,
    tone
  } = props;
  const resolvedMessage = useMemo(() => {
    if (typeof messageProp === "function") {
      return messageProp(path ? path.split(";") : []);
    }
    return messageProp;
  }, [messageProp, path]);
  const [currentMessage, setCurrentMessage] = useState(() => {
    if (typeof resolvedMessage === "string") return resolvedMessage;
    return DEFAULT_MESSAGE;
  });
  useEffect(() => {
    if (typeof resolvedMessage !== "object") return void 0;
    if (typeof resolvedMessage.subscribe === "function") return void 0;
    const sub = resolvedMessage.subscribe(setCurrentMessage);
    return () => sub.unsubscribe();
  }, [resolvedMessage]);
  const [contentElement, setContentElement] = useState(null);
  const [mounted, setMounted] = useState(false);
  useEffect(() => {
    if (!contentElement) return void 0;
    return _raf2(() => setMounted(true));
  }, [contentElement]);
  const content = /* @__PURE__ */jsxs(Content, {
    align: "center",
    "data-mounted": mounted ? "" : void 0,
    direction: "column",
    height: "fill",
    justify: "center",
    ref: setContentElement,
    children: [/* @__PURE__ */jsx(Spinner, {
      muted: true
    }), (title || currentMessage) && /* @__PURE__ */jsx(Box, {
      marginTop: 3,
      children: /* @__PURE__ */jsx(Text, {
        align: "center",
        muted: true,
        size: 1,
        children: title || currentMessage
      })
    })]
  });
  return /* @__PURE__ */jsx(Pane, {
    flex,
    id: paneKey,
    minWidth,
    selected,
    tone,
    children: /* @__PURE__ */jsx(PaneContent, {
      children: content
    })
  });
});
LoadingPane.displayName = "LoadingPane";
const paneMap = {
  component: lazy(() => import('./index-9cbc91eb.js')),
  document: lazy(() => import('./index-3e9457ce.js')),
  documentList: lazy(() => import('./index-9b184a3d.js')),
  list: lazy(() => import('./index-f4b3c5f5.js'))
};
const DeskToolPane = memo(function DeskToolPane2(props) {
  const {
    active,
    childItemId,
    groupIndex,
    index,
    itemId,
    pane,
    paneKey,
    params,
    payload,
    path,
    selected,
    siblingIndex
  } = props;
  const PaneComponent = paneMap[pane.type] || UnknownPane;
  return /* @__PURE__ */jsx(PaneRouterProvider, {
    flatIndex: index,
    index: groupIndex,
    params,
    payload,
    siblingIndex,
    children: /* @__PURE__ */jsx(Suspense, {
      fallback: /* @__PURE__ */jsx(LoadingPane, {
        paneKey,
        path,
        selected
      }),
      children: /* @__PURE__ */jsx(PaneComponent, {
        childItemId: childItemId || "",
        index,
        itemId,
        isActive: active,
        isSelected: selected,
        paneKey,
        pane
      })
    })
  });
}, (_ref10, _ref11) => {
  let {
    params: prevParams = {},
    payload: prevPayload = null,
    ...prev
  } = _ref10;
  let {
    params: nextParams = {},
    payload: nextPayload = null,
    ...next
  } = _ref11;
  if (!isEqual(prevParams, nextParams)) return false;
  if (!isEqual(prevPayload, nextPayload)) return false;
  const keys = /* @__PURE__ */new Set([...Object.keys(prev), ...Object.keys(next)]);
  for (const key of keys) {
    if (prev[key] !== next[key]) return false;
  }
  return true;
});
function ErrorPane(props) {
  const {
    children,
    currentMinWidth,
    flex,
    minWidth,
    paneKey,
    title = "Error",
    tone = "critical"
  } = props;
  return /* @__PURE__ */jsxs(Pane, {
    currentMinWidth,
    flex,
    id: paneKey,
    minWidth,
    tone,
    children: [/* @__PURE__ */jsx(PaneHeader, {
      title
    }), /* @__PURE__ */jsx(PaneContent, {
      overflow: "auto",
      children: /* @__PURE__ */jsx(Box, {
        paddingX: 4,
        paddingY: 5,
        children
      })
    })]
  });
}
function getOpErrorTitle(op) {
  if (op === "delete") {
    return "An error occurred while attempting to delete this document.\n      This usually means that there are other documents that refers to it.";
  }
  if (op === "unpublish") {
    return "An error occurred while attempting to unpublish this document.\n      This usually means that there are other documents that refers to it.";
  }
  return "An error occurred during ".concat(op);
}
function getOpSuccessTitle(op) {
  if (op === "publish") {
    return "The document was published";
  }
  if (op === "unpublish") {
    return "The document was unpublished. A draft has been created from the latest published version.";
  }
  if (op === "discardChanges") {
    return "All changes since last publish has now been discarded. The discarded draft can still be recovered from history";
  }
  if (op === "delete") {
    return "The document was successfully deleted";
  }
  return "Successfully performed ".concat(op, " on document");
}
const IGNORE_OPS = ["patch", "commit"];
const DocumentOperationResults = memo(function DocumentOperationResults2() {
  const {
    push: pushToast
  } = useToast();
  const {
    documentId,
    documentType
  } = useDocumentPane();
  const event = useDocumentOperationEvent(documentId, documentType);
  const prevEvent = useRef(event);
  const paneRouter = usePaneRouter();
  useEffect(() => {
    if (!event || event === prevEvent.current) return;
    let cleanupId;
    if (event.type === "error") {
      pushToast({
        closable: true,
        duration: 3e4,
        // 30s
        status: "error",
        title: getOpErrorTitle(event.op),
        description: /* @__PURE__ */jsxs("details", {
          children: [/* @__PURE__ */jsx("summary", {
            children: "Details"
          }), event.error.message]
        })
      });
    }
    if (event.type === "success" && !IGNORE_OPS.includes(event.op)) {
      pushToast({
        closable: true,
        status: "success",
        title: getOpSuccessTitle(event.op)
      });
    }
    if (event.type === "success" && event.op === "delete") {
      cleanupId = setTimeout(() => paneRouter.closeCurrentAndAfter(), 0);
    }
    prevEvent.current = event;
    return () => clearTimeout(cleanupId);
  }, [event, paneRouter, pushToast]);
  return null;
});
function useDeskToolSetting(namespace, key, defaultValue) {
  const settingsStore = useSettingsStore();
  const [value, setValue] = useState(defaultValue);
  const deskToolSettings = useMemo(() => settingsStore.forNamespace("desk-tool"), [settingsStore]);
  const settings = useMemo(() => {
    if (namespace) {
      return deskToolSettings.forNamespace(namespace).forKey(key);
    }
    return deskToolSettings.forKey(key);
  }, [deskToolSettings, namespace, key]);
  useEffect(() => {
    const sub = settings.listen(defaultValue).subscribe({
      next: setValue
    });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [defaultValue, key, namespace, settings]);
  const set = useCallback(newValue => {
    setValue(newValue);
    settings.set(newValue);
  }, [settings]);
  return useMemo(() => [value, set], [set, value]);
}
const VIEW_MODE_PARSED = {
  id: "parsed",
  title: "Parsed"
};
const VIEW_MODE_RAW = {
  id: "raw",
  title: "Raw JSON"
};
const VIEW_MODES = [VIEW_MODE_PARSED, VIEW_MODE_RAW];
const lru = HLRU(1e3);
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  if (cached === void 0) {
    lru.set(keyPath, Array.isArray(value) || isRecord(value));
    return isExpanded(keyPath, value);
  }
  return cached;
}
function toggleExpanded(event) {
  const {
    path
  } = event;
  const current = lru.get(path);
  if (current === void 0) {
    return;
  }
  lru.set(path, !current);
}
function selectElement(element) {
  const sel = window.getSelection();
  if (sel) {
    const range = document.createRange();
    sel.removeAllRanges();
    range.selectNodeContents(element);
    sel.addRange(range);
  }
}
function select(event) {
  selectElement(event.currentTarget);
}
function maybeSelectAll(event) {
  const selectAll = event.keyCode === 65 && (event.metaKey || event.ctrlKey);
  if (!selectAll) {
    return;
  }
  event.preventDefault();
  selectElement(event.currentTarget);
}
function isDocumentLike(value) {
  return isRecord(value) && isString(value._id) && isString(value._type);
}
var __freeze$9 = Object.freeze;
var __defProp$9 = Object.defineProperty;
var __template$9 = (cooked, raw) => __freeze$9(__defProp$9(cooked, "raw", {
  value: __freeze$9(raw || cooked.slice())
}));
var _a$9;
const JSONInspectorWrapper = styled.div(_ref12 => {
  let {
    theme
  } = _ref12;
  const {
    color,
    fonts,
    space
  } = theme.sanity;
  return css(_a$9 || (_a$9 = __template$9(["\n    & .json-inspector,\n    & .json-inspector .json-inspector__selection {\n      font-family: ", ";\n      font-size: ", "px;\n      line-height: ", "px;\n      color: var(--card-code-fg-color);\n    }\n\n    & .json-inspector .json-inspector__leaf {\n      padding-left: ", ";\n    }\n\n    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {\n      padding-top: ", ";\n      padding-left: 0;\n    }\n\n    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {\n      display: none;\n    }\n\n    & .json-inspector .json-inspector__line {\n      display: block;\n      position: relative;\n      cursor: default;\n    }\n\n    & .json-inspector .json-inspector__line::after {\n      content: '';\n      position: absolute;\n      top: 0;\n      left: -200px;\n      right: -50px;\n      bottom: 0;\n      z-index: -1;\n      pointer-events: none;\n    }\n\n    & .json-inspector .json-inspector__line:hover::after {\n      background: var(--card-code-bg-color);\n    }\n\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {\n      cursor: pointer;\n    }\n\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {\n      content: '\u25B8 ';\n      margin-left: calc(0 - ", " + 3px);\n      font-size: ", "px;\n      line-height: ", "px;\n    }\n\n    &\n      .json-inspector\n      .json-inspector__leaf_expanded.json-inspector__leaf_composite\n      > .json-inspector__line::before {\n      content: '\u25BE ';\n      font-size: ", "px;\n      line-height: ", "px;\n    }\n\n    & .json-inspector .json-inspector__radio,\n    & .json-inspector .json-inspector__flatpath {\n      display: none;\n    }\n\n    & .json-inspector .json-inspector__value {\n      margin-left: ", ";\n    }\n\n    &\n      .json-inspector\n      > .json-inspector__leaf_root\n      > .json-inspector__line\n      > .json-inspector__key\n      + .json-inspector__value {\n      margin: 0;\n    }\n\n    & .json-inspector .json-inspector__key {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_helper,\n    & .json-inspector .json-inspector__value_null {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__not-found {\n      padding-top: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_string {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_boolean {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_number {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__show-original {\n      display: inline-block;\n      padding: 0 6px;\n      cursor: pointer;\n    }\n\n    & .json-inspector .json-inspector__show-original:hover {\n      color: inherit;\n    }\n\n    & .json-inspector .json-inspector__show-original::before {\n      content: '\u2194';\n    }\n\n    & .json-inspector .json-inspector__show-original:hover::after {\n      content: ' expand';\n    }\n  "])), fonts.code.family, fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, rem(space[4]), rem(space[3]), rem(space[4]), fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, fonts.code.sizes[2].fontSize, fonts.code.sizes[2].lineHeight, rem(space[4] / 2), color.syntax.property, color.syntax.constant, rem(space[3]), color.syntax.string, color.syntax.boolean, color.syntax.number);
});
function Search(props) {
  const {
    onChange,
    query
  } = props;
  const handleChange = useCallback(event => onChange(event.target.value), [onChange]);
  return /* @__PURE__ */jsx(TextInput, {
    icon: SearchIcon,
    onChange: handleChange,
    placeholder: "Search",
    radius: 2,
    value: query || ""
  });
}
function InspectDialog(props) {
  const {
    value
  } = props;
  const {
    onInspectClose,
    paneKey
  } = useDocumentPane();
  const dialogIdPrefix = "".concat(paneKey, "_inspect_");
  const [viewModeId, onViewModeChange] = useDeskToolSetting("desk-tool", "inspect-view-preferred-view-mode-".concat(paneKey), "parsed");
  const viewMode = VIEW_MODES.find(mode => mode.id === viewModeId);
  const setParsedViewMode = useCallback(() => {
    onViewModeChange(VIEW_MODE_PARSED.id);
  }, [onViewModeChange]);
  const setRawViewMode = useCallback(() => {
    onViewModeChange(VIEW_MODE_RAW.id);
  }, [onViewModeChange]);
  return /* @__PURE__ */jsx(Dialog, {
    id: "".concat(dialogIdPrefix, "dialog"),
    header: isDocumentLike(value) ? /* @__PURE__ */jsxs(Fragment, {
      children: ["Inspecting", " ", /* @__PURE__ */jsx("em", {
        children: /* @__PURE__ */jsx(DocTitle, {
          document: value
        })
      })]
    }) : /* @__PURE__ */jsx("em", {
      children: "No value"
    }),
    onClose: onInspectClose,
    onClickOutside: onInspectClose,
    width: 3,
    children: /* @__PURE__ */jsxs(Flex, {
      direction: "column",
      height: "fill",
      children: [/* @__PURE__ */jsx(Card, {
        padding: 3,
        shadow: 1,
        style: {
          position: "sticky",
          bottom: 0,
          zIndex: 3
        },
        children: /* @__PURE__ */jsxs(TabList, {
          space: 1,
          children: [/* @__PURE__ */jsx(Tab, {
            "aria-controls": "".concat(dialogIdPrefix, "tabpanel"),
            fontSize: 1,
            id: "".concat(dialogIdPrefix, "tab-").concat(VIEW_MODE_PARSED.id),
            label: VIEW_MODE_PARSED.title,
            onClick: setParsedViewMode,
            selected: viewMode === VIEW_MODE_PARSED
          }), /* @__PURE__ */jsx(Tab, {
            "aria-controls": "".concat(dialogIdPrefix, "tabpanel"),
            fontSize: 1,
            id: "".concat(dialogIdPrefix, "tab-").concat(VIEW_MODE_RAW.id),
            label: VIEW_MODE_RAW.title,
            onClick: setRawViewMode,
            selected: viewMode === VIEW_MODE_RAW
          })]
        })
      }), /* @__PURE__ */jsxs(TabPanel, {
        "aria-labelledby": "".concat(dialogIdPrefix, "tab-").concat(viewModeId),
        flex: 1,
        id: "".concat(dialogIdPrefix, "tabpanel"),
        overflow: "auto",
        padding: 4,
        style: {
          outline: "none"
        },
        children: [viewMode === VIEW_MODE_PARSED && /* @__PURE__ */jsx(JSONInspectorWrapper, {
          children: /* @__PURE__ */jsx(JSONInspector, {
            data: value,
            isExpanded,
            onClick: toggleExpanded,
            search: Search
          })
        }), viewMode === VIEW_MODE_RAW && /* @__PURE__ */jsx(Code, {
          language: "json",
          tabIndex: 0,
          onKeyDown: maybeSelectAll,
          onDoubleClick: select,
          onFocus: select,
          children: JSON.stringify(value, null, 2)
        })]
      })]
    })
  });
}
var __freeze$8 = Object.freeze;
var __defProp$8 = Object.defineProperty;
var __template$8 = (cooked, raw) => __freeze$8(__defProp$8(cooked, "raw", {
  value: __freeze$8(raw || cooked.slice())
}));
var _a$8;
const Root$3 = styled(Card)(_a$8 || (_a$8 = __template$8(["\n  position: relative;\n  z-index: 50;\n"])));
function DeletedDocumentBanner(_ref13) {
  let {
    revisionId
  } = _ref13;
  const {
    documentId,
    documentType
  } = useDocumentPane();
  const {
    restore
  } = useDocumentOperation(documentId, documentType);
  const {
    navigateIntent
  } = useRouter();
  const handleRestore = useCallback(() => {
    if (revisionId) {
      restore.execute(revisionId);
      navigateIntent("edit", {
        id: documentId,
        type: documentType
      });
    }
  }, [documentId, documentType, navigateIntent, restore, revisionId]);
  return /* @__PURE__ */jsx(Root$3, {
    "data-testid": "deleted-document-banner",
    shadow: 1,
    tone: "transparent",
    children: /* @__PURE__ */jsx(Container, {
      paddingX: 4,
      paddingY: revisionId ? 2 : 3,
      sizing: "border",
      width: 1,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "center",
        children: [/* @__PURE__ */jsx(Text, {
          size: 1,
          children: /* @__PURE__ */jsx(ReadOnlyIcon, {})
        }), /* @__PURE__ */jsxs(Flex, {
          align: "center",
          gap: 2,
          flex: 1,
          marginLeft: 3,
          children: [/* @__PURE__ */jsx(Text, {
            size: 1,
            children: "This document has been deleted."
          }), revisionId && /* @__PURE__ */jsx(Button, {
            fontSize: 1,
            padding: 2,
            mode: "bleed",
            tone: "primary",
            onClick: handleRestore,
            text: "Restore most recent version"
          })]
        })]
      })
    })
  });
}
var __freeze$7 = Object.freeze;
var __defProp$7 = Object.defineProperty;
var __template$7 = (cooked, raw) => __freeze$7(__defProp$7(cooked, "raw", {
  value: __freeze$7(raw || cooked.slice())
}));
var _a$7, _b$1;
const Root$2 = styled(Card)(_a$7 || (_a$7 = __template$7(["\n  position: relative;\n  z-index: 50;\n"])));
const TextOneLine = styled(Text)(_b$1 || (_b$1 = __template$7(["\n  & > * {\n    overflow: hidden;\n    overflow: clip;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n  }\n"])));
const ReferenceChangedBanner = memo(() => {
  var _a2, _b2, _c, _d, _e, _f;
  const documentPreviewStore = useDocumentPreviewStore();
  const {
    params,
    groupIndex,
    routerPanesState,
    replaceCurrent,
    BackLink
  } = usePaneRouter();
  const routerReferenceId = (_a2 = routerPanesState[groupIndex]) == null ? void 0 : _a2[0].id;
  const parentGroup = routerPanesState[groupIndex - 1];
  const parentSibling = parentGroup == null ? void 0 : parentGroup[0];
  const parentId = parentSibling == null ? void 0 : parentSibling.id;
  const hasHistoryOpen = Boolean((_b2 = parentSibling == null ? void 0 : parentSibling.params) == null ? void 0 : _b2.rev);
  const parentRefPath = useMemo(() => {
    return (params == null ? void 0 : params.parentRefPath) && fromString(params.parentRefPath) || null;
  }, [params == null ? void 0 : params.parentRefPath]);
  const referenceInfo = useMemoObservable(() => {
    const parentRefPathSegment = parentRefPath == null ? void 0 : parentRefPath[0];
    if (!parentId || !parentRefPathSegment || !parentRefPath) {
      return of({
        loading: false
      });
    }
    const publishedId = getPublishedId(parentId);
    const path = fromString(parentRefPathSegment);
    const keyedSegmentIndex = path.findIndex(p => typeof p == "object" && "_key" in p);
    return concat(
    // emit a loading state instantly
    of({
      loading: true
    }),
    // then emit the values from watching the published ID's path
    documentPreviewStore.unstable_observePathsDocumentPair(publishedId, keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex)).pipe(
    // this debounce time is needed to prevent flashing banners due to
    // the router state updating faster than the content-lake state. we
    // debounce to wait for more emissions because the value pulled
    // initially could be stale.
    debounceTime(750), map(_ref14 => {
      let {
        draft,
        published
      } = _ref14;
      var _a3;
      return {
        loading: false,
        result: {
          availability: {
            draft: draft.availability,
            published: published.availability
          },
          refValue: (_a3 = get(draft.snapshot || published.snapshot, parentRefPath)) == null ? void 0 : _a3._ref
        }
      };
    })));
  }, [documentPreviewStore, parentId, parentRefPath], {
    loading: true
  });
  const handleReloadReference = useCallback(() => {
    var _a3;
    if (referenceInfo.loading) return;
    if ((_a3 = referenceInfo.result) == null ? void 0 : _a3.refValue) {
      replaceCurrent({
        id: referenceInfo.result.refValue,
        params
      });
    }
  }, [referenceInfo.loading, referenceInfo.result, replaceCurrent, params]);
  const shouldHide =
  // if `parentId` or `parentRefPath` is not present then this banner is n/a
  !parentId || !parentRefPath ||
  // if viewing this pane via history, then hide
  hasHistoryOpen ||
  // if loading, hide
  referenceInfo.loading ||
  // if the parent document is not available (e.g. due to permission denied or
  // not found) we don't want to display a warning here, but instead rely on the
  // parent view to display the appropriate message
  !((_c = referenceInfo.result) == null ? void 0 : _c.availability.draft.available) && !((_d = referenceInfo.result) == null ? void 0 : _d.availability.published.available) ||
  // if the references are the same, then hide the reference changed banner
  ((_e = referenceInfo.result) == null ? void 0 : _e.refValue) === routerReferenceId;
  if (shouldHide) return null;
  return /* @__PURE__ */jsx(Root$2, {
    shadow: 1,
    tone: "caution",
    "data-testid": "reference-changed-banner",
    children: /* @__PURE__ */jsx(Container, {
      paddingX: 4,
      paddingY: 2,
      sizing: "border",
      width: 1,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "center",
        children: [/* @__PURE__ */jsx(Text, {
          size: 1,
          children: /* @__PURE__ */jsx(WarningOutlineIcon, {})
        }), ((_f = referenceInfo.result) == null ? void 0 : _f.refValue) ? /* @__PURE__ */jsxs(Fragment, {
          children: [/* @__PURE__ */jsx(Box, {
            flex: 1,
            marginLeft: 3,
            children: /* @__PURE__ */jsx(TextOneLine, {
              title: "This reference has changed since you opened it.",
              size: 1,
              children: "This reference has changed since you opened it."
            })
          }), /* @__PURE__ */jsx(Box, {
            marginLeft: 3,
            children: /* @__PURE__ */jsx(Button, {
              onClick: handleReloadReference,
              icon: SyncIcon,
              fontSize: 1,
              mode: "ghost",
              padding: 2,
              space: 2,
              text: "Reload reference"
            })
          })]
        }) : /* @__PURE__ */jsxs(Fragment, {
          children: [/* @__PURE__ */jsx(Box, {
            flex: 1,
            marginLeft: 3,
            children: /* @__PURE__ */jsx(TextOneLine, {
              title: "This reference has been removed since you opened it.",
              size: 1,
              children: "This reference has been removed since you opened it."
            })
          }), /* @__PURE__ */jsx(Box, {
            marginLeft: 3,
            children: /* @__PURE__ */jsx(Button, {
              as: BackLink,
              icon: CloseIcon,
              fontSize: 1,
              mode: "ghost",
              padding: 2,
              space: 2,
              text: "Close reference"
            })
          })]
        })]
      })
    })
  });
});
ReferenceChangedBanner.displayName = "ReferenceChangedBanner";
var __freeze$6 = Object.freeze;
var __defProp$6 = Object.defineProperty;
var __template$6 = (cooked, raw) => __freeze$6(__defProp$6(cooked, "raw", {
  value: __freeze$6(raw || cooked.slice())
}));
var _a$6;
const Root$1 = styled(Card)(_a$6 || (_a$6 = __template$6(["\n  position: relative;\n  z-index: 50;\n"])));
function PermissionCheckBanner(_ref15) {
  let {
    granted,
    requiredPermission
  } = _ref15;
  var _a2, _b;
  const currentUser = useCurrentUser();
  const plural = ((_a2 = currentUser == null ? void 0 : currentUser.roles) == null ? void 0 : _a2.length) !== 1;
  const roles = join(((_b = currentUser == null ? void 0 : currentUser.roles) == null ? void 0 : _b.map(r => /* @__PURE__ */jsx("code", {
    children: r.title
  }, r.name))) || [], ", ");
  if (granted) return null;
  return /* @__PURE__ */jsx(Root$1, {
    "data-testid": "permission-check-banner",
    shadow: 1,
    tone: "transparent",
    children: /* @__PURE__ */jsx(Container, {
      paddingX: 4,
      paddingY: 3,
      sizing: "border",
      width: 1,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "flex-start",
        children: [/* @__PURE__ */jsx(Text, {
          size: 1,
          children: /* @__PURE__ */jsx(ReadOnlyIcon, {})
        }), /* @__PURE__ */jsx(Box, {
          flex: 1,
          marginLeft: 3,
          children: /* @__PURE__ */jsxs(Text, {
            size: 1,
            children: ["Your role", plural && "s", " ", roles, " ", plural ? "do" : "does", " not have permissions to", " ", requiredPermission, " this document."]
          })
        })]
      })
    })
  });
}
function join(array, sep) {
  return array.reduce((result, item) => {
    if (result === null) {
      return [item];
    }
    return result.concat([sep, item]);
  }, null);
}
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
const LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function useConditionalToast(params) {
  const toast = useToast();
  const wasEnabled = usePrevious(params.enabled);
  useEffect(() => {
    if (!wasEnabled && params.enabled) {
      toast.push({
        ...params,
        duration: LONG_ENOUGH_BUT_NOT_TOO_LONG
      });
    }
    if (wasEnabled && !params.enabled) {
      toast.push({
        ...params,
        // Note: @sanity/ui fallbacks to the default duration of 4s in case of falsey values
        duration: 0.01
      });
    }
  }, [params, toast, wasEnabled]);
}
const preventDefault = ev => ev.preventDefault();
const FormView = forwardRef(function FormView2(props, ref) {
  var _a;
  const {
    hidden,
    margins
  } = props;
  const {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    editState,
    documentId,
    documentType,
    fieldActions,
    onChange,
    validation,
    ready,
    formState,
    onFocus,
    onBlur,
    onSetCollapsedPath,
    onPathOpen,
    onSetCollapsedFieldSet,
    onSetActiveFieldGroup
  } = useDocumentPane();
  const documentStore = useDocumentStore();
  const presence = useDocumentPresence(documentId);
  const patchChannel = useMemo(() => createPatchChannel(), []);
  const isLocked = (_a = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a.enabled;
  useConditionalToast({
    id: "sync-lock-".concat(documentId),
    status: "warning",
    enabled: isLocked,
    title: "Syncing document\u2026",
    description: "Please hold tight while the document is synced. This usually happens right after the document has been published, and it shouldn't take more than a few seconds"
  });
  useEffect(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe(tap(event => {
      if (event.type === "mutation") {
        patchChannel.publish(prepareMutationEvent(event));
      }
      if (event.type === "rebase") {
        patchChannel.publish(prepareRebaseEvent(event));
      }
    })).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = Boolean(value == null ? void 0 : value._rev);
  useEffect(() => {
    if (hasRev) {
      patchChannel.publish({
        type: "mutation",
        patches: [],
        snapshot: value
      });
    }
  }, [hasRev]);
  const [formRef, setFormRef] = useState(null);
  useEffect(() => {
    if (ready && !(formState == null ? void 0 : formState.focusPath.length) && formRef) {
      focusFirstDescendant(formRef);
    }
  }, [ready]);
  const setRef = useCallback(node => {
    setFormRef(node);
    if (typeof ref === "function") {
      ref(node);
    } else if (ref) {
      ref.current = node;
    }
  }, [ref]);
  return /* @__PURE__ */jsx(Container, {
    hidden,
    paddingX: 4,
    paddingTop: 5,
    paddingBottom: 9,
    sizing: "border",
    width: 1,
    children: /* @__PURE__ */jsx(PresenceOverlay, {
      margins,
      children: /* @__PURE__ */jsx(Box, {
        as: "form",
        onSubmit: preventDefault,
        ref: setRef,
        children: ready ? formState === null ? /* @__PURE__ */jsx(Box, {
          padding: 2,
          children: /* @__PURE__ */jsx(Text, {
            children: "This form is hidden"
          })
        }) : /* @__PURE__ */jsx(FormBuilder, {
          __internal_fieldActions: fieldActions,
          __internal_patchChannel: patchChannel,
          collapsedFieldSets,
          collapsedPaths,
          focusPath: formState.focusPath,
          changed: formState.changed,
          focused: formState.focused,
          groups: formState.groups,
          id: "root",
          members: formState.members,
          onChange,
          onFieldGroupSelect: onSetActiveFieldGroup,
          onPathBlur: onBlur,
          onPathFocus: onFocus,
          onPathOpen,
          onSetFieldSetCollapsed: onSetCollapsedFieldSet,
          onSetPathCollapsed: onSetCollapsedPath,
          presence,
          readOnly: formState.readOnly,
          schemaType: formState.schemaType,
          validation,
          value: formState.value
        }) : /* @__PURE__ */jsx(Delay, {
          ms: 300,
          children: /* @__PURE__ */jsxs(Flex, {
            align: "center",
            direction: "column",
            height: "fill",
            justify: "center",
            children: [/* @__PURE__ */jsx(Spinner, {
              muted: true
            }), /* @__PURE__ */jsx(Box, {
              marginTop: 3,
              children: /* @__PURE__ */jsx(Text, {
                align: "center",
                muted: true,
                size: 1,
                children: "Loading document"
              })
            })]
          })
        })
      })
    })
  });
});
function prepareMutationEvent(event) {
  const patches = event.mutations.map(mut => mut.patch).filter(Boolean);
  return {
    type: "mutation",
    snapshot: event.document,
    patches: fromMutationPatches(event.origin, patches)
  };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map(mut => mut.patch).filter(Boolean);
  const localPatches = event.localMutations.map(mut => mut.patch).filter(Boolean);
  return {
    type: "rebase",
    snapshot: event.document,
    patches: fromMutationPatches("remote", remotePatches).concat(fromMutationPatches("local", localPatches))
  };
}
function DocumentHeaderTabs() {
  const {
    activeViewId,
    paneKey,
    views
  } = useDocumentPane();
  const tabPanelId = "".concat(paneKey, "tabpanel");
  return /* @__PURE__ */jsx(TabList, {
    space: 1,
    children: views.map((view, index) => {
      var _a;
      return /* @__PURE__ */jsx(DocumentHeaderTab, {
        icon: view.icon,
        id: "".concat(paneKey, "tab-").concat(view.id),
        isActive: activeViewId === view.id,
        label: /* @__PURE__ */jsx(Fragment, {
          children: view.title
        }),
        tabPanelId,
        viewId: index === 0 ? null : (_a = view.id) != null ? _a : null
      }, view.id);
    })
  });
}
function DocumentHeaderTab(props) {
  const {
    isActive,
    tabPanelId,
    viewId,
    ...rest
  } = props;
  const {
    ready
  } = useDocumentPane();
  const {
    setView
  } = usePaneRouter();
  const handleClick = useCallback(() => setView(viewId), [setView, viewId]);
  return /* @__PURE__ */jsx(Tab, {
    ...rest,
    "aria-controls": tabPanelId,
    disabled: !ready,
    fontSize: 1,
    selected: isActive,
    onClick: handleClick
  });
}
function DocumentHeaderTitle() {
  const {
    connectionState,
    schemaType,
    title,
    value: documentValue
  } = useDocumentPane();
  const subscribed = Boolean(documentValue) && connectionState === "connected";
  const {
    error,
    value
  } = unstable_useValuePreview({
    enabled: subscribed,
    schemaType,
    value: documentValue
  });
  if (connectionState !== "connected") {
    return /* @__PURE__ */jsx(Fragment, {});
  }
  if (title) {
    return /* @__PURE__ */jsx(Fragment, {
      children: title
    });
  }
  if (!documentValue) {
    return /* @__PURE__ */jsxs(Fragment, {
      children: ["New ", (schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)]
    });
  }
  if (error) {
    return /* @__PURE__ */jsxs(Fragment, {
      children: ["Error: ", error.message]
    });
  }
  return /* @__PURE__ */jsx(Fragment, {
    children: (value == null ? void 0 : value.title) || /* @__PURE__ */jsx("span", {
      style: {
        color: "var(--card-muted-fg-color)"
      },
      children: "Untitled"
    })
  });
}
const DocumentPanelHeader = memo(forwardRef(function DocumentPanelHeader2(_props, ref) {
  const {
    onMenuAction,
    onPaneClose,
    onPaneSplit,
    menuItems,
    menuItemGroups,
    schemaType,
    timelineStore,
    ready,
    views,
    unstable_languageFilter
  } = useDocumentPane();
  const {
    features
  } = useDeskTool();
  const {
    index,
    BackLink,
    hasGroupSiblings
  } = usePaneRouter();
  const {
    actions: fieldActions
  } = useFieldActions();
  const menuNodes = useMemo(() => resolveMenuNodes({
    actionHandler: onMenuAction,
    fieldActions,
    menuItems,
    menuItemGroups
  }), [onMenuAction, fieldActions, menuItemGroups, menuItems]);
  const menuButtonNodes = useMemo(() => menuNodes.filter(isMenuNodeButton), [menuNodes]);
  const contextMenuNodes = useMemo(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]);
  const showTabs = views.length > 1;
  const rev = useTimelineSelector(timelineStore, state => state.revTime);
  const {
    collapsed,
    isLast
  } = usePane();
  const tabIndex = isLast && !collapsed ? -1 : 0;
  const showSplitPaneButton = features.splitViews && onPaneSplit && views.length > 1;
  const showSplitPaneCloseButton = showSplitPaneButton && hasGroupSiblings;
  const showPaneGroupCloseButton = !showSplitPaneCloseButton && !features.backButton;
  return /* @__PURE__ */jsx(PaneHeader, {
    ref,
    loading: !ready,
    title: /* @__PURE__ */jsx(DocumentHeaderTitle, {}),
    tabs: showTabs && /* @__PURE__ */jsx(DocumentHeaderTabs, {}),
    tabIndex,
    backButton: features.backButton && index > 0 && /* @__PURE__ */jsx(Button, {
      as: BackLink,
      "data-as": "a",
      icon: ArrowLeftIcon,
      mode: "bleed",
      padding: 2
    }),
    subActions: /* @__PURE__ */jsx(TimelineMenu, {
      chunk: rev,
      mode: "rev",
      placement: "bottom-end"
    }),
    actions: /* @__PURE__ */jsxs(Flex, {
      align: "center",
      gap: 1,
      children: [unstable_languageFilter.length > 0 && /* @__PURE__ */jsx(Fragment, {
        children: unstable_languageFilter.map((languageFilterComponent, idx) => {
          return createElement(languageFilterComponent, {
            // eslint-disable-next-line react/no-array-index-key
            key: "language-filter-".concat(idx),
            schemaType
          });
        })
      }), menuButtonNodes.map(item => /* @__PURE__ */jsx(PaneHeaderActionButton, {
        node: item
      }, item.key)), /* @__PURE__ */jsx(PaneContextMenuButton, {
        nodes: contextMenuNodes
      }, "context-menu"), showSplitPaneButton && /* @__PURE__ */jsx(Tooltip, {
        content: /* @__PURE__ */jsx(Text, {
          size: 1,
          style: {
            whiteSpace: "nowrap"
          },
          children: "Split pane right"
        }),
        padding: 2,
        placement: "bottom",
        portal: true,
        children: /* @__PURE__ */jsx(Button, {
          "aria-label": "Split pane right",
          icon: SplitVerticalIcon,
          mode: "bleed",
          onClick: onPaneSplit
        }, "split-pane-button")
      }), showSplitPaneCloseButton && /* @__PURE__ */jsx(Button, {
        icon: CloseIcon,
        mode: "bleed",
        onClick: onPaneClose,
        title: "Close split pane"
      }, "close-view-button"), showPaneGroupCloseButton && /* @__PURE__ */jsx(Button, {
        icon: CloseIcon,
        mode: "bleed",
        title: "Close pane group",
        as: BackLink
      }, "close-view-button")]
    })
  });
}));
var __freeze$5 = Object.freeze;
var __defProp$5 = Object.defineProperty;
var __template$5 = (cooked, raw) => __freeze$5(__defProp$5(cooked, "raw", {
  value: __freeze$5(raw || cooked.slice())
}));
var _a$5;
const DocumentBox = styled(Box)({
  position: "relative"
});
const Scroller = styled(ScrollContainer)(_ref16 => {
  let {
    $disabled
  } = _ref16;
  if ($disabled) {
    return {
      height: "100%"
    };
  }
  return css(_a$5 || (_a$5 = __template$5(["\n    height: 100%;\n    overflow: auto;\n    position: relative;\n    scroll-behavior: smooth;\n    outline: none;\n  "])));
});
const DocumentPanel = function DocumentPanel2(props) {
  const {
    footerHeight,
    isInspectOpen,
    rootElement,
    setDocumentPanelPortalElement
  } = props;
  const {
    activeViewId,
    displayed,
    documentId,
    editState,
    inspector,
    value,
    views,
    ready,
    schemaType,
    permissions,
    isPermissionsLoading,
    isDeleting,
    isDeleted,
    timelineStore,
    formState
  } = useDocumentPane();
  const {
    collapsed: layoutCollapsed
  } = usePaneLayout();
  const {
    collapsed
  } = usePane();
  const parentPortal = usePortal();
  const {
    features
  } = useDeskTool();
  const [headerElement, setHeaderElement] = useState(null);
  const headerRect = useElementRect(headerElement);
  const portalRef = useRef(null);
  const [documentScrollElement, setDocumentScrollElement] = useState(null);
  const formContainerElement = useRef(null);
  const requiredPermission = value._createdAt ? "update" : "create";
  const selectedGroup = useMemo(() => {
    if (!formState) return void 0;
    return formState.groups.find(group => group.selected);
  }, [formState]);
  const activeView = useMemo(() => views.find(view => view.id === activeViewId) || views[0] || {
    type: "form"
  }, [activeViewId, views]);
  const portalElement = features.splitPanes ? portalRef.current || parentPortal.element : parentPortal.element;
  const margins = useMemo(() => {
    if (layoutCollapsed) {
      return [(headerRect == null ? void 0 : headerRect.height) || 0, 0, footerHeight ? footerHeight + 2 : 2, 0];
    }
    return [0, 0, 2, 0];
  }, [layoutCollapsed, footerHeight, headerRect]);
  const formViewHidden = activeView.type !== "form";
  const activeViewNode = useMemo(() => activeView.type === "component" && activeView.component && createElement(activeView.component, {
    document: {
      draft: (editState == null ? void 0 : editState.draft) || null,
      displayed: displayed || value,
      historical: displayed,
      published: (editState == null ? void 0 : editState.published) || null
    },
    documentId,
    options: activeView.options,
    schemaType
  }), [activeView, displayed, documentId, editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, schemaType, value]);
  const lastNonDeletedRevId = useTimelineSelector(timelineStore, state => state.lastNonDeletedRevId);
  useEffect(() => {
    if (!(documentScrollElement == null ? void 0 : documentScrollElement.scrollTo)) return;
    documentScrollElement.scrollTo(0, 0);
  }, [documentId, documentScrollElement]);
  useEffect(() => {
    if (portalElement) {
      setDocumentPanelPortalElement(portalElement);
    }
  }, [portalElement, setDocumentPanelPortalElement]);
  const inspectDialog = useMemo(() => {
    return isInspectOpen ? /* @__PURE__ */jsx(InspectDialog, {
      value: displayed || value
    }) : null;
  }, [isInspectOpen, displayed, value]);
  const showInspector = Boolean(!collapsed && inspector);
  return /* @__PURE__ */jsxs(Fragment, {
    children: [/* @__PURE__ */jsx(DocumentPanelHeader, {
      ref: setHeaderElement
    }), /* @__PURE__ */jsx(PaneContent, {
      children: /* @__PURE__ */jsxs(Flex, {
        height: "fill",
        children: [(features.resizablePanes || !showInspector) && /* @__PURE__ */jsx(DocumentBox, {
          flex: 2,
          overflow: "hidden",
          children: /* @__PURE__ */jsx(PortalProvider, {
            element: portalElement,
            __unstable_elements: {
              documentScrollElement
            },
            children: /* @__PURE__ */jsx(BoundaryElementProvider, {
              element: documentScrollElement,
              children: /* @__PURE__ */jsxs(VirtualizerScrollInstanceProvider, {
                scrollElement: documentScrollElement,
                containerElement: formContainerElement,
                children: [activeView.type === "form" && !isPermissionsLoading && ready && /* @__PURE__ */jsxs(Fragment, {
                  children: [/* @__PURE__ */jsx(PermissionCheckBanner, {
                    granted: Boolean(permissions == null ? void 0 : permissions.granted),
                    requiredPermission
                  }), !isDeleting && isDeleted && /* @__PURE__ */jsx(DeletedDocumentBanner, {
                    revisionId: lastNonDeletedRevId
                  }), /* @__PURE__ */jsx(ReferenceChangedBanner, {})]
                }), /* @__PURE__ */jsxs(Scroller, {
                  $disabled: layoutCollapsed || false,
                  "data-testid": "document-panel-scroller",
                  ref: setDocumentScrollElement,
                  children: [/* @__PURE__ */jsx(FormView, {
                    hidden: formViewHidden,
                    margins,
                    ref: formContainerElement
                  }, documentId + (ready ? "_ready" : "_pending")), activeViewNode]
                }, "".concat(selectedGroup == null ? void 0 : selectedGroup.name, "-").concat(documentId, "}")), inspectDialog, /* @__PURE__ */jsx("div", {
                  "data-testid": "document-panel-portal",
                  ref: portalRef
                })]
              })
            })
          })
        }), showInspector && /* @__PURE__ */jsx(BoundaryElementProvider, {
          element: rootElement,
          children: /* @__PURE__ */jsx(DocumentInspectorPanel, {
            documentId,
            documentType: schemaType.name,
            flex: 1
          })
        })]
      })
    })]
  });
};
const POPOVER_FALLBACK_PLACEMENTS = ["left", "bottom"];
const DIALOG_WIDTH_TO_UI_WIDTH = {
  small: 0,
  medium: 1,
  large: 2,
  full: "auto"
};
function ConfirmDialog(props) {
  const {
    dialog,
    referenceElement
  } = props;
  return /* @__PURE__ */jsx(Popover, {
    content: /* @__PURE__ */jsx(ConfirmDialogContent, {
      dialog
    }),
    fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
    open: true,
    placement: "top",
    portal: true,
    preventOverflow: true,
    referenceElement
  });
}
function ConfirmDialogContent(props) {
  const {
    dialog
  } = props;
  const {
    cancelButtonIcon,
    cancelButtonText,
    confirmButtonIcon,
    confirmButtonText,
    // color,
    message,
    onCancel,
    onConfirm,
    tone
  } = dialog;
  const {
    isTopLayer
  } = useLayer();
  const [element, setElement] = useState(null);
  const handleClickOutside = useCallback(() => {
    if (isTopLayer) onCancel();
  }, [isTopLayer, onCancel]);
  const handleGlobalKeyDown = useCallback(event => {
    if (event.key === "Escape" && isTopLayer) onCancel();
  }, [isTopLayer, onCancel]);
  useClickOutside(handleClickOutside, [element]);
  useGlobalKeyDown(handleGlobalKeyDown);
  return /* @__PURE__ */jsxs(Flex, {
    direction: "column",
    ref: setElement,
    style: {
      minWidth: 320 - 16,
      maxWidth: 400
    },
    children: [/* @__PURE__ */jsx(Box, {
      flex: 1,
      overflow: "auto",
      padding: 4,
      children: /* @__PURE__ */jsx(Text, {
        children: message
      })
    }), /* @__PURE__ */jsx(Box, {
      paddingX: 4,
      paddingY: 3,
      style: {
        borderTop: "1px solid var(--card-border-color)"
      },
      children: /* @__PURE__ */jsxs(Grid, {
        columns: 2,
        gap: 2,
        children: [/* @__PURE__ */jsx(Button, {
          icon: cancelButtonIcon,
          onClick: onCancel,
          mode: "ghost",
          text: cancelButtonText || "Cancel"
        }), /* @__PURE__ */jsx(Button, {
          icon: confirmButtonIcon,
          onClick: onConfirm,
          text: confirmButtonText || "Confirm",
          tone
        })]
      })
    })]
  });
}
function ModalDialog(props) {
  const {
    dialog
  } = props;
  const dialogId = useId();
  const footer = dialog.footer && /* @__PURE__ */jsx(Box, {
    paddingX: 4,
    paddingY: 3,
    children: dialog.footer
  });
  return /* @__PURE__ */jsx(LegacyLayerProvider, {
    zOffset: "fullscreen",
    children: /* @__PURE__ */jsx(Dialog, {
      __unstable_hideCloseButton: dialog.showCloseButton === false,
      footer,
      header: dialog.header,
      id: dialogId,
      onClose: dialog.onClose,
      onClickOutside: dialog.onClose,
      width: dialog.width === void 0 ? 1 : DIALOG_WIDTH_TO_UI_WIDTH[dialog.width],
      children: /* @__PURE__ */jsx(Box, {
        padding: 4,
        children: dialog.content
      })
    })
  });
}
function PopoverDialog(props) {
  const {
    dialog,
    referenceElement
  } = props;
  return /* @__PURE__ */jsx(Popover, {
    content: /* @__PURE__ */jsx(PopoverDialogContent, {
      dialog
    }),
    fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS,
    open: true,
    placement: "top",
    portal: true,
    preventOverflow: true,
    referenceElement
  });
}
function PopoverDialogContent(props) {
  const {
    dialog
  } = props;
  const {
    content,
    onClose
  } = dialog;
  const {
    isTopLayer
  } = useLayer();
  const [element, setElement] = useState(null);
  const handleClickOutside = useCallback(() => {
    if (isTopLayer) onClose();
  }, [isTopLayer, onClose]);
  const handleGlobalKeyDown = useCallback(event => {
    if (event.key === "Escape" && isTopLayer) onClose();
  }, [isTopLayer, onClose]);
  useClickOutside(handleClickOutside, [element]);
  useGlobalKeyDown(handleGlobalKeyDown);
  return /* @__PURE__ */jsx("div", {
    ref: setElement,
    children: content
  });
}
function DocumentActionPortalProvider(props) {
  const {
    children
  } = props;
  const {
    element,
    elements
  } = usePortal();
  const portalElement = (elements == null ? void 0 : elements[DOCUMENT_PANEL_PORTAL_ELEMENT]) || element;
  return /* @__PURE__ */jsx(PortalProvider, {
    element: portalElement,
    children
  });
}
function ActionStateDialog(props) {
  const {
    dialog,
    referenceElement = null
  } = props;
  const modalId = useId();
  if (dialog.type === "confirm") {
    return /* @__PURE__ */jsx(ConfirmDialog, {
      dialog,
      referenceElement
    });
  }
  if (dialog.type === "popover") {
    return /* @__PURE__ */jsx(PopoverDialog, {
      dialog,
      referenceElement
    });
  }
  if (dialog.type === "dialog" || !dialog.type) {
    return /* @__PURE__ */jsx(DocumentActionPortalProvider, {
      children: /* @__PURE__ */jsx(ModalDialog, {
        dialog
      })
    });
  }
  if (dialog.type === "custom") {
    return /* @__PURE__ */jsx(DocumentActionPortalProvider, {
      children: dialog == null ? void 0 : dialog.component
    });
  }
  const unknownModal = dialog;
  console.warn("Unsupported modal type ".concat(unknownModal.type));
  return /* @__PURE__ */jsx(Dialog, {
    id: modalId,
    onClose: unknownModal.onClose,
    onClickOutside: unknownModal.onClose,
    width: 2,
    children: /* @__PURE__ */jsx(Box, {
      padding: 4,
      children: unknownModal.content || /* @__PURE__ */jsxs(Fragment, {
        children: ["Unexpected modal type (", /* @__PURE__ */jsx("code", {
          children: unknownModal.type
        }), ")"]
      })
    })
  });
}
function ActionMenuButton(props) {
  const {
    actionStates,
    disabled
  } = props;
  const idPrefix = useId();
  const buttonRef = useRef(null);
  const [actionIndex, setActionIndex] = useState(-1);
  const [referenceElement, setReferenceElement] = useState(null);
  const handleAction = useCallback(idx => {
    setActionIndex(idx);
  }, []);
  const popoverProps = useMemo(() => ({
    placement: "top-end",
    portal: true,
    preventOverflow: true
  }), []);
  const currentAction = actionStates[actionIndex];
  return /* @__PURE__ */jsxs(Fragment, {
    children: [/* @__PURE__ */jsx(MenuButton, {
      id: "".concat(idPrefix, "-action-menu"),
      button: /* @__PURE__ */jsx(Button, {
        "data-testid": "action-menu-button",
        "aria-label": "Open document actions",
        disabled,
        icon: ChevronDownIcon,
        mode: "ghost",
        ref: buttonRef
      }),
      menu: /* @__PURE__ */jsx(Menu, {
        padding: 1,
        children: actionStates.map((actionState, idx) => /* @__PURE__ */jsx(ActionMenuListItem, {
          actionState,
          disabled,
          index: idx,
          onAction: handleAction
        }, idx))
      }),
      popover: popoverProps,
      ref: setReferenceElement
    }), currentAction && currentAction.dialog && /* @__PURE__ */jsx(LegacyLayerProvider, {
      zOffset: "paneFooter",
      children: /* @__PURE__ */jsx(ActionStateDialog, {
        dialog: currentAction.dialog,
        referenceElement
      })
    })]
  });
}
function ActionMenuListItem(props) {
  const {
    actionState,
    disabled,
    index,
    onAction
  } = props;
  const {
    onHandle
  } = actionState;
  const handleClick = useCallback(() => {
    onAction(index);
    if (onHandle) onHandle();
  }, [index, onAction, onHandle]);
  const tooltipContent = actionState.title && /* @__PURE__ */jsx(Box, {
    padding: 2,
    children: /* @__PURE__ */jsx(Text, {
      size: 1,
      children: actionState.title
    })
  });
  return /* @__PURE__ */jsx(MenuItem, {
    "data-testid": "action-".concat(actionState.label.replace(" ", "")),
    disabled: disabled || Boolean(actionState.disabled),
    onClick: handleClick,
    padding: 0,
    tone: actionState.tone,
    children: /* @__PURE__ */jsx(Tooltip, {
      content: tooltipContent,
      disabled: !tooltipContent,
      fallbackPlacements: ["left", "bottom"],
      placement: "top",
      portal: true,
      children: /* @__PURE__ */jsxs(Flex, {
        align: "center",
        paddingX: 3,
        children: [/* @__PURE__ */jsxs(Flex, {
          flex: 1,
          paddingY: 3,
          children: [actionState.icon && /* @__PURE__ */jsx(Box, {
            marginRight: 3,
            children: /* @__PURE__ */jsxs(Text, {
              children: [isValidElement(actionState.icon) && actionState.icon, isValidElementType(actionState.icon) && createElement(actionState.icon)]
            })
          }), /* @__PURE__ */jsx(Text, {
            children: actionState.label
          })]
        }), actionState.shortcut && /* @__PURE__ */jsx(Box, {
          marginLeft: 3,
          children: /* @__PURE__ */jsx(Hotkeys, {
            keys: String(actionState.shortcut).split("+").map(s => s.slice(0, 1).toUpperCase() + s.slice(1))
          })
        })]
      })
    })
  });
}
function DocumentStatusBarActionsInner(props) {
  const {
    disabled,
    showMenu,
    states
  } = props;
  const [firstActionState, ...menuActionStates] = states;
  const [buttonElement, setButtonElement] = useState(null);
  const tooltipContent = useMemo(() => {
    if (!firstActionState || !firstActionState.title && !firstActionState.shortcut) return null;
    return /* @__PURE__ */jsxs(Flex, {
      padding: 2,
      style: {
        maxWidth: 300
      },
      align: "center",
      children: [/* @__PURE__ */jsx(Text, {
        size: 1,
        children: firstActionState.title
      }), firstActionState.shortcut && /* @__PURE__ */jsx(Box, {
        marginLeft: firstActionState.title ? 2 : 0,
        children: /* @__PURE__ */jsx(Hotkeys, {
          keys: String(firstActionState.shortcut).split("+").map(s => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase())
        })
      })]
    });
  }, [firstActionState]);
  return /* @__PURE__ */jsxs(Flex, {
    children: [firstActionState && /* @__PURE__ */jsx(LayerProvider, {
      zOffset: 200,
      children: /* @__PURE__ */jsx(Tooltip, {
        disabled: !tooltipContent,
        content: tooltipContent,
        portal: true,
        placement: "top",
        children: /* @__PURE__ */jsx(Stack, {
          flex: 1,
          children: /* @__PURE__ */jsx(Button, {
            "data-testid": "action-".concat(firstActionState.label),
            disabled: disabled || Boolean(firstActionState.disabled),
            icon: firstActionState.icon,
            onClick: firstActionState.onHandle,
            ref: setButtonElement,
            text: firstActionState.label,
            tone: firstActionState.tone || "primary"
          })
        })
      })
    }), showMenu && menuActionStates.length > 0 && /* @__PURE__ */jsx(Box, {
      marginLeft: 1,
      children: /* @__PURE__ */jsx(ActionMenuButton, {
        actionStates: menuActionStates,
        disabled
      })
    }), firstActionState && firstActionState.dialog && /* @__PURE__ */jsx(ActionStateDialog, {
      dialog: firstActionState.dialog,
      referenceElement: buttonElement
    })]
  });
}
const DocumentStatusBarActions = memo(function DocumentStatusBarActions2() {
  const {
    actions,
    connectionState,
    documentId,
    editState
  } = useDocumentPane();
  if (!actions || !editState) {
    return null;
  }
  return /* @__PURE__ */jsx(RenderActionCollectionState, {
    actions,
    actionProps: editState,
    children: _ref17 => {
      let {
        states
      } = _ref17;
      return /* @__PURE__ */jsx(DocumentStatusBarActionsInner, {
        disabled: connectionState !== "connected",
        showMenu: actions.length > 1,
        states
      }, documentId);
    }
  });
});
const HistoryStatusBarActions = memo(function HistoryStatusBarActions2() {
  const {
    connectionState,
    editState,
    timelineStore
  } = useDocumentPane();
  const revTime = useTimelineSelector(timelineStore, state => state.revTime);
  const revision = (revTime == null ? void 0 : revTime.id) || "";
  const disabled = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev === revision;
  const actionProps = useMemo(() => ({
    ...(editState || {}),
    revision
  }), [editState, revision]);
  const historyActions = useMemo(() => [HistoryRestoreAction], []);
  return /* @__PURE__ */jsx(RenderActionCollectionState, {
    actions: historyActions,
    actionProps,
    children: _ref18 => {
      let {
        states
      } = _ref18;
      return /* @__PURE__ */jsx(DocumentStatusBarActionsInner, {
        disabled: connectionState !== "connected" || Boolean(disabled),
        showMenu: false,
        states
      });
    }
  });
});
const BADGE_TONES = {
  primary: "primary",
  success: "positive",
  warning: "caution",
  danger: "critical"
};
function DocumentBadgesInner(_ref19) {
  let {
    states
  } = _ref19;
  return /* @__PURE__ */jsx(Inline, {
    space: 1,
    children: states.map((badge, index) => /* @__PURE__ */jsx(Tooltip, {
      content: badge.title && /* @__PURE__ */jsx(Box, {
        padding: 2,
        children: /* @__PURE__ */jsx(Text, {
          size: 1,
          children: badge.title
        })
      }),
      disabled: !badge.title,
      placement: "top",
      portal: true,
      children: /* @__PURE__ */jsx(Badge, {
        fontSize: 1,
        mode: "outline",
        paddingX: 2,
        paddingY: 1,
        radius: 4,
        tone: badge.color ? BADGE_TONES[badge.color] : void 0,
        style: {
          whiteSpace: "nowrap"
        },
        children: badge.label
      })
    }, String(index)))
  });
}
function DocumentBadges() {
  const {
    badges,
    editState
  } = useDocumentPane();
  if (!editState || !badges) return null;
  return /* @__PURE__ */jsx(RenderBadgeCollectionState, {
    badges,
    badgeProps: editState,
    children: _ref20 => {
      let {
        states
      } = _ref20;
      return /* @__PURE__ */jsx(DocumentBadgesInner, {
        states
      });
    }
  });
}
var __freeze$4 = Object.freeze;
var __defProp$4 = Object.defineProperty;
var __template$4 = (cooked, raw) => __freeze$4(__defProp$4(cooked, "raw", {
  value: __freeze$4(raw || cooked.slice())
}));
var _a$4;
const Root = styled(Flex)(_a$4 || (_a$4 = __template$4(["\n  cursor: default;\n"])));
function PublishStatus(props) {
  const {
    collapsed,
    disabled,
    lastPublished,
    lastUpdated,
    liveEdit
  } = props;
  const lastPublishedTimeAgo = useTimeAgo(lastPublished || "", {
    minimal: true,
    agoSuffix: true
  });
  const lastPublishedTime = useTimeAgo(lastPublished || "", {
    minimal: true
  });
  const lastUpdatedTimeAgo = useTimeAgo(lastUpdated || "", {
    minimal: true,
    agoSuffix: true
  });
  const lastUpdatedTime = useTimeAgo(lastUpdated || "", {
    minimal: true
  });
  const a11yUpdatedAgo = useTimeAgo(lastUpdated || "", {
    minimal: false,
    agoSuffix: true
  });
  const a11yPublishedAgo = useTimeAgo(lastPublished || "", {
    minimal: false,
    agoSuffix: true
  });
  const a11yLabel = liveEdit ? "Last updated ".concat(a11yUpdatedAgo) : "Last published ".concat(a11yPublishedAgo);
  return /* @__PURE__ */jsx(Root, {
    align: "center",
    "data-ui": "SessionLayout",
    sizing: "border",
    children: /* @__PURE__ */jsx(Tooltip, {
      placement: "top",
      portal: true,
      content: /* @__PURE__ */jsx(Stack, {
        padding: 3,
        space: 3,
        children: /* @__PURE__ */jsx(Text, {
          size: 1,
          children: liveEdit ? /* @__PURE__ */jsxs(Fragment, {
            children: ["Last updated", " ", /* @__PURE__ */jsx("abbr", {
              "aria-label": lastUpdated ? a11yUpdatedAgo : a11yPublishedAgo,
              children: lastUpdated ? lastUpdatedTimeAgo : lastPublishedTimeAgo
            })]
          }) : /* @__PURE__ */jsxs(Fragment, {
            children: ["Last published ", /* @__PURE__ */jsx("abbr", {
              "aria-label": a11yPublishedAgo,
              children: lastPublishedTimeAgo
            })]
          })
        })
      }),
      children: /* @__PURE__ */jsx(Button, {
        mode: "bleed",
        tone: liveEdit ? "critical" : "positive",
        tabIndex: -1,
        disabled,
        "aria-label": a11yLabel,
        children: /* @__PURE__ */jsxs(Flex, {
          align: "center",
          children: [/* @__PURE__ */jsx(Box, {
            marginRight: collapsed ? 0 : 3,
            children: /* @__PURE__ */jsx(Text, {
              size: 2,
              "aria-hidden": "true",
              children: liveEdit ? /* @__PURE__ */jsx(PlayIcon, {}) : /* @__PURE__ */jsx(PublishIcon, {})
            })
          }), !collapsed && /* @__PURE__ */jsx(Text, {
            size: 1,
            weight: "medium",
            children: liveEdit ? /* @__PURE__ */jsx("abbr", {
              "aria-label": a11yLabel,
              children: lastUpdated ? lastUpdatedTime : lastPublishedTime
            }) : /* @__PURE__ */jsx("abbr", {
              "aria-label": a11yLabel,
              children: lastPublishedTime
            })
          })]
        })
      })
    })
  });
}
var __freeze$3 = Object.freeze;
var __defProp$3 = Object.defineProperty;
var __template$3 = (cooked, raw) => __freeze$3(__defProp$3(cooked, "raw", {
  value: __freeze$3(raw || cooked.slice())
}));
var _a$3, _b, _c;
const StyledMotionPath = styled(motion.path)(_a$3 || (_a$3 = __template$3(["\n  transform-origin: center;\n"])));
const Circle = props => /* @__PURE__ */jsx(motion.circle, {
  fill: "none",
  r: "8",
  cx: "12.5",
  cy: "12.5",
  strokeWidth: "1.2",
  ...props
});
const Arrows = props => /* @__PURE__ */jsx(StyledMotionPath, {
  fill: "none",
  d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811",
  ...props
});
const Checkmark = props => /* @__PURE__ */jsx(motion.path, {
  d: "M9.5 12.1316L11.7414 14.5L16 10",
  ...props
});
const Edit = props => /* @__PURE__ */jsx(motion.path, {
  d: "M15 7L18 10M6 19L7 15L17 5L20 8L10 18L6 19Z",
  ...props
});
const rotateAnimation = keyframes(_b || (_b = __template$3(["\n  0% {\n    transform: rotate(0);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n"])));
const RotateGroup = styled.g(_c || (_c = __template$3(["\n  transform-origin: center;\n\n  &[data-rotate] {\n    animation: ", " 1s ease-in-out infinite;\n  }\n"])), rotateAnimation);
const root = {
  syncing: {
    scale: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    scale: [1, 0.8, 1.2, 0.9, 1.1, 0.95, 1.05, 0.99, 1],
    transition: {
      duration: 0.5,
      delay: 0.2
    }
  },
  changes: {
    transition: {
      duration: 0
    }
  }
};
const circle = {
  syncing: {
    strokeDasharray: "0, 0, 23, 3, 23, 3",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    strokeDasharray: "0, 0, 23, 0, 23, 0",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    strokeDasharray: "0, 60, 23, 0, 23, 0",
    strokeDashoffset: 0,
    opacity: 0,
    transition: {
      duration: 0.5
    }
  }
};
const arrows = {
  syncing: {
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    opacity: 0,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    opacity: 0
  }
};
const checkmark = {
  syncing: {
    pathLength: 0,
    transition: {
      duration: 0
    }
  },
  saved: {
    pathLength: 1,
    transition: {
      delay: 0.4,
      duration: 0.3
    }
  },
  changes: {
    pathLength: 0,
    transition: {
      duration: 0.2
    }
  }
};
const edit = {
  syncing: {
    pathLength: 0,
    transition: {
      duration: 0
    }
  },
  saved: {
    pathLength: 0,
    transition: {
      duration: 0
    }
  },
  changes: {
    pathLength: 1,
    transition: {
      duration: 0.4,
      delay: 0.5
    }
  }
};
function AnimatedStatusIcon(props) {
  const {
    status
  } = props;
  if (!status) {
    return null;
  }
  return /* @__PURE__ */jsx("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 25 25",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "1.2",
    "data-sanity-icon": "",
    children: /* @__PURE__ */jsxs(motion.g, {
      variants: root,
      initial: status,
      animate: status,
      children: [/* @__PURE__ */jsxs(RotateGroup, {
        "data-rotate": status === "changes" ? void 0 : "",
        children: [/* @__PURE__ */jsx(Arrows, {
          variants: arrows,
          initial: status,
          animate: status
        }), /* @__PURE__ */jsx(Circle, {
          variants: circle,
          initial: status,
          animate: status
        })]
      }), /* @__PURE__ */jsx(Checkmark, {
        variants: checkmark,
        initial: status,
        animate: status
      }), /* @__PURE__ */jsx(Edit, {
        variants: edit,
        initial: status,
        animate: status
      })]
    })
  });
}
const ReviewButton = React.forwardRef(function ReviewButton2(props, ref) {
  const {
    collapsed,
    status,
    lastUpdated,
    ...rest
  } = props;
  const lastUpdatedTime = useTimeAgo(lastUpdated || "", {
    minimal: true
  });
  const lastUpdatedTimeAgo = useTimeAgo(lastUpdated || "", {
    minimal: true,
    agoSuffix: true
  });
  const a11yUpdatedAgo = useTimeAgo(lastUpdated || "", {
    minimal: false,
    agoSuffix: true
  });
  const buttonProps = useMemo(() => {
    if (status === "syncing") {
      return {
        text: "Saving...",
        tone: void 0
      };
    }
    if (status === "changes") {
      return {
        text: lastUpdatedTime,
        tone: "caution"
      };
    }
    if (status === "saved") {
      return {
        text: "Saved!",
        tone: "positive"
      };
    }
    return {};
  }, [status, lastUpdatedTime]);
  if (!status) {
    return null;
  }
  return /* @__PURE__ */jsx(Tooltip, {
    placement: "top",
    portal: true,
    disabled: status !== "changes",
    content: /* @__PURE__ */jsxs(Stack, {
      padding: 3,
      space: 3,
      children: [/* @__PURE__ */jsx(Text, {
        size: 1,
        weight: "semibold",
        children: "Review changes"
      }), /* @__PURE__ */jsxs(Text, {
        size: 1,
        muted: true,
        children: ["Changes saved ", /* @__PURE__ */jsx("abbr", {
          "aria-label": a11yUpdatedAgo,
          children: lastUpdatedTimeAgo
        })]
      })]
    }),
    children: /* @__PURE__ */jsx(Button, {
      mode: "bleed",
      justify: "flex-start",
      tone: buttonProps == null ? void 0 : buttonProps.tone,
      ...rest,
      "data-testid": "review-changes-button",
      ref,
      "aria-label": "Review changes",
      children: /* @__PURE__ */jsxs(Flex, {
        align: "center",
        children: [/* @__PURE__ */jsx(Box, {
          marginRight: collapsed ? 0 : 3,
          "aria-hidden": "true",
          children: /* @__PURE__ */jsx(Text, {
            children: /* @__PURE__ */jsx(AnimatedStatusIcon, {
              status
            })
          })
        }), !collapsed && /* @__PURE__ */jsx(Text, {
          size: 1,
          weight: "medium",
          children: buttonProps == null ? void 0 : buttonProps.text
        })]
      })
    })
  });
});
const ReviewChangesButton = React.memo(ReviewButton);
const SYNCING_TIMEOUT = 1e3;
const SAVED_TIMEOUT = 3e3;
const DocumentSparkline = memo(function DocumentSparkline2() {
  var _a;
  const {
    changesOpen,
    documentId,
    documentType,
    editState,
    onHistoryClose,
    onHistoryOpen,
    timelineStore,
    value
  } = useDocumentPane();
  const syncState = useSyncState(documentId, documentType);
  const lastUpdated = value == null ? void 0 : value._updatedAt;
  const lastPublished = (_a = editState == null ? void 0 : editState.published) == null ? void 0 : _a._updatedAt;
  const liveEdit = Boolean(editState == null ? void 0 : editState.liveEdit);
  const published = Boolean(editState == null ? void 0 : editState.published);
  const changed = Boolean(editState == null ? void 0 : editState.draft);
  const [rootFlexElement, setRootFlexElement] = useState(null);
  const rootFlexRect = useElementRect(rootFlexElement);
  const collapsed = !rootFlexRect || (rootFlexRect == null ? void 0 : rootFlexRect.width) < 300;
  const [status, setStatus] = useState(null);
  const showingRevision = useTimelineSelector(timelineStore, state => state.onOlderRevision);
  useEffect(() => {
    if (status === "syncing" && !syncState.isSyncing) {
      const timerId = setTimeout(() => setStatus("saved"), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }
    if (status === "saved") {
      const timerId = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId);
    }
  }, [status, lastUpdated, syncState.isSyncing]);
  useLayoutEffect(() => {
    setStatus(null);
  }, [documentId]);
  useLayoutEffect(() => {
    if (syncState.isSyncing) {
      setStatus("syncing");
    }
  }, [syncState.isSyncing, lastUpdated]);
  const reviewButton = useMemo(() => /* @__PURE__ */jsx(ReviewChangesButton, {
    lastUpdated,
    status: status || (changed ? "changes" : void 0),
    onClick: changesOpen ? onHistoryClose : onHistoryOpen,
    disabled: showingRevision,
    selected: changesOpen,
    collapsed
  }), [changed, changesOpen, onHistoryClose, onHistoryOpen, lastUpdated, showingRevision, status, collapsed]);
  const publishStatus = useMemo(() => (liveEdit || published) && /* @__PURE__ */jsx(Box, {
    marginRight: 1,
    children: /* @__PURE__ */jsx(PublishStatus, {
      disabled: showingRevision,
      lastPublished,
      lastUpdated,
      liveEdit,
      collapsed
    })
  }), [collapsed, lastPublished, lastUpdated, liveEdit, published, showingRevision]);
  return /* @__PURE__ */jsxs(Flex, {
    align: "center",
    "data-ui": "DocumentSparkline",
    ref: setRootFlexElement,
    children: [publishStatus, /* @__PURE__ */jsxs(Flex, {
      align: "center",
      flex: 1,
      children: [reviewButton, !collapsed && /* @__PURE__ */jsx(Box, {
        marginLeft: 3,
        children: /* @__PURE__ */jsx(DocumentBadges, {})
      })]
    })]
  });
});
var __freeze$2 = Object.freeze;
var __defProp$2 = Object.defineProperty;
var __template$2 = (cooked, raw) => __freeze$2(__defProp$2(cooked, "raw", {
  value: __freeze$2(raw || cooked.slice())
}));
var _a$2;
const DocumentActionsBox = styled(Box)(_a$2 || (_a$2 = __template$2(["\n  min-width: 10em;\n  max-width: 16em;\n"])));
function DocumentStatusBar(props) {
  const {
    actionsBoxRef
  } = props;
  const {
    badges,
    timelineStore
  } = useDocumentPane();
  const showingRevision = useTimelineSelector(timelineStore, state => state.onOlderRevision);
  return useMemo(() => /* @__PURE__ */jsx(Box, {
    paddingLeft: 2,
    paddingRight: [2, 3],
    paddingY: 2,
    children: /* @__PURE__ */jsxs(Flex, {
      align: "center",
      children: [/* @__PURE__ */jsx(Box, {
        flex: [1, 2],
        children: badges && /* @__PURE__ */jsx(DocumentSparkline, {})
      }), /* @__PURE__ */jsx(DocumentActionsBox, {
        flex: 1,
        marginLeft: [1, 3],
        ref: actionsBoxRef,
        children: showingRevision ? /* @__PURE__ */jsx(HistoryStatusBarActions, {}) : /* @__PURE__ */jsx(DocumentStatusBarActions, {})
      })]
    })
  }), [actionsBoxRef, badges, showingRevision]);
}
function KeyboardShortcutResponder(props) {
  const {
    actionsBoxElement,
    activeIndex,
    as = "div",
    children,
    id,
    onActionStart,
    onKeyDown,
    rootRef,
    states,
    ...rest
  } = props;
  const activeAction = states[activeIndex];
  const handleKeyDown = useCallback(event => {
    const matchingStates = states.filter(state => state.shortcut && isHotkey(state.shortcut, event));
    const matchingState = matchingStates[0];
    if (matchingStates.length > 1) {
      console.warn('Keyboard shortcut conflict: More than one document action matches the shortcut "'.concat(matchingState.shortcut, '"'));
    }
    if (matchingState && !matchingState.disabled && matchingState.onHandle) {
      event.preventDefault();
      matchingState.onHandle();
      onActionStart(states.indexOf(matchingState));
      return;
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [onActionStart, onKeyDown, states]);
  return createElement(as, {
    id,
    onKeyDown: handleKeyDown,
    tabIndex: -1,
    ...rest,
    ref: rootRef
  }, [children, activeAction && activeAction.dialog && /* @__PURE__ */jsx(LegacyLayerProvider, {
    zOffset: "paneFooter",
    children: /* @__PURE__ */jsx(ActionStateDialog, {
      dialog: activeAction.dialog,
      referenceElement: actionsBoxElement
    })
  })]);
}
const DocumentActionShortcuts = React.memo(props => {
  const {
    actionsBoxElement,
    as = "div",
    children,
    ...rest
  } = props;
  const {
    actions,
    editState
  } = useDocumentPane();
  const [activeIndex, setActiveIndex] = useState(-1);
  const onActionStart = useCallback(idx => {
    setActiveIndex(idx);
  }, []);
  const actionProps = useMemo(() => editState && {
    ...editState,
    // @todo: what to call here?
    onComplete: () => void 0,
    // @todo: get revision string
    revision: void 0
  }, [editState]);
  if (!actionProps || !actions) return null;
  return /* @__PURE__ */jsx(RenderActionCollectionState, {
    actionProps,
    actions,
    children: _ref21 => {
      let {
        states
      } = _ref21;
      return /* @__PURE__ */jsx(KeyboardShortcutResponder, {
        ...rest,
        activeIndex,
        actionsBoxElement,
        as,
        onActionStart,
        states,
        children
      });
    }
  });
});
DocumentActionShortcuts.displayName = "DocumentActionShortcuts";
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1;
const DIALOG_PROVIDER_POSITION = [
// We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
"fixed", "fixed",
// And we use the `position: absolute` strategy (within panes) on wide screens.
"absolute"];
const StyledChangeConnectorRoot = styled(ChangeConnectorRoot)(_a$1 || (_a$1 = __template$1(["\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  min-height: 0;\n  min-width: 0;\n"])));
const DocumentPane = memo(function DocumentPane2(props) {
  const {
    name: parentSourceName
  } = useSource();
  return /* @__PURE__ */jsx(SourceProvider, {
    name: props.pane.source || parentSourceName,
    children: /* @__PURE__ */jsx(DocumentPaneInner, {
      ...props
    })
  });
});
function DocumentPaneInner(props) {
  var _a2;
  const {
    pane,
    paneKey
  } = props;
  const {
    resolveNewDocumentOptions
  } = useSource().document;
  const paneRouter = usePaneRouter();
  const options = usePaneOptions(pane.options, paneRouter.params);
  const {
    documentType,
    isLoaded: isDocumentLoaded
  } = useDocumentType(options.id, options.type);
  const templateItems = useMemo(() => {
    return resolveNewDocumentOptions({
      type: "document",
      documentId: options.id,
      schemaType: options.type
    });
  }, [options.id, options.type, resolveNewDocumentOptions]);
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({
    templateItems
  });
  const isLoaded = isDocumentLoaded && !isTemplatePermissionsLoading;
  const providerProps = useMemo(() => {
    return isLoaded && documentType && options.type !== documentType ? mergeDocumentType(props, options, documentType) : props;
  }, [props, documentType, isLoaded, options]);
  const {
    ReferenceChildLink,
    handleEditReference,
    groupIndex,
    routerPanesState
  } = paneRouter;
  const childParams = ((_a2 = routerPanesState[groupIndex + 1]) == null ? void 0 : _a2[0].params) || {};
  const routerPanesStateLength = routerPanesState.length;
  const {
    parentRefPath
  } = childParams;
  const activePath = useMemo(() => {
    return parentRefPath ? {
      path: fromString(parentRefPath),
      state:
      // eslint-disable-next-line no-nested-ternary
      groupIndex >= routerPanesStateLength - 1 ? "none" : groupIndex >= routerPanesStateLength - 2 ? "selected" : "pressed"
    } : {
      path: [],
      state: "none"
    };
  }, [parentRefPath, groupIndex, routerPanesStateLength]);
  if (options.type === "*" && !isLoaded) {
    return /* @__PURE__ */jsx(LoadingPane, {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: "Loading document\u2026"
    });
  }
  if (!documentType) {
    return /* @__PURE__ */jsx(ErrorPane, {
      flex: 2.5,
      minWidth: 320,
      paneKey,
      title: /* @__PURE__ */jsx(Fragment, {
        children: "The document was not found"
      }),
      children: /* @__PURE__ */jsx(Stack, {
        space: 4,
        children: /* @__PURE__ */jsxs(Text, {
          as: "p",
          children: ["The document type is not defined, and a document with the ", /* @__PURE__ */jsx("code", {
            children: options.id
          }), " ", "identifier could not be found."]
        })
      })
    });
  }
  return /* @__PURE__ */jsx(DocumentPaneProvider, {
    ...providerProps,
    children: /* @__PURE__ */jsx(ReferenceInputOptionsProvider, {
      EditReferenceLinkComponent: ReferenceChildLink,
      onEditReference: handleEditReference,
      initialValueTemplateItems: templatePermissions,
      activePath,
      children: /* @__PURE__ */jsx(InnerDocumentPane, {})
    })
  }, "".concat(documentType, "-").concat(options.id));
}
function usePaneOptions(options) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const templates = useTemplates();
  return useMemo(() => {
    if (options.type && options.type !== "*") {
      return options;
    }
    const templateName = options.template || params.template;
    const template = templateName ? templates.find(t => t.id === templateName) : void 0;
    const documentType = template == null ? void 0 : template.schemaType;
    if (!documentType) {
      return options;
    }
    return {
      ...options,
      type: documentType
    };
  }, [options, params.template, templates]);
}
function mergeDocumentType(props, options, documentType) {
  return {
    ...props,
    pane: {
      ...props.pane,
      options: {
        ...options,
        type: documentType
      }
    }
  };
}
function InnerDocumentPane() {
  const {
    changesOpen,
    documentType,
    inspector,
    inspectOpen,
    onFocus,
    onPathOpen,
    onHistoryOpen,
    onKeyUp,
    paneKey,
    schemaType,
    value
  } = useDocumentPane();
  const {
    collapsed: layoutCollapsed
  } = usePaneLayout();
  const zOffsets = useZIndex();
  const [rootElement, setRootElement] = useState(null);
  const [footerElement, setFooterElement] = useState(null);
  const [actionsBoxElement, setActionsBoxElement] = useState(null);
  const [documentPanelPortalElement, setDocumentPanelPortalElement] = useState(null);
  const footerRect = useElementRect(footerElement);
  const footerH = footerRect == null ? void 0 : footerRect.height;
  const onConnectorSetFocus = useCallback(path => {
    onPathOpen(path);
    onFocus(path);
  }, [onPathOpen, onFocus]);
  const currentMinWidth = DOCUMENT_PANEL_INITIAL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0);
  const minWidth = DOCUMENT_PANEL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0);
  if (!schemaType) {
    return /* @__PURE__ */jsx(ErrorPane, {
      currentMinWidth,
      flex: 2.5,
      minWidth,
      paneKey,
      title: /* @__PURE__ */jsxs(Fragment, {
        children: ["Unknown document type: ", /* @__PURE__ */jsx("code", {
          children: documentType
        })]
      }),
      tone: "caution",
      children: /* @__PURE__ */jsxs(Stack, {
        space: 4,
        children: [documentType && /* @__PURE__ */jsxs(Text, {
          as: "p",
          children: ["This document has the schema type ", /* @__PURE__ */jsx("code", {
            children: documentType
          }), ", which is not defined as a type in the local content studio schema."]
        }), !documentType && /* @__PURE__ */jsx(Text, {
          as: "p",
          children: "This document does not exist, and no schema type was specified for it."
        }), isDev && value && /* @__PURE__ */jsxs(Fragment, {
          children: [/* @__PURE__ */jsx(Text, {
            as: "p",
            children: "Here is the JSON representation of the document:"
          }), /* @__PURE__ */jsx(Card, {
            padding: 3,
            overflow: "auto",
            radius: 2,
            shadow: 1,
            tone: "inherit",
            children: /* @__PURE__ */jsx(Code, {
              language: "json",
              size: [1, 1, 2],
              children: JSON.stringify(value, null, 2)
            })
          })]
        })]
      })
    });
  }
  return /* @__PURE__ */jsxs(DocumentActionShortcuts, {
    actionsBoxElement,
    as: Pane,
    currentMinWidth,
    "data-testid": "document-pane",
    flex: 2.5,
    id: paneKey,
    minWidth,
    onKeyUp,
    rootRef: setRootElement,
    children: [/* @__PURE__ */jsx(DialogProvider, {
      position: DIALOG_PROVIDER_POSITION,
      zOffset: zOffsets.portal,
      children: /* @__PURE__ */jsx(Flex, {
        direction: "column",
        flex: 1,
        height: layoutCollapsed ? void 0 : "fill",
        children: /* @__PURE__ */jsx(StyledChangeConnectorRoot, {
          "data-testid": "change-connector-root",
          isReviewChangesOpen: changesOpen,
          onOpenReviewChanges: onHistoryOpen,
          onSetFocus: onConnectorSetFocus,
          children: /* @__PURE__ */jsx(DocumentPanel, {
            footerHeight: footerH || null,
            isInspectOpen: inspectOpen,
            rootElement,
            setDocumentPanelPortalElement
          })
        })
      })
    }), /* @__PURE__ */jsx(PortalProvider, {
      __unstable_elements: {
        [DOCUMENT_PANEL_PORTAL_ELEMENT]: documentPanelPortalElement
      },
      children: /* @__PURE__ */jsx(DialogProvider, {
        position: DIALOG_PROVIDER_POSITION,
        zOffset: zOffsets.portal,
        children: /* @__PURE__ */jsx(PaneFooter, {
          ref: setFooterElement,
          children: /* @__PURE__ */jsx(DocumentStatusBar, {
            actionsBoxRef: setActionsBoxElement
          })
        })
      })
    }), /* @__PURE__ */jsx(DocumentOperationResults, {})]
  });
}
function NoDocumentTypesScreen() {
  return /* @__PURE__ */jsx(Card, {
    height: "fill",
    children: /* @__PURE__ */jsx(Flex, {
      align: "center",
      height: "fill",
      justify: "center",
      padding: 4,
      sizing: "border",
      children: /* @__PURE__ */jsx(Container, {
        width: 0,
        children: /* @__PURE__ */jsx(Card, {
          padding: 4,
          radius: 2,
          shadow: 1,
          tone: "caution",
          children: /* @__PURE__ */jsxs(Flex, {
            children: [/* @__PURE__ */jsx(Box, {
              children: /* @__PURE__ */jsx(Text, {
                size: 1,
                children: /* @__PURE__ */jsx(WarningOutlineIcon, {})
              })
            }), /* @__PURE__ */jsxs(Stack, {
              flex: 1,
              marginLeft: 3,
              space: 3,
              children: [/* @__PURE__ */jsx(Text, {
                as: "h1",
                size: 1,
                weight: "bold",
                children: "No document types"
              }), /* @__PURE__ */jsx(Text, {
                as: "p",
                muted: true,
                size: 1,
                children: "Please define at least one document type in your schema."
              }), /* @__PURE__ */jsx(Text, {
                as: "p",
                muted: true,
                size: 1,
                children: /* @__PURE__ */jsx("a", {
                  href: "https://www.sanity.io/docs/create-a-schema-and-configure-sanity-studio",
                  target: "_blank",
                  rel: "noreferrer",
                  children: "Learn how to add a document type \u2192"
                })
              })]
            })]
          })
        })
      })
    })
  });
}
const DocumentTitle = props => {
  const {
    documentId,
    documentType
  } = props;
  const editState = useEditState(documentId, documentType);
  const schema = useSchema();
  const isNewDocument = !(editState == null ? void 0 : editState.published) && !(editState == null ? void 0 : editState.draft);
  const documentValue = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published);
  const schemaType = schema.get(documentType);
  const {
    value,
    isLoading: previewValueIsLoading
  } = unstable_useValuePreview({
    enabled: true,
    schemaType,
    value: documentValue
  });
  const documentTitle = isNewDocument ? "New ".concat((schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)) : (value == null ? void 0 : value.title) || "Untitled";
  const settled = editState.ready && !previewValueIsLoading;
  const newTitle = useConstructDocumentTitle(documentTitle);
  useEffect(() => {
    if (!settled) return;
    document.title = newTitle;
  }, [documentTitle, settled, newTitle]);
  return null;
};
const PassthroughTitle = props => {
  const {
    title
  } = props;
  const newTitle = useConstructDocumentTitle(title);
  useEffect(() => {
    document.title = newTitle;
  }, [newTitle, title]);
  return null;
};
const DeskTitle = props => {
  const {
    resolvedPanes
  } = props;
  if (!(resolvedPanes == null ? void 0 : resolvedPanes.length)) return null;
  const lastPane = resolvedPanes[resolvedPanes.length - 1];
  if (isLoadingPane(lastPane)) {
    return /* @__PURE__ */jsx(PassthroughTitle, {});
  }
  if (isDocumentPane(lastPane)) {
    if (lastPane == null ? void 0 : lastPane.title) {
      return /* @__PURE__ */jsx(PassthroughTitle, {
        title: lastPane.title
      });
    }
    return /* @__PURE__ */jsx(DocumentTitle, {
      documentId: lastPane.options.id,
      documentType: lastPane.options.type
    });
  }
  return /* @__PURE__ */jsx(PassthroughTitle, {
    title: lastPane == null ? void 0 : lastPane.title
  });
};
function useConstructDocumentTitle(activeTitle) {
  const deskToolBaseTitle = useDeskTool().structureContext.title;
  return [activeTitle, deskToolBaseTitle].filter(title => title).join(" | ");
}
function isDocumentPane(pane) {
  return pane !== LOADING_PANE && pane.type === "document";
}
function isLoadingPane(pane) {
  return pane === LOADING_PANE;
}
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a;
const StyledPaneLayout = styled(PaneLayout)(_a || (_a = __template(["\n  min-height: 100%;\n  min-width: 320px;\n"])));
const isSaveHotkey = isHotkey("mod+s");
const DeskTool = memo(function DeskTool2(_ref22) {
  let {
    onPaneChange
  } = _ref22;
  var _a2;
  const {
    push: pushToast
  } = useToast();
  const schema = useSchema();
  const {
    layoutCollapsed,
    setLayoutCollapsed
  } = useDeskTool();
  const {
    paneDataItems,
    resolvedPanes
  } = useResolvedPanes();
  const isResolvingIntent = useRouterState(useCallback(routerState => typeof routerState.intent === "string", []));
  const {
    sanity: {
      media
    }
  } = useTheme();
  const [portalElement, setPortalElement] = useState(null);
  const handleRootCollapse = useCallback(() => setLayoutCollapsed(true), [setLayoutCollapsed]);
  const handleRootExpand = useCallback(() => setLayoutCollapsed(false), [setLayoutCollapsed]);
  useEffect(() => {
    if (resolvedPanes.length) {
      onPaneChange(resolvedPanes);
    }
  }, [onPaneChange, resolvedPanes]);
  useEffect(() => {
    const handleGlobalKeyDown = event => {
      if (isSaveHotkey(event)) {
        event.preventDefault();
        pushToast({
          closable: true,
          id: "auto-save-message",
          status: "info",
          title: "Your work is automatically saved!",
          duration: 4e3
        });
      }
    };
    window.addEventListener("keydown", handleGlobalKeyDown);
    return () => window.removeEventListener("keydown", handleGlobalKeyDown);
  }, [pushToast]);
  const hasDefinedDocumentTypes = (_a2 = schema._original) == null ? void 0 : _a2.types.some(_isCustomDocumentTypeDefinition);
  if (!hasDefinedDocumentTypes) {
    return /* @__PURE__ */jsx(NoDocumentTypesScreen, {});
  }
  return /* @__PURE__ */jsxs(PortalProvider, {
    element: portalElement || null,
    children: [/* @__PURE__ */jsxs(StyledPaneLayout, {
      flex: 1,
      height: layoutCollapsed ? void 0 : "fill",
      minWidth: media[1],
      onCollapse: handleRootCollapse,
      onExpand: handleRootExpand,
      children: [paneDataItems.map(_ref23 => {
        let {
          active,
          childItemId,
          groupIndex,
          itemId,
          key: paneKey,
          pane,
          index: paneIndex,
          params: paneParams,
          path,
          payload,
          siblingIndex,
          selected
        } = _ref23;
        return /* @__PURE__ */jsx(Fragment$1, {
          children: pane === LOADING_PANE ? /* @__PURE__ */jsx(LoadingPane, {
            paneKey,
            path,
            selected
          }) : /* @__PURE__ */jsx(DeskToolPane, {
            active,
            groupIndex,
            index: paneIndex,
            pane,
            childItemId,
            itemId,
            paneKey,
            params: paneParams,
            payload,
            path,
            selected,
            siblingIndex
          })
        }, "".concat(pane === LOADING_PANE ? "loading" : pane.type, "-").concat(paneIndex));
      }), paneDataItems.length <= 1 && isResolvingIntent && /* @__PURE__ */jsx(LoadingPane, {
        paneKey: "intent-resolver"
      })]
    }), /* @__PURE__ */jsx(DeskTitle, {
      resolvedPanes
    }), /* @__PURE__ */jsx("div", {
      "data-portal": "",
      ref: setPortalElement
    })]
  });
});
function DeskToolBoundary(_ref24) {
  let {
    tool: {
      options
    }
  } = _ref24;
  const {
    unstable_sources: sources
  } = useWorkspace();
  const [firstSource] = sources;
  const {
    source,
    defaultDocumentNode,
    structure
  } = options || {};
  useEffect(() => {
    setActivePanes([]);
    return () => setActivePanes([]);
  }, []);
  const [{
    error
  }, setError] = useState({
    error: null
  });
  if (error) return /* @__PURE__ */jsx(StructureError, {
    error
  });
  return /* @__PURE__ */jsx(ErrorBoundary, {
    onCatch: setError,
    children: /* @__PURE__ */jsx(SourceProvider, {
      name: source || firstSource.name,
      children: /* @__PURE__ */jsxs(DeskToolProvider, {
        defaultDocumentNode,
        structure,
        children: [/* @__PURE__ */jsx(DeskTool, {
          onPaneChange: setActivePanes
        }), /* @__PURE__ */jsx(IntentResolver, {})]
      })
    })
  });
}
var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  default: DeskToolBoundary
});
export { DocumentPane, index, useDeskToolSetting };
//# sourceMappingURL=index-dd34e89c.js.map
