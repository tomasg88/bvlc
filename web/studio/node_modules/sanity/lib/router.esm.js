import { jsx } from 'react/jsx-runtime';
import React, { useContext, useCallback, useMemo, forwardRef } from 'react';
import debug$1 from 'debug';
import flatten from 'lodash/flatten.js';
import difference from 'lodash/difference.js';
import intersection from 'lodash/intersection.js';
import isPlainObject from 'lodash/isPlainObject.js';
import pick from 'lodash/pick.js';
import identity from 'lodash/identity.js';
const RouterContext = React.createContext(null);
function useRouter() {
  const router = useContext(RouterContext);
  if (!router) {
    throw new Error("Router: missing context value");
  }
  return router;
}
function isLeftClickEvent(event) {
  return event.button === 0;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function useLink(options) {
  const {
    onClick: onClickProp,
    href,
    target,
    replace = false
  } = options;
  const {
    navigateUrl
  } = useRouter();
  const onClick = useCallback(event => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (!href) return;
    if (onClickProp) {
      onClickProp(event);
    }
    if (isModifiedEvent(event) || !isLeftClickEvent(event)) {
      return;
    }
    if (target) {
      return;
    }
    event.preventDefault();
    navigateUrl({
      path: href,
      replace
    });
  }, [href, navigateUrl, onClickProp, replace, target]);
  return {
    onClick
  };
}
function useIntentLink(options) {
  const {
    intent,
    onClick: onClickProp,
    params,
    replace,
    target
  } = options;
  const {
    resolveIntentLink
  } = useRouter();
  const href = useMemo(() => resolveIntentLink(intent, params), [intent, params, resolveIntentLink]);
  const {
    onClick
  } = useLink({
    href,
    onClick: onClickProp,
    replace,
    target
  });
  return {
    onClick,
    href
  };
}
const IntentLink = forwardRef(function IntentLink2(props, ref) {
  const {
    intent,
    params,
    target,
    ...restProps
  } = props;
  const {
    onClick,
    href
  } = useIntentLink({
    intent,
    params,
    target,
    onClick: props.onClick
  });
  return /* @__PURE__ */jsx("a", {
    ...restProps,
    href,
    onClick,
    ref,
    target
  });
});
const Link = forwardRef(function Link2(props, ref) {
  const {
    onClick: onClickProp,
    href,
    target,
    replace,
    ...restProps
  } = props;
  const {
    onClick
  } = useLink({
    onClick: onClickProp,
    href,
    target,
    replace
  });
  return /* @__PURE__ */jsx("a", {
    ...restProps,
    onClick,
    href,
    target,
    ref
  });
});
const _hasOWn = Object.prototype.hasOwnProperty;
const hasOwn = _hasOWn.call.bind(_hasOWn);
function isEmpty(object) {
  for (const key in object) {
    if (hasOwn(object, key)) {
      return false;
    }
  }
  return true;
}
function addScope(routerState, scope, scopedState) {
  return scopedState && {
    ...routerState,
    [scope]: scopedState
  };
}
function RouteScope(props) {
  const {
    children,
    scope
  } = props;
  const parent = useRouter();
  const {
    resolvePathFromState: parent_resolvePathFromState,
    navigate: parent_navigate
  } = parent;
  const resolvePathFromState = useCallback(nextState => {
    const nextStateScoped = isEmpty(nextState) ? {} : addScope(parent.state, scope, nextState);
    return parent_resolvePathFromState(nextStateScoped);
  }, [parent_resolvePathFromState, parent.state, scope]);
  const navigate = useCallback((nextState, options) => {
    const nextScopedState = addScope(parent.state, scope, nextState);
    parent_navigate(nextScopedState, options);
  }, [parent_navigate, parent.state, scope]);
  const scopedRouter = useMemo(() => ({
    ...parent,
    navigate,
    resolvePathFromState,
    state: parent.state[scope]
  }), [navigate, parent, resolvePathFromState, scope]);
  return /* @__PURE__ */jsx(RouterContext.Provider, {
    value: scopedRouter,
    children
  });
}
function RouterProvider(props) {
  const {
    onNavigate,
    router: routerProp,
    state
  } = props;
  const resolveIntentLink = useCallback((intentName, parameters) => {
    const [params, payload] = Array.isArray(parameters) ? parameters : [parameters];
    return routerProp.encode({
      intent: intentName,
      params,
      payload
    });
  }, [routerProp]);
  const resolvePathFromState = useCallback(nextState => {
    return routerProp.encode(nextState);
  }, [routerProp]);
  const navigate = useCallback(function (nextState) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    onNavigate({
      path: resolvePathFromState(nextState),
      replace: options.replace
    });
  }, [onNavigate, resolvePathFromState]);
  const navigateIntent = useCallback(function (intentName, params) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    onNavigate({
      path: resolveIntentLink(intentName, params),
      replace: options.replace
    });
  }, [onNavigate, resolveIntentLink]);
  const router = useMemo(() => ({
    navigate,
    navigateIntent,
    navigateUrl: onNavigate,
    resolveIntentLink,
    resolvePathFromState,
    state
  }), [navigate, navigateIntent, onNavigate, resolveIntentLink, resolvePathFromState, state]);
  return /* @__PURE__ */jsx(RouterContext.Provider, {
    value: router,
    children: props.children
  });
}
const EMPTY_STATE$1 = {};
function useStateLink(options) {
  const {
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex = false
  } = options;
  if (state && toIndex) {
    throw new Error("Passing both `state` and `toIndex={true}` as props to StateLink is invalid");
  }
  if (!state && !toIndex) {
    console.error(new Error("No state passed to StateLink. If you want to link to an empty state, its better to use the the `toIndex` property"));
  }
  const {
    resolvePathFromState
  } = useRouter();
  const href = useMemo(() => resolvePathFromState(toIndex ? EMPTY_STATE$1 : state || EMPTY_STATE$1), [resolvePathFromState, state, toIndex]);
  const {
    onClick
  } = useLink({
    href,
    onClick: onClickProp,
    replace,
    target
  });
  return {
    onClick,
    href
  };
}
const StateLink = forwardRef(function StateLink2(props, ref) {
  const {
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex = false,
    ...restProps
  } = props;
  const {
    onClick,
    href
  } = useStateLink({
    onClick: onClickProp,
    replace,
    state,
    target,
    toIndex
  });
  return /* @__PURE__ */jsx("a", {
    ...restProps,
    href,
    onClick,
    ref
  });
});
const VALID_PARAM_SEGMENT = /^[a-zA-Z0-9_-]+$/;
function createSegment(segment) {
  if (!segment) {
    return null;
  }
  if (segment.startsWith(":")) {
    const paramName = segment.substring(1);
    if (!VALID_PARAM_SEGMENT.test(paramName)) {
      const addendum = segment.includes("*") ? " Splats are not supported. Consider using child routes instead" : "";
      console.error(new Error('Warning: Param segments "'.concat(segment, '" includes invalid characters.').concat(addendum)));
    }
    return {
      type: "param",
      name: paramName
    };
  }
  return {
    type: "dir",
    name: segment
  };
}
function _parseRoute(route) {
  const [pathname] = route.split("?");
  const segments = pathname.split("/").map(createSegment).filter(Boolean);
  return {
    raw: route,
    segments
  };
}
const debug = debug$1("state-router");
function arrayify(val) {
  if (Array.isArray(val)) {
    return val;
  }
  return val ? [val] : [];
}
function matchPath(node, path) {
  const parts = path.split("/").filter(Boolean);
  const segmentsLength = node.route.segments.length;
  if (parts.length < segmentsLength) {
    return null;
  }
  const state = {};
  const isMatching = node.route.segments.every((segment, i) => {
    if (segment.type === "dir") {
      return segment.name === parts[i];
    }
    const transform = node.transform && node.transform[segment.name];
    state[segment.name] = transform ? transform.toState(parts[i]) : parts[i];
    return true;
  });
  if (!isMatching) {
    return null;
  }
  const rest = parts.slice(segmentsLength);
  let childState = null;
  const children = typeof node.children === "function" ? arrayify(node.children(state)) : node.children;
  children.some(childNode => {
    if (childNode) {
      childState = matchPath(childNode, rest.join("/"));
      return childState;
    }
    return void 0;
  });
  if (rest.length > 0 && !childState) {
    return null;
  }
  const mergedState = {
    ...state,
    ...(childState || {})
  };
  return node.scope ? {
    [node.scope]: mergedState
  } : mergedState;
}
function _resolveStateFromPath(node, path) {
  debug("resolving state from path %s", path);
  const pathMatch = matchPath(node, path.split("?")[0]);
  debug("resolved: %o", pathMatch || null);
  return pathMatch || null;
}
function isRecord(value) {
  return isPlainObject(value);
}
function createMatchResult(nodes, missing, remaining) {
  return {
    nodes,
    missing,
    remaining
  };
}
function _findMatchingRoutes(node, _state) {
  if (!_state) {
    return createMatchResult([], [], []);
  }
  const state = node.scope ? _state[node.scope] : _state;
  const requiredParams = node.route.segments.filter(seg => seg.type === "param").map(seg => seg.name);
  const stateKeys = isRecord(state) ? Object.keys(state) : [];
  const consumedParams = intersection(stateKeys, requiredParams);
  const missingParams = difference(requiredParams, consumedParams);
  const remainingParams = difference(stateKeys, consumedParams);
  if (missingParams.length > 0) {
    return createMatchResult([], missingParams, []);
  }
  if (remainingParams.length === 0) {
    return createMatchResult([node], [], []);
  }
  const children = arrayify((typeof node.children === "function" ? node.children(isRecord(state) ? state : {}) : node.children) || []);
  if (remainingParams.length > 0 && children.length === 0) {
    return createMatchResult([], remainingParams, []);
  }
  const remainingState = pick(state, remainingParams);
  let matchingChild = {
    nodes: [],
    remaining: [],
    missing: []
  };
  arrayify(children).some(childNode => {
    matchingChild = _findMatchingRoutes(childNode, remainingState);
    return matchingChild.nodes.length > 0;
  });
  if (matchingChild.nodes.length === 0) {
    return createMatchResult([], missingParams, remainingParams);
  }
  return createMatchResult([node, ...matchingChild.nodes], matchingChild.missing, matchingChild.remaining);
}
function _resolvePathFromState(node, state) {
  debug("Resolving path from state %o", state);
  const match = _findMatchingRoutes(node, state);
  if (match.remaining.length > 0) {
    const remaining = match.remaining;
    throw new Error("Unable to find matching route for state. Could not map the following state key".concat(remaining.length == 1 ? "" : "s", " to a valid url: ").concat(remaining.join(", ")));
  }
  if (match.nodes.length === 0) {
    throw new Error("Unable to resolve path from given state: ".concat(JSON.stringify(state)));
  }
  let scopedState = state;
  const relative = flatten(match.nodes.map(matchNode => {
    if (matchNode.scope && matchNode.scope in scopedState) {
      scopedState = scopedState[matchNode.scope];
    }
    return matchNode.route.segments.map(segment => {
      if (segment.type === "dir") {
        return segment.name;
      }
      const transform = matchNode.transform && matchNode.transform[segment.name];
      return transform ? transform.toPath(scopedState[segment.name]) : scopedState[segment.name];
    });
  })).join("/");
  debug("Resolved to /%s", relative);
  return "/".concat(relative);
}
function decodeJsonParams() {
  let pathsegment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  const segment = decodeURIComponent(pathsegment);
  if (!segment) {
    return {};
  }
  try {
    return JSON.parse(atob(segment));
  } catch (err) {}
  try {
    return JSON.parse(segment);
  } catch (err) {
    console.warn("Failed to parse JSON parameters");
  }
  return {};
}
function encodeJsonParams(params) {
  return params ? btoa(JSON.stringify(params)) : "";
}
function decodeParams(pathSegment) {
  return pathSegment.split(";").reduce((params, pair) => {
    const [key, value] = pair.split("=");
    params[decodeURIComponent(key)] = decodeURIComponent(value);
    return params;
  }, {});
}
function encodeParams(params) {
  return Object.entries(params).filter(_ref => {
    let [, value] = _ref;
    return value !== void 0 && value !== null;
  }).map(_ref2 => {
    let [key, value] = _ref2;
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  }).join(";");
}
const route = {
  create: (routeOrOpts, childrenOrOpts, children) => createNode(normalizeArgs(routeOrOpts, childrenOrOpts, children)),
  intents: base => {
    const basePath = normalize(base).join("/");
    return route.create("".concat(basePath, "/:intent"), [route.create(":params", {
      transform: {
        params: {
          toState: decodeParams,
          toPath: encodeParams
        }
      }
    }, [route.create(":payload", {
      transform: {
        payload: {
          toState: decodeJsonParams,
          toPath: encodeJsonParams
        }
      }
    })])]);
  },
  scope: function (scopeName) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    const options = normalizeArgs(...rest);
    return createNode({
      ...options,
      scope: scopeName
    });
  }
};
function normalizeChildren(children) {
  if (Array.isArray(children) || typeof children === "function") {
    return children;
  }
  return children ? [children] : [];
}
function isRoute(val) {
  return val && "_isRoute" in val;
}
function normalizeArgs(path, childrenOrOpts, children) {
  if (typeof path === "object") {
    return path;
  }
  if (Array.isArray(childrenOrOpts) || typeof childrenOrOpts === "function" || isRoute(childrenOrOpts)) {
    return {
      path,
      children: normalizeChildren(childrenOrOpts)
    };
  }
  if (children) {
    return {
      path,
      ...childrenOrOpts,
      children: normalizeChildren(children)
    };
  }
  return {
    path,
    ...childrenOrOpts
  };
}
function normalize() {
  for (var _len2 = arguments.length, paths = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    paths[_key2] = arguments[_key2];
  }
  return paths.reduce((acc, path) => acc.concat(path.split("/")), []).filter(Boolean);
}
const EMPTY_STATE = {};
function isRoot(pathname) {
  return pathname.split("/").every(segment => !segment);
}
function createNode(options) {
  const {
    path,
    scope,
    transform,
    children
  } = options;
  if (!path) {
    throw new TypeError("Missing path");
  }
  const parsedRoute = _parseRoute(path);
  return {
    _isRoute: true,
    // todo: make a Router class instead
    scope,
    route: parsedRoute,
    children: children || [],
    transform,
    encode(state) {
      return _resolvePathFromState(this, state);
    },
    decode(_path) {
      return _resolveStateFromPath(this, _path);
    },
    isRoot,
    isNotFound(pathname) {
      return this.decode(pathname) === null;
    },
    getBasePath() {
      return this.encode(EMPTY_STATE);
    },
    getRedirectBase(pathname) {
      if (isRoot(pathname)) {
        const basePath = this.getBasePath();
        if (pathname !== basePath) {
          return basePath;
        }
      }
      return null;
    }
  };
}
function useRouterState() {
  let selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;
  const {
    state
  } = useRouter();
  return useMemo(() => selector(state), [selector, state]);
}
function withRouter(Component) {
  function WithRouter2(props) {
    const router = useRouter();
    return /* @__PURE__ */jsx(Component, {
      ...props,
      router
    });
  }
  WithRouter2.displayName = "withRouter(".concat(Component.displayName || Component.name, ")");
  return WithRouter2;
}
const WithRouter = withRouter(props => props.children(props.router));
export { IntentLink, Link, RouteScope, RouterContext, RouterProvider, StateLink, WithRouter, route, useIntentLink, useLink, useRouter, useRouterState, useStateLink, withRouter };
//# sourceMappingURL=router.esm.js.map
