/// <reference types="react" />

import {ArrayDiff as ArrayDiff_2} from '@sanity/diff'
import {ArraySchemaType} from '@sanity/types'
import {AssetMetadataType} from '@sanity/types'
import {AssetSource} from '@sanity/types'
import {AssetSourceSpec} from '@sanity/types'
import {AvatarPosition} from '@sanity/ui'
import {AvatarSize} from '@sanity/ui'
import {AvatarStatus} from '@sanity/ui'
import {BifurClient} from '@sanity/bifur-client'
import {BlockDecoratorDefinition} from '@sanity/types'
import {BlockListDefinition} from '@sanity/types'
import {BlockStyleDefinition} from '@sanity/types'
import {BooleanDiff as BooleanDiff_2} from '@sanity/diff'
import {BooleanSchemaType} from '@sanity/types'
import {BoxProps} from '@sanity/ui'
import type {BrowserHistory} from 'history'
import {ButtonMode} from '@sanity/ui'
import {ButtonProps} from '@sanity/ui'
import {ButtonTone} from '@sanity/ui'
import {CardProps} from '@sanity/ui'
import {ClientConfig} from '@sanity/client'
import type {ClientPerspective} from '@sanity/client'
import {ColorHueKey} from '@sanity/color'
import {ColorTintKey} from '@sanity/color'
import {ColorTints} from '@sanity/color'
import {ComponentProps} from 'react'
import {ComponentType} from 'react'
import {ConditionalProperty} from '@sanity/types'
import {Context} from 'react'
import {CrossDatasetReferenceSchemaType} from '@sanity/types'
import {CrossDatasetReferenceValue} from '@sanity/types'
import {CSSProperties} from 'react'
import {CurrentUser} from '@sanity/types'
import {Diff as Diff_2} from '@sanity/diff'
import {ElementType} from 'react'
import {ExecutionProps} from 'styled-components'
import {File as File_2} from '@sanity/types'
import {FileAsset} from '@sanity/types'
import {FileSchemaType} from '@sanity/types'
import {FileValue} from '@sanity/types'
import {FocusEventHandler} from 'react'
import {FormEventHandler} from 'react'
import {FormNodeValidation} from '@sanity/types'
import {GeopointValue} from '@sanity/types'
import type {HashHistory} from 'history'
import type {History as History_2} from 'history'
import {HotkeyOptions} from '@sanity/portable-text-editor'
import {HotkeysProps as HotkeysProps_2} from '@sanity/ui'
import {HTMLProps} from 'react'
import {Image as Image_2} from '@sanity/types'
import {ImageAsset} from '@sanity/types'
import {ImageSchemaType} from '@sanity/types'
import imageUrlBuilder from '@sanity/image-url'
import type {ImageUrlFitMode} from '@sanity/types'
import {ImageValue} from '@sanity/types'
import {IndexTuple} from '@sanity/types'
import type {InitialValueProperty} from '@sanity/types'
import {InitialValueResolverContext} from '@sanity/types'
import {IntrinsicTypeName} from '@sanity/types'
import {ItemDiff as ItemDiff_2} from '@sanity/diff'
import {JSX as JSX_2} from 'react'
import {JSXElementConstructor} from 'react'
import {KeyedSegment} from '@sanity/types'
import {MemoizedFunction} from 'lodash'
import type {MemoryHistory} from 'history'
import type {MendozaEffectPair} from '@sanity/types'
import {MenuButtonProps} from '@sanity/ui'
import {MutableRefObject} from 'react'
import {Mutation} from '@sanity/mutator'
import {NullDiff as NullDiff_2} from '@sanity/diff'
import {NumberDiff as NumberDiff_2} from '@sanity/diff'
import {NumberSchemaType} from '@sanity/types'
import {ObjectDiff as ObjectDiff_2} from '@sanity/diff'
import {ObjectField} from '@sanity/types'
import {ObjectFieldType} from '@sanity/types'
import {ObjectSchemaType} from '@sanity/types'
import {Observable} from 'rxjs'
import {OnCopyFn} from '@sanity/portable-text-editor'
import {OnPasteFn} from '@sanity/portable-text-editor'
import {OperatorFunction} from 'rxjs'
import {PatchOperations} from '@sanity/types'
import {Path} from '@sanity/types'
import {PathSegment} from '@sanity/types'
import {Placement} from '@sanity/ui'
import {PopoverProps} from '@sanity/ui'
import {PortableTextBlock} from '@sanity/types'
import {PortableTextObject} from '@sanity/types'
import {PortableTextTextBlock} from '@sanity/types'
import {PrepareViewOptions} from '@sanity/types'
import {PreviewConfig} from '@sanity/types'
import {PreviewValue} from '@sanity/types'
import {PropsWithChildren} from 'react'
import {default as React_2} from 'react'
import {ReactElement} from 'react'
import {ReactNode} from 'react'
import {RefAttributes} from 'react'
import {Reference} from '@sanity/types'
import {ReferenceSchemaType} from '@sanity/types'
import {ReferenceValue} from '@sanity/types'
import {ResizeObserverEntry as ResizeObserverEntry_2} from '@juggle/resize-observer'
import {ResponsivePaddingProps} from '@sanity/ui'
import {ResponsiveWidthProps} from '@sanity/ui'
import {Role} from '@sanity/types'
import type {RootTheme} from '@sanity/ui'
import {SanityClient} from '@sanity/client'
import {SanityDocument} from '@sanity/types'
import {SanityDocumentLike} from '@sanity/types'
import {Schema} from '@sanity/types'
import {SchemaType} from '@sanity/types'
import {SchemaTypeDefinition} from '@sanity/types'
import {ScrollToOptions as ScrollToOptions_2} from '@tanstack/react-virtual'
import {SlugSchemaType} from '@sanity/types'
import {SlugValue} from '@sanity/types'
import {SortOrdering} from '@sanity/types'
import {StringDiff as StringDiff_2} from '@sanity/diff'
import {StringSchemaType} from '@sanity/types'
import {StringSegmentChanged as StringSegmentChanged_2} from '@sanity/diff'
import {StringSegmentUnchanged as StringSegmentUnchanged_2} from '@sanity/diff'
import {Subject} from 'rxjs'
import {Subscriber} from 'nano-pubsub'
import {Text as Text_2} from '@sanity/ui'
import {TextProps} from '@sanity/ui'
import {TextSchemaType} from '@sanity/types'
import {ThemeColorSchemeKey} from '@sanity/ui'
import type {ThrottleSettings} from 'lodash'
import {TooltipProps} from '@sanity/ui'
import type {TransactionLogEventWithEffects} from '@sanity/types'
import {TransactionLogEventWithMutations} from '@sanity/types'
import {TypeChangeDiff as TypeChangeDiff_2} from '@sanity/diff'
import {UploadState} from '@sanity/types'
import {User} from '@sanity/types'
import {ValidationMarker} from '@sanity/types'

/** @internal */
export declare function __tmp_wrap_presenceStore(context: {
  bifur: BifurClient
  connectionStatusStore: ConnectionStatusStore
  userStore: UserStore
}): PresenceStore

/**
 * @hidden
 * @beta */
export declare interface ActionComponent<ActionProps> {
  (props: ActionProps): DocumentActionDescription | null
}

/** @internal */
export declare type ActionHook<T, K> = (args: T) => K | null

/** @internal */
export declare function ActiveWorkspaceMatcher({
  children,
  LoadingComponent,
  NotFoundComponent,
  unstable_history: historyProp,
}: ActiveWorkspaceMatcherProps): React_2.JSX.Element

/** @internal */
export declare const ActiveWorkspaceMatcherContext: Context<ActiveWorkspaceMatcherContextValue | null>

/** @internal */
export declare interface ActiveWorkspaceMatcherContextValue {
  activeWorkspace: WorkspaceSummary
  setActiveWorkspace: (workspaceName: string) => void
}

/** @internal */
export declare interface ActiveWorkspaceMatcherProps {
  children: React_2.ReactNode
  unstable_history?: RouterHistory
  NotFoundComponent: React_2.ComponentType<{
    onNavigateToDefaultWorkspace: () => void
  }>
  LoadingComponent: React_2.ComponentType
}

/**
 * @hidden
 * @beta */
export declare type Annotation = AnnotationDetails | null

/**
 * Annotation connected to a change
 *
 *
 * @hidden
 * @beta
 */
export declare type AnnotationDetails = {
  chunk: Chunk
  timestamp: string
  author: string
}

/**
 * @hidden
 * @beta */
export declare interface ApiConfig {
  projectId: string
  dataset: string
}

/** @internal */
export declare type ArrayDiff<V = unknown> = ArrayDiff_2<Annotation, V>

/**
 * @hidden
 * @public */
export declare interface ArrayFieldProps extends BaseFieldProps {
  schemaType: ArraySchemaType
  value: unknown[] | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  inputProps: ArrayOfObjectsInputProps
}

/**
 * These are the props an implementation of the ArrayFunctions component will receive
 *
 *
 * @hidden
 * @beta
 */
export declare interface ArrayInputFunctionsProps<Item, SchemaType extends ArraySchemaType> {
  children?: React_2.ReactNode
  onItemAppend: (itemValue: Item) => void
  onChange: (event: PatchEvent) => void
  onValueCreate: (type: SchemaType) => Item
  onItemPrepend: (itemValue: Item) => void
  readOnly?: boolean
  schemaType: SchemaType
  value?: Item[]
}

/**
 * @hidden
 * @beta */
export declare interface ArrayInputInsertEvent<Item> {
  items: Item[]
  position: 'before' | 'after'
  referenceItem: KeyedSegment | number
  skipInitialValue?: boolean
  open?: boolean
}

/**
 * @hidden
 * @beta */
export declare interface ArrayInputMoveItemEvent {
  fromIndex: number
  toIndex: number
}

/**
 * @hidden
 * @beta */
export declare interface ArrayItemError {
  kind: 'error'
  key: string
  index: number
  error: InvalidItemTypeError
}

/**
 * Diff extensions for presentational concerns
 *
 * @internal
 */
export declare interface ArrayItemMetadata {
  fromType?: SchemaType
  toType?: SchemaType
}

/**
 * @hidden
 * Array of predefined object options input
 * Note: this input can handle only object values
 *
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfObjectOptionsInput(
  props: ArrayOfObjectsInputProps,
): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare interface ArrayOfObjectsComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ArrayFieldProps>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ArrayOfObjectsInputProps>
  item?: ComponentType<ObjectItemProps>
  preview?: ComponentType<PreviewProps>
}

/** @public */
export declare interface ArrayOfObjectsFormNode<
  T extends any[] = unknown[],
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfObjectsMember[]
}

/**
 * @hidden
 * @beta */
export declare function ArrayOfObjectsFunctions<
  Item extends ObjectItem,
  SchemaType extends ArraySchemaType,
>(props: ArrayInputFunctionsProps<Item, SchemaType>): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfObjectsInput(props: ArrayOfObjectsInputProps): React_2.JSX.Element

/**
 * Convenience component for rendering an "array of objects"-item
 * @internal
 */
export declare function ArrayOfObjectsInputMember(
  props: ArrayOfObjectsMemberProps,
): React_2.JSX.Element | null

/**
 * Convenience component for wrapping an array of objects
 * @internal
 */
export declare function ArrayOfObjectsInputMembers(
  props: ArrayOfObjectsInputMembersProps,
): React_2.JSX.Element

/** @internal */
export declare interface ArrayOfObjectsInputMembersProps {
  members: ArrayOfObjectsMember[]
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderField: RenderFieldCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}

/**
 * @hidden
 * @public */
export declare interface ArrayOfObjectsInputProps<
  T extends {
    _key: string
  } = {
    _key: string
  },
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseInputProps,
    ArrayOfObjectsFormNode<T[], S> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps<T, S>>
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onItemAppend: (item: T) => void
  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: T) => void
  /**
   * @hidden
   * @beta */
  onItemRemove: (itemKey: string) => void
  /**
   * @hidden
   * @beta */
  onItemMove: (event: ArrayInputMoveItemEvent) => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: ArrayInputInsertEvent<T>) => void
  /**
   * @hidden
   * @beta */
  resolveInitialValue: (type: SchemaType, params: Record<string, unknown>) => Promise<T>
  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver<ObjectSchemaType>
  /**
   * @hidden
   * @beta */
  onUpload: (event: UploadEvent) => void
  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path) => void
  /**
   * for array inputs using expand/collapse semantics for items
   *
   * @hidden
   * @beta
   */
  onItemCollapse: (itemKey: string) => void
  /**
   * @hidden
   * @beta */
  onItemExpand: (itemKey: string) => void
  /**
   * for array inputs using modal open/close semantics for items
   *
   * @hidden
   * @beta
   */
  onItemOpen: (path: Path) => void
  /**
   * @hidden
   * @beta */
  onItemClose: () => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/**
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfObjectsItem(props: MemberItemProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare interface ArrayOfObjectsItemMember<
  Node extends ObjectArrayFormNode = ObjectArrayFormNode,
> {
  kind: 'item'
  key: string
  index: number
  collapsed: boolean | undefined
  collapsible: boolean | undefined
  open: boolean
  parentSchemaType: ArraySchemaType
  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
export declare type ArrayOfObjectsMember = ArrayOfObjectsItemMember | ArrayItemError

/** @internal */
export declare interface ArrayOfObjectsMemberProps {
  member: ArrayOfObjectsMember
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}

/**
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfOptionsInput(
  props: ArrayOfObjectsInputProps | ArrayOfPrimitivesInputProps,
): React_2.JSX.Element

/**
 * Array of predefined primitive options input
 * Note: this input can only handle primitive values
 *
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfPrimitiveOptionsInput(
  props: ArrayOfPrimitivesInputProps,
): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare interface ArrayOfPrimitivesComponents {
  diff?: ComponentType<any>
  field?: ComponentType<ArrayOfPrimitivesFieldProps>
  input?: ComponentType<ArrayOfPrimitivesInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 * @hidden
 * @beta */
export declare type ArrayOfPrimitivesElementType<T extends any[]> = T extends (infer K)[]
  ? K
  : unknown

/**
 * @hidden
 * @public */
export declare interface ArrayOfPrimitivesFieldProps extends BaseFieldProps {
  schemaType: ArraySchemaType
  value: unknown[] | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  inputProps: ArrayOfPrimitivesInputProps
}

/** @public */
export declare interface ArrayOfPrimitivesFormNode<
  T extends (string | number | boolean)[] = (string | number | boolean)[],
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfPrimitivesMember[]
}

/**
 * @hidden
 * @beta */
export declare function ArrayOfPrimitivesFunctions<
  MemberType extends string | boolean | number,
  SchemaType extends ArraySchemaType,
>(props: ArrayInputFunctionsProps<MemberType, SchemaType>): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare class ArrayOfPrimitivesInput extends React_2.PureComponent<
  ArrayOfPrimitivesInputProps,
  State
> {
  _element: HTMLElement | null
  constructor(props: ArrayOfPrimitivesInputProps)
  handleAppend: (itemValue: PrimitiveValue) => void
  handlePrepend: (itemValue: PrimitiveValue) => void
  handleSortEnd: (event: {fromIndex: number; toIndex: number}) => void
  handleItemMoveStart: () => void
  handleItemMoveEnd: () => void
  focus(): void
  getSnapshotBeforeUpdate(prevProps: ArrayOfPrimitivesInputProps):
    | {
        prevFocusedIndex: PathSegment
        restoreSelection: {
          text: string
          start: number | null
          end: number | null
          value: string
        }
      }
    | {
        prevFocusedIndex?: undefined
        restoreSelection?: undefined
      }
    | null
  componentDidUpdate(
    prevProps: ArrayOfPrimitivesInputProps,
    prevState: Record<string, unknown>,
    snapshot?: {
      restoreSelection: {
        start: number
        end: number
      }
      prevFocusedIndex: number
    },
  ): void
  renderArrayItem: (props: Omit<PrimitiveItemProps, 'renderDefault'>) => React_2.JSX.Element
  render(): React_2.JSX.Element
}

/**
 * @hidden
 * @public */
export declare interface ArrayOfPrimitivesInputProps<
  T extends string | boolean | number = string | boolean | number,
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseInputProps,
    ArrayOfPrimitivesFormNode<T[], S> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps<T, S>>
  onSetCollapsed: (collapsed: boolean) => void
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onItemAppend: (item: ArrayOfPrimitivesElementType<T[]>) => void
  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: ArrayOfPrimitivesElementType<T[]>) => void
  /**
   * @hidden
   * @beta */
  onItemRemove: (index: number) => void
  /**
   * @hidden
   * @beta */
  onMoveItem: (event: ArrayInputMoveItemEvent) => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: {items: T[]; position: 'before' | 'after'; referenceIndex: number}) => void
  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver<NumberSchemaType | BooleanSchemaType | StringSchemaType>
  /**
   * @hidden
   * @beta */
  onUpload: (event: UploadEvent) => void
  /**
   * @hidden
   * @beta */
  onIndexFocus: (index: number) => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfPrimitivesItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/**
 *
 * @hidden
 * @beta
 */
export declare function ArrayOfPrimitivesItem(props: PrimitiveMemberItemProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare interface ArrayOfPrimitivesItemMember<
  Node extends PrimitiveFormNode = PrimitiveFormNode,
> {
  kind: 'item'
  key: string
  index: number
  open: boolean
  parentSchemaType: ArraySchemaType
  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
export declare type ArrayOfPrimitivesMember = ArrayOfPrimitivesItemMember | ArrayItemError

/** @internal */
export declare function asLoadable<T>(): OperatorFunction<T, LoadableState<T>>

/**
 * @hidden
 * @beta
 */
export declare type AssetSourceResolver = ComposableOption<AssetSource[], ConfigContext>

/**
 * @hidden
 * @beta
 */
export declare type AsyncComposableOption<TValue, TContext> = (
  prev: TValue,
  context: TContext,
) => Promise<TValue>

/** @internal */
export declare type AsyncConfigPropertyReducer<TValue, TContext> = (
  prev: TValue,
  config: PluginOptions,
  context: TContext,
) => TValue | Promise<TValue>

/**
 * Authentication options
 *
 * @public
 */
export declare interface AuthConfig {
  /**
   * Login method to use for the studio the studio. Can be one of:
   * - `dual` (default) - attempt to use cookies where possible, falling back to
   *   storing authentication token in `localStorage` otherwise
   * - `cookie` - explicitly disable `localStorage` method, relying only on cookies. May fail due
   *   to cookies being treated as third-party cookies in some browsers, thus the default is `dual`.
   * - `token` - explicitly disable cookies, relying only on `localStorage` method
   */
  loginMethod?: 'dual' | 'cookie' | 'token'
  /**
   * Whether to append the providers specified in `providers` with the default providers from the
   * API, or replace the default providers with the ones specified.
   *
   * @deprecated Use the function form of `providers` instead for more control
   */
  mode?: 'append' | 'replace'
  /**
   * If true, the "Choose login provider" (eg "Google, "GitHub", "E-mail/password") screen
   * will be skipped if only a single provider is configured in the `providers` array -
   * instead it will redirect unauthenticated users straight to the authenticatino URL.
   */
  redirectOnSingle?: boolean
  /**
   * Array of authentication providers to use, or a function that takes an array of default
   * authentication providers (fetched from the Sanity API) and should return a new list of
   * providers. This can be used to selectively replace, add or remove providers from the
   * list of choices.
   *
   * @remarks If a static array of providers is provided, the `mode` property is taken into account
   *   when determining what to do with it - `append` will append the providers to the default set
   *   of providers, while `replace` will replace the default providers with the ones specified.
   *
   * If not set, the default providers will be used.
   */
  providers?: AuthProvider[] | ((prev: AuthProvider[]) => AuthProvider[] | Promise<AuthProvider[]>)
  /**
   * The API hostname for requests. Should usually be left undefined,
   * but can be set if using custom cname for API domain.
   */
  apiHost?: string
}

/**
 * A provider of authentication.
 *
 * By default, a list of providers for a project will be fetched from the
 * {@link https://api.sanity.io/v1/auth/providers | Sanity API}, but you may choose to limit this
 * list by explicitly defining the providers you want to allow, or add additional custom providers
 * that conforms to the authentication provider specification outlined in
 * {@link https://www.sanity.io/docs/third-party-login | the documentation}.
 *
 * @public
 */
export declare interface AuthProvider {
  /**
   * URL-friendly identifier/name for the provider, eg `github`
   */
  name: string
  /**
   * Human friendly title for the provider, eg `GitHub`
   */
  title: string
  /**
   * URL for the authentication endpoint that will trigger the authentication flow
   */
  url: string
  /**
   * URL for a logo to display next to the provider in the login screen
   */
  logo?: string
}

/**
 * The unit an `AuthStore` emits to determine the user's authentication state.
 *
 * @beta
 * @hidden
 */
export declare interface AuthState {
  /**
   * Similar to a logged-in flag. This state is used in places like the
   * `AuthBoundary` to determine whether or not it should render the
   * `NotAuthenticatedComponent`. Implementers may choose to set this to `true`
   * while also also emitting a `currentUser` of `null` if a `null` user is
   * accepted (e.g. a project that doesn't require a login)
   */
  authenticated: boolean
  /**
   * The value of the user logged in or `null` if none is provided
   */
  currentUser: CurrentUser | null
  /**
   * A client that is expected to be pre-configured to allow for any downstream
   * requests in the Studio
   */
  client: SanityClient
}

/**
 * The interface used by the Studio that produces a `SanityClient` and
 * `CurrentUser` that gets passed to the resulting `Workspace`s and `Source`s.
 *
 * NOTE: This interface is primarily for internal use. Refer to
 * `createAuthStore` instead.
 *
 * @beta
 * @hidden
 */
export declare interface AuthStore {
  /**
   * Emits `AuthState`s. This should update when the user's auth state changes.
   * E.g. After a login, a new `AuthState` could be emitted with a non-null
   * `currentUser` and `authenticated: true`
   *
   * NOTE: all auth store implementations should emit on subscribe using
   * something like shareReplay(1) to ensure all new subscribers get an
   * `AuthState` value on subscribe
   */
  state: Observable<AuthState>
  /**
   * Emits auth tokens, or `null` if not configured to use them or they do not exist
   */
  token?: Observable<string | null>
  /**
   * Custom auth stores are expected to implement a UI that initiates the user's
   * authentication. For the typical case in `createAuthStore`, this means
   * loading the providers and showing them as options to the user.
   */
  LoginComponent?: React.ComponentType<LoginComponentProps>
  /**
   * Custom auth stores can implement a function that runs when the user logs
   * out. The implementation is expected to remove all credentials both locally
   * and on the server.
   */
  logout?: () => void
  /**
   * Custom auth stores can implement a function that is designated to run when
   * the Studio loads (e.g. to trade a session ID for a token in cookie-less
   * mode). Within the Studio, this is called within the `AuthBoundary`.
   */
  handleCallbackUrl?: () => Promise<void>
}

/** @internal */
export declare interface AuthStoreOptions extends AuthConfig {
  clientFactory?: (options: ClientConfig) => SanityClient
  projectId: string
  dataset: string
}

/** @internal */
export declare type AvailabilityReason = 'READABLE' | 'PERMISSION_DENIED' | 'NOT_FOUND'

/** @internal */
export declare interface AvailabilityResponse {
  omitted: {
    id: string
    reason: 'existence' | 'permission'
  }[]
}

/**
 * @hidden
 * @public */
export declare interface BaseFieldProps {
  /** @beta */
  actions?: DocumentFieldAction[]
  /** @internal @deprecated DO NOT USE */
  __internal_comments?: FieldCommentsProps
  /** @internal @deprecated ONLY USED BY AI ASSIST PLUGIN */
  __internal_slot?: React.ReactNode
  schemaType: SchemaType
  title: string | undefined
  description: string | undefined
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  validation: FormNodeValidation[]
  level: number
  inputId: string
  value: unknown | undefined
  path: Path
  name: string
  index: number
  changed: boolean
  children: ReactNode
  renderDefault: (props: FieldProps) => ReactElement
}

/**
 * @hidden
 * @beta */
declare interface BaseFileInputProps extends ObjectInputProps<BaseFileInputValue, FileSchemaType> {
  assetSources: AssetSource[]
  directUploads?: boolean
  observeAsset: (documentId: string) => Observable<FileAsset>
  resolveUploader: UploaderResolver
  client: SanityClient
}

/**
 * @hidden
 * @beta */
declare interface BaseFileInputValue extends Partial<File_2> {
  _upload?: UploadState
}

/**
 * @hidden
 * @public
 */
export declare interface BaseFormNode<T = unknown, S extends SchemaType = SchemaType> {
  /** The unique identifier of the node. */
  id: string
  /** The schema type of the node. */
  schemaType: S
  /** The level of the node in the form hierarchy. */
  level: number
  /** The path of the node in the form hierarchy. */
  path: Path
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  /** The validation markers of the node. */
  validation: FormNodeValidation[]
  /** The value of the node. */
  value: T | undefined
  /** Whether the node is read-only. */
  readOnly?: boolean
  /** Whether the node is focused. */
  focused?: boolean
  /** Whether the node has changes in a draft. */
  changed: boolean
}

/**
 * @hidden
 * @beta */
declare interface BaseImageInputProps
  extends ObjectInputProps<BaseImageInputValue, ImageSchemaType> {
  assetSources: AssetSource[]
  directUploads?: boolean
  imageUrlBuilder: ImageUrlBuilder
  observeAsset: (documentId: string) => Observable<ImageAsset>
  resolveUploader: UploaderResolver
  client: SanityClient
}

/**
 * @hidden
 * @beta */
declare interface BaseImageInputValue extends Partial<Image_2> {
  _upload?: UploadState
}

/**
 * @hidden
 * @public */
export declare interface BaseInputProps {
  renderDefault: (props: InputProps) => React_2.ReactElement
}

/**
 * @public
 * @todo dedupe with intent types in core
 */
declare interface BaseIntentParams {
  /* Intent type */
  type?: string
  /* Intent Id */
  id?: string
  /* Intent template */
  template?: string
  /**
   * Experimental field path
   * @beta
   * @experimental
   * @hidden
   */
  path?: string
}

/**
 * Props for the base item component.
 *
 * @public
 */
export declare interface BaseItemProps<T> {
  /** The schema type of the item. */
  schemaType: SchemaType
  /** The key of the item. */
  key: string
  /** The index of the item. */
  index: number
  /** The level of the item. */
  level: number
  /** The value of the item. */
  value: unknown
  /** The path of the item. */
  path: Path
  /** The title of the item. */
  title: string | undefined
  /** The description of the item. */
  description: string | undefined
  /** The ID of the input element. */
  inputId: string
  /** The function to call when the item receives focus. */
  onFocus: (event: React_2.FocusEvent) => void
  /** The function to call when the item loses focus. */
  onBlur: (event: React_2.FocusEvent) => void
  /** Whether the item is read-only. */
  readOnly?: boolean
  /** Whether the item is focused. */
  focused?: boolean
  /** The function to call when the item is removed. */
  onRemove: () => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: Omit<ArrayInputInsertEvent<T>, 'referenceItem'>) => void
  /** The children of the item. */
  children: React_2.ReactNode
  /** The validation markers for the item. */
  validation: FormNodeValidation[]
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  /** The function to call to render the default item. See {@link ItemProps} */
  renderDefault: (props: ItemProps) => React_2.ReactElement
}

/**
 * Props for rendering a Portable Text annotation
 *
 * @public
 * @remarks If you want to render a mix of the annotated text and non-text content, you have to attribute
 * the non-text containers with `contentEditable={false}`. See the second example.
 * @example Simple example of customizing the annotation text to render yellow.
 * ```ts
 * (props: BlockAnnotationProps) =>
 *   props.renderDefault({
 *     ...props,
 *     textElement: <span style={{color: 'yellow'}}>{props.textElement}</span>,
 *   })
 * ```
 * @example Simple example of rendering the annotation with a custom modal for editing.
 * Note that the form content container is attributed as `contentEditable={false}`.
 * This is to signal to the text editor that this content isn't part of the editable text.
 * ```ts
 * (props: BlockAnnotationProps) => {
 *   return (
 *     <>
 *       // Render the annotated text
 *       <span onClick={props.onOpen}>
 *         {props.textElement}
 *       </span>
 *       // Render the editing form if the object is opened
 *       {props.open && (
 *         <Dialog
 *           contentEditable={false} // Attribute this as non-editable to the text editor
 *           header={`Edit ${props.schemaType.title}`}
 *           id={`dialog-${props.value._key}`}
 *           onClickOutside={props.onClose}
 *           onClose={props.onClose}
 *         >
 *           <Box margin={2} padding={2}>
 *             {props.children}
 *           </Box>
 *         </Dialog>
 *      )}
 *     </>
 *   )
 * }
 * ```
 * */
export declare interface BlockAnnotationProps {
  /**
   * Boundary element of the floating toolbar element.
   */
  __unstable_floatingBoundary: HTMLElement | null
  /**
   * Boundary element where the text for this annotation appears.
   */
  __unstable_referenceBoundary: HTMLElement | null
  /**
   * DOM element for the annotated text.
   */
  __unstable_referenceElement: HTMLElement | null
  /**
   * Wether the annotated text node has editor focus.
   * @remarks differs from `focused` which is wether the annotation object has form focus.
   */
  __unstable_textElementFocus?: boolean
  /**
   * The input form for the annotation object.
   * @remarks If you wrap this in something, you must make sure to put `contentEditable={false}` on the root container.
   * Otherwise the editor will think content is part of the editable text and will error.
   */
  children: ReactNode
  /**
   * If the editor form for this annotation object currently have form focus.
   */
  focused: boolean
  /**
   * Markers (meta data) connected to this annotation.
   * @deprecated - use `renderBlock` and `renderInlineBlock` interfaces instead
   */
  markers: PortableTextMarker[]
  /**
   * Closes the editing form connected to this annotation.
   */
  onClose: () => void
  /**
   * Opens the editing form connected to this annotation.
   */
  onOpen: () => void
  /**
   * Focus a form node in the object for this annotation.
   * @param path - the relative path to the form node to put focus on.
   */
  onPathFocus: (path: Path) => void
  /**
   * Removes the annotation object from the text.
   */
  onRemove: () => void
  /**
   * If the annotation is currently opened for editing.
   */
  open: boolean
  /**
   * The parent schema type. For annotations this this the block type.
   */
  parentSchemaType: SchemaType
  /**
   * The full form path to this annotation from document root.
   */
  path: Path
  /**
   * Form presence for this annotation.
   */
  presence: FormNodePresence[]
  /**
   * Is the annotation object read only?
   */
  readOnly: boolean
  /**
   * Plugin chain render callback.
   */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * Plugin chain render callback.
   */
  renderBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback.
   */
  renderDefault: (props: BlockAnnotationProps) => ReactElement
  /**
   * Plugin chain render callback.
   */
  renderField: RenderFieldCallback
  /**
   * Plugin chain render callback.
   */
  renderInlineBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback.
   */
  renderInput: RenderInputCallback
  /**
   * Plugin chain render callback.
   */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * Plugin chain render callback.
   */
  renderPreview: RenderPreviewCallback
  /**
   * The schema type for the annotation object.
   */
  schemaType: ObjectSchemaType
  /**
   * If the annotated text currently is selected by the user.
   */
  selected: boolean
  /**
   * React element of the text that is being annotated.
   */
  textElement: ReactElement
  /**
   * Form validation for the annotation object.
   */
  validation: FormNodeValidation[]
  /**
   * Value of the annotation object.
   */
  value: PortableTextObject
}

/**
 * Props for rendering text decorations in Portable Text blocks.
 * It could be decorations like bold, italic, subscript etc.
 *
 * @public
 */
export declare interface BlockDecoratorProps {
  /**
   * The span node as rendered without the decorator.
   */
  children: React.ReactElement
  /**
   * If the span node currently is focused by the user.
   */
  focused: boolean
  /**
   * The default render function for this decorator,
   * some decorators are proved by default and has a default rendering.
   */
  renderDefault: (props: BlockDecoratorProps) => React.ReactElement
  /**
   * The decorator schema type. Icon can be found here.
   */
  schemaType: BlockDecoratorDefinition
  /**
   * If the span node text currently is selected by the user.
   */
  selected: boolean
  /**
   * The title of the decorator (e.g. 'Underlined text') for UI-representation.
   */
  title: string
  /**
   * The value of the decorator (e.g. 'underlined') as it
   * appears in the child.marks array of the text node.
   */
  value: string
}

/**
 * @hidden
 * @beta */
export declare function BlockImagePreview(props: BlockImagePreviewProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare type BlockImagePreviewProps = Omit<PreviewProps<'blockImage'>, 'renderDefault'>

/**
 * Props for rendering a Portable Text block as a list item.
 *
 * @public
 */
export declare interface BlockListItemProps {
  /**
   * The block that is rendered as a list item.
   */
  block: PortableTextTextBlock
  /**
   * The block rendered without the list style.
   */
  children: React.ReactElement
  /**
   * If the block currently is focused by the user.
   */
  focused: boolean
  /**
   * The nesting level of this list item.
   */
  level: number
  /**
   * The default function for rendering this as a list item. Some list types are built in and
   * will have a default rendering.
   */
  renderDefault: (props: BlockListItemProps) => React.ReactElement
  /**
   * The schema type for this list type. Icon can be found here.
   */
  schemaType: BlockListDefinition
  /**
   * If the user currently has a text selection in this block.
   */
  selected: boolean
  /**
   * The title of the list item type (e.g. 'Bullet list') for UI-representation.
   */
  title: string
  /**
   * The value of the list item type (e.g. 'bullet') as it appears in the block.listItem attribute.
   */
  value: string
}

/**
 * @hidden
 * @beta */
export declare function BlockPreview(
  props: Omit<PreviewProps<'block'>, 'renderDefault'>,
): React_2.JSX.Element

/**
 * Props for rendering a Portable Text block
 *
 * @public
 */
export declare interface BlockProps {
  /**
   * Boundary element of the floating toolbar element.
   */
  __unstable_floatingBoundary: HTMLElement | null
  /**
   * Boundary element for the block.
   */
  __unstable_referenceBoundary: HTMLElement | null
  /**
   * DOM element for the block.
   */
  __unstable_referenceElement: HTMLElement | null
  /**
   * The default rendering of the block (the text).
   */
  children: ReactNode
  /**
   * If the block currently is focused by the user.
   */
  focused: boolean
  /**
   * Markers (meta data) connected to this annotation.
   * @deprecated - use `renderBlock` and `renderInlineBlock` interfaces instead
   */
  markers: PortableTextMarker[]
  /**
   * Closes the editing form connected to this block.
   * For regular text blocks this is not relevant.
   */
  onClose: () => void
  /**
   * Opens the editing form connected to this block.
   * For regular text blocks this is not relevant.
   */
  onOpen: () => void
  /**
   * Focus a form node in this block.
   * @param path - the relative path to the form node to put focus on.
   */
  onPathFocus: (path: Path) => void
  /**
   * Removes the block.
   */
  onRemove: () => void
  /**
   * If the block is currently opened for editing.
   */
  open: boolean
  /**
   * The parent schema type (array type).
   */
  parentSchemaType: ArraySchemaType | ObjectSchemaType
  /**
   * The full form path to this block from document root.
   */
  path: Path
  /**
   * Form presence for this block.
   */
  presence: FormNodePresence[]
  /**
   * Is the block object read only?
   */
  readOnly: boolean
  /**
   * Plugin chain render callback.
   */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * Plugin chain render callback.
   */
  renderBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback (default rendering function of the block).
   */
  renderDefault: (props: BlockProps) => ReactElement
  /**
   * Plugin chain render callback.
   */
  renderField: RenderFieldCallback
  /**
   * Plugin chain render callback.
   */
  renderInlineBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback.
   */
  renderInput: RenderInputCallback
  /**
   * Plugin chain render callback.
   */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * Plugin chain render callback.
   */
  renderPreview: RenderPreviewCallback
  /**
   * The schema type for the block.
   */
  schemaType: ObjectSchemaType
  /**
   * If the block is in the user's selection.
   */
  selected: boolean
  /**
   * Form validation for the block object.
   */
  validation: FormNodeValidation[]
  /**
   * Value of the block.
   */
  value: PortableTextBlock
}

/**
 * Props for rendering a text block style.
 *
 * @public
 */
export declare interface BlockStyleProps {
  /**
   * The value of the block that is rendered style for.
   */
  block: PortableTextTextBlock
  /**
   * The block as rendered without this style.
   */
  children: React.ReactElement
  /**
   * If the block currently has focus in the text editor.
   */
  focused: boolean
  /**
   * The default rendering function for this style.
   */
  renderDefault: (props: BlockStyleProps) => React.ReactElement
  /**
   * The schema type for this style.
   */
  schemaType: BlockStyleDefinition
  /**
   * If the block currently have a text selection.
   */
  selected: boolean
  /**
   * The title of the style (e.g. 'Large Heading') for UI-representation.
   */
  title: string
  /**
   * The value of the style (e.g. 'h1') as it appears in the block's `.style` property value.
   */
  value: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface BooleanComponents {
  diff?: ComponentType<any>
  field?: ComponentType<BooleanFieldProps>
  input?: ComponentType<BooleanInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare type BooleanDiff = BooleanDiff_2<Annotation>

/**
 * @hidden
 * @public */
export declare interface BooleanFieldProps extends BaseFieldProps {
  schemaType: BooleanSchemaType
  value: boolean | undefined
  inputProps: BooleanInputProps
}

/** @public */
export declare type BooleanFormNode<S extends BooleanSchemaType = BooleanSchemaType> = BaseFormNode<
  boolean,
  S
>

/**
 *
 * @hidden
 * @beta
 */
export declare function BooleanInput(props: BooleanInputProps): React_2.JSX.Element

/**
 * @hidden
 * @public */
export declare interface BooleanInputProps<S extends BooleanSchemaType = BooleanSchemaType>
  extends BaseInputProps,
    BooleanFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * A shorthand aggregation of any validation errors the input currently have
   * Will be falsey if no error.
   * In the case of multiple errors it will be a newline delimited string of each error message
   * For advanced use cases use the ´validation´ prop which contains more levels and details
   */
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/**
 * @hidden
 * @beta */
export declare type BufferedDocumentEvent =
  | SnapshotEvent
  | DocumentRebaseEvent
  | DocumentMutationEvent
  | CommittedEvent

/** @internal */
export declare interface BufferedDocumentWrapper {
  consistency$: Observable<boolean>
  remoteSnapshot$: Observable<RemoteSnapshotEvent>
  events: Observable<BufferedDocumentEvent>
  commitRequest$: Observable<CommitRequest>
  patch: (patches: any[]) => MutationPayload[]
  create: (document: Partial<SanityDocument>) => MutationPayload
  createIfNotExists: (document: SanityDocument) => MutationPayload
  createOrReplace: (document: SanityDocument) => MutationPayload
  delete: () => MutationPayload
  mutate: (mutations: MutationPayload[]) => void
  commit: () => void
}

/**
 * Build a Sanity UI theme from legacy CSS properties.
 *
 * @example
 * ```tsx
 * import {buildLegacyTheme, defineConfig} from 'sanity'
 *
 * export default defineConfig({
 *   // project configuration ...
 *
 *   // Customize theming
 *   theme: buildLegacyTheme({
 *     '--black': '#000',
 *     '--gray': '#777',
 *     '--focus-color': '#00f',
 *   })
 * })
 * ```
 *
 * @param partialLegacyTheme - Properties to override the theme with. See {@link LegacyThemeProps}
 *
 * @public
 */
export declare function buildLegacyTheme(partialLegacyTheme: Partial<LegacyThemeProps>): StudioTheme

/** @internal */
export declare function ChangeBreadcrumb(props: {
  change?: FieldChangeNode
  titlePath: ChangeTitlePath
}): React_2.JSX.Element

/** @internal */
export declare const ChangeConnectorRoot: typeof EnabledChangeConnectorRoot

/**
 * This is used to draw the bar that wraps the diff components in the changes panel
 *
 * @internal
 */
export declare const ChangeFieldWrapper: (props: {
  path: Path
  children: React_2.ReactNode
  hasHover: boolean
}) => React_2.JSX.Element

/** @internal */
export declare function ChangeIndicator(
  props: ChangeIndicatorProps & Omit<HTMLProps<HTMLDivElement>, 'as'>,
): React_2.JSX.Element

/** @internal */
export declare const ChangeIndicatorContext: React_2.Context<ChangeIndicatorContextValue>

/** @internal */
export declare interface ChangeIndicatorContextValue {
  value?: unknown
  focusPath: Path
  path: Path
  fullPath: Path
  isChanged: boolean
}

/** @internal */
export declare interface ChangeIndicatorProps {
  path: Path
  hasFocus: boolean
  isChanged: boolean
  withHoverEffect?: boolean
}

/** @internal */
export declare function ChangeList({
  diff,
  fields,
  schemaType,
}: ChangeListProps): React_2.ReactElement | null

/** @internal */
export declare interface ChangeListProps {
  schemaType: ObjectSchemaType
  diff: ObjectDiff
  fields?: string[]
}

/** @internal */
export declare type ChangeNode = GroupChangeNode | FieldChangeNode

/** @internal */
export declare function ChangeResolver(props: ChangeResolverProps): React_2.JSX.Element | null

/** @internal */
export declare interface ChangeResolverProps {
  change: ChangeNode
  readOnly?: ConditionalProperty
  hidden?: ConditionalProperty
}

/** @internal */
export declare type ChangeTitlePath = (string | FromToIndex)[]

/** @internal */
export declare function ChangeTitleSegment(props: {
  change?: FieldChangeNode
  segment: string | FromToIndex
}): React_2.JSX.Element

/** @internal */
export declare function checkoutPair(client: SanityClient, idPair: IdPair): Pair

/**
 * @hidden
 * @beta */
export declare type Chunk = {
  index: number
  id: string
  type: ChunkType
  start: number
  end: number
  startTimestamp: string
  endTimestamp: string
  authors: Set<string>
  draftState: 'present' | 'missing' | 'unknown'
  publishedState: 'present' | 'missing' | 'unknown'
}

/**
 * History timeline / chunking
 *
 *
 * @hidden
 * @beta
 */
export declare type ChunkType =
  | 'initial'
  | 'create'
  | 'editDraft'
  | 'delete'
  | 'publish'
  | 'unpublish'
  | 'discardDraft'
  | 'editLive'

/**
 * @hidden
 * @beta */
export declare function CircularProgress(props: {
  /** Percentage */
  value: number
}): React_2.JSX.Element

/** @internal */
export declare const CollapseMenu: React_2.ForwardRefExoticComponent<
  CollapseMenuProps & React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare const CollapseMenuButton: React_2.ForwardRefExoticComponent<
  Omit<CollapseMenuButtonProps & Omit<React_2.HTMLProps<HTMLButtonElement>, 'as'>, 'ref'> &
    React_2.RefAttributes<HTMLButtonElement>
>

/** @internal */
export declare interface CollapseMenuButtonProps extends CommonProps {
  collapsedProps?: Omit<CommonProps, 'text'>
  expandedProps?: CommonProps
  text: ButtonProps['text']
}

/** @internal */
export declare interface CollapseMenuProps {
  children: React_2.ReactNode
  collapsed?: boolean
  collapseText?: boolean
  disableRestoreFocusOnClose?: boolean
  gap?: number | number[]
  menuButtonProps?: Omit<MenuButtonProps, 'id' | 'menu' | 'button'> & {
    id?: string
    button?: React_2.ReactElement
  }
  onMenuClose?: () => void
}

/** @internal */
export declare function collate<
  T extends {
    _id: string
    _type: string
  },
>(documents: T[]): CollatedHit<T>[]

/**
 * Takes a list of documents and collates draft/published pairs into single entries
 * `{id: <published id>, draft?: <draft document>, published?: <published document>}`
 *
 * Note: because Map is ordered by insertion key the resulting array will be ordered by whichever
 * version appeared first
 *
 * @internal
 */
export declare interface CollatedHit<
  T extends {
    _id: string
  } = {
    _id: string
  },
> {
  id: string
  type: string
  draft?: T
  published?: T
}

/**
 * If the `scheme` prop is provided we don't need to setup any logic to handle localStorage
 * @internal
 */
export declare function ColorSchemeCustomProvider({
  children,
  onSchemeChange,
  scheme,
}: Pick<ColorSchemeProviderProps, 'children' | 'onSchemeChange'> & {
  scheme: StudioThemeColorSchemeKey
}): React_2.JSX.Element

/**
 * Uses useSyncExternalStore to ensure that localStorage is accessed in a SSR hydration compatible way
 * @internal
 */
export declare function ColorSchemeLocalStorageProvider({
  children,
  onSchemeChange,
}: Pick<ColorSchemeProviderProps, 'children' | 'onSchemeChange'>): React_2.JSX.Element

/** @internal */
export declare function ColorSchemeProvider({
  children,
  onSchemeChange,
  scheme: schemeProp,
}: ColorSchemeProviderProps): React_2.JSX.Element

/** @internal */
export declare interface ColorSchemeProviderProps {
  children: React_2.ReactNode
  onSchemeChange?: (nextScheme: StudioThemeColorSchemeKey) => void
  scheme?: StudioThemeColorSchemeKey
}

/**
 * The setter for ColorSchemeValueContext, in a separate context to avoid unnecessary re-renders
 * If set to false then the UI should adjust to reflect that the Studio can't change the color scheme
 * @internal
 */
export declare const ColorSchemeSetValueContext: React_2.Context<
  false | ((nextScheme: StudioThemeColorSchemeKey) => void) | null
>

/**
 * Used to keep track of the internal value, which can be "system" in addition to "light" and "dark"
 * @internal
 */
export declare const ColorSchemeValueContext: React_2.Context<StudioThemeColorSchemeKey | null>

/**
 * @hidden
 * @beta */
export declare interface CombinedDocument {
  draft: Record<string, unknown> | null
  published: Record<string, unknown> | null
}

/**
 * Renders a Command List with support for the following:
 *
 * - Keyboard navigation (↑ / ↓ / ENTER) to children with a specified container (`childContainerRef`)
 * - Focus redirection when clicking child elements
 * - Pointer blocking when navigating with arrow keys (to ensure that only one active state is visible at any given time)
 * - ARIA attributes to define a `combobox` input that controls a separate `listbox`
 *
 * @internal
 */
export declare const CommandList: React_2.ForwardRefExoticComponent<
  CommandListProps<any> & React_2.RefAttributes<CommandListHandle>
>

/** @internal */
export declare type CommandListElementType = 'input' | 'list'

/** @internal */
export declare type CommandListGetItemDisabledCallback = (virtualIndex: number) => boolean

/** @internal */
export declare type CommandListGetItemKeyCallback = (virtualIndex: number) => number | string

/** @internal */
export declare type CommandListGetItemSelectedCallback = (virtualIndex: number) => boolean

/** @internal */
export declare interface CommandListHandle {
  focusInputElement: () => void
  focusListElement: () => void
  getTopIndex: () => number
  scrollToIndex: (index: number) => void
}

/** @internal */
export declare type CommandListItemContext = {
  activeIndex: number | null
  disabled?: boolean
  selected?: boolean
  virtualIndex: number
}

/** @internal */
export declare interface CommandListProps<T = any> extends ResponsivePaddingProps {
  /** The data attribute to apply to any active virtual list items */
  activeItemDataAttr?: string
  /** `aria-label` to apply to the virtual list container element */
  ariaLabel: string
  /** Whether `aria-multiselectable` is enabled on the virtual list container element */
  ariaMultiselectable?: boolean
  /** Automatically focus the input or virtual list */
  autoFocus?: CommandListElementType
  /** Whether the virtual list can receive focus */
  canReceiveFocus?: boolean
  /** Pixel offset of the virtual list focus ring. Negative values will cause the focus ring to appear inset */
  focusRingOffset?: number
  /** Force a fixed height for all virtual list children and skip measurement (faster). */
  fixedHeight?: boolean
  /** Custom function to map disabled items */
  getItemDisabled?: CommandListGetItemDisabledCallback
  /** Custom function to map virtual list items to custom keys */
  getItemKey?: CommandListGetItemKeyCallback
  /** Custom function to map selected items */
  getItemSelected?: CommandListGetItemSelectedCallback
  /** Scroll alignment of the initial active index */
  initialScrollAlign?: ScrollToOptions_2['align']
  /** Initial active index on mount */
  initialIndex?: number
  /** Input element to associate with this virtual list. Associated inputs will receive focus and handle key events */
  inputElement?: HTMLInputElement | null
  /** Estimated height for each list item */
  itemHeight: number
  /** Virtual list item values, accessible to all rendered item components */
  items: T[]
  /** Callback fired when the virtual list is within `onEndReachedIndexThreshold` of rendered content */
  onEndReached?: () => void
  /** Number of items from the end of the virtual list before which `onEndReached` is triggered */
  onEndReachedIndexOffset?: number
  /** Only show selection state when the virtual list is active (is hovered or has focus) */
  onlyShowSelectionWhenActive?: boolean
  /** Number of items to render above and below the visible area*/
  overscan?: number
  /** Rendered component in virtual lists */
  renderItem: CommandListRenderItemCallback<T>
  /** Allow wraparound keyboard navigation between first and last items */
  wrapAround?: boolean
}

/** @internal */
export declare type CommandListRenderItemCallback<T> = (
  item: T,
  context: CommandListItemContext,
) => ReactNode

/** @internal */
export declare type CommitFunction = (mutation: Mutation['params']) => Promise<unknown>

/**
 * Represents "commit requests" from the mutator.
 * These are emitted from the BufferedDocument instance's `requestHandler` callback
 *
 * @internal
 */
export declare interface CommitRequest {
  mutation: Mutation
  success: () => void
  failure: (error: Error) => void
  cancel: (error: Error) => void
}

/**
 * @hidden
 * @beta */
export declare interface CommittedEvent {
  type: 'committed'
}

/** @internal */
export declare interface CommonProps extends Omit<ButtonProps, 'text' | 'iconRight'> {
  as?: React_2.ElementType | keyof JSX.IntrinsicElements
  dividerBefore?: boolean
  focused?: boolean
  tooltipProps?: TooltipProps
  tooltipText?: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface ComplexElementProps {
  id: string
  onFocus: FocusEventHandler
  onBlur: FocusEventHandler
  ref: React_2.MutableRefObject<any>
  'aria-describedby': string | undefined
}

/** @public */
export declare type ComposableOption<TValue, TContext> = (prev: TValue, context: TContext) => TValue

/**
 * @internal
 */
declare interface ConditionalPropertyCallbackContext {
  parent?: unknown
  document?: Record<string, unknown>
  currentUser: Omit<CurrentUser, 'role'> | null
  value: unknown
}

/**
 * @hidden
 * @beta
 */
export declare type Config = SingleWorkspace | WorkspaceOptions[]

/** @public */
export declare interface ConfigContext {
  /**
   * The ID of the project.
   */
  projectId: string
  /**
   * The name of the dataset.
   */
  dataset: string
  /**
   * The schema for this source.
   */
  schema: Schema
  /**
   * The current user or `null` if not authenticated.
   */
  currentUser: CurrentUser | null
  /**
   * A function that returns a Sanity client with the {@link SourceClientOptions | specified options}.
   */
  getClient: (options: SourceClientOptions) => SanityClient
}

/** @internal */
export declare class ConfigPropertyError extends Error {
  propertyName: string
  path: string[]
  cause: unknown
  constructor({propertyName, path, cause}: ConfigPropertyErrorOptions)
}

/** @internal */
export declare interface ConfigPropertyErrorOptions {
  propertyName: string
  path: string[]
  cause: unknown
}

/** @internal */
export declare type ConfigPropertyReducer<TValue, TContext> = (
  prev: TValue,
  config: PluginOptions,
  context: TContext,
) => TValue

/** @internal */
export declare class ConfigResolutionError extends Error {
  name: string
  type: string
  causes: unknown[]
  constructor({causes, name, type}: ConfigResolutionErrorOptions)
}

/** @internal */
export declare interface ConfigResolutionErrorOptions {
  name: string
  type: string
  causes: Array<ConfigResolutionError | Error | unknown>
}

/** @internal */
export declare type ConnectedStatus = {
  type: 'connected'
  lastHeartbeat: Date
}

/** @internal */
export declare const CONNECTING: ConnectingStatus

/** @internal */
export declare type ConnectingStatus = {
  type: 'connecting'
}

/** @internal */
export declare type ConnectionState = 'connecting' | 'reconnecting' | 'connected'

/** @internal */
export declare type ConnectionStatus =
  | ConnectingStatus
  | ErrorStatus
  | ConnectedStatus
  | RetryingStatus

/** @internal */
export declare interface ConnectionStatusStore {
  connectionStatus$: Observable<ConnectionStatus>
}

/** @internal */
export declare interface ConnectionStatusStoreOptions {
  bifur: BifurClient
}

/** @internal */
export declare const ConnectorContext: Context<ConnectorContextValue>

/** @internal */
export declare interface ConnectorContextValue {
  isReviewChangesOpen: boolean
  onOpenReviewChanges: () => void | undefined
  onSetFocus: (nextPath: Path) => void | undefined
}

/** @internal */
export declare class CorsOriginError extends Error {
  projectId?: string
  constructor({projectId}: CorsOriginErrorOptions)
}

/** @internal */
export declare interface CorsOriginErrorOptions {
  projectId?: string
}

/**
 * @internal
 */
export declare const createAuthStore: typeof _createAuthStore & MemoizedFunction

/**
 * @internal
 */
export declare function _createAuthStore({
  clientFactory: clientFactoryOption,
  projectId,
  dataset,
  apiHost,
  loginMethod,
  ...providerOptions
}: AuthStoreOptions): AuthStore

/** @internal */
export declare const createBufferedDocument: (
  documentId: string,
  listenerEvent$: Observable<ListenerEvent>,
) => BufferedDocumentWrapper

/**
 * @deprecated Use `defineConfig` instead
 *
 * @hidden
 * @beta
 */
export declare function createConfig<T extends Config>(config: T): T

/**
 * This is the beginning of what should be the data store tracking connection status in the Sanity studio.
 *
 * @internal
 */
export declare function createConnectionStatusStore({
  bifur,
}: ConnectionStatusStoreOptions): ConnectionStatusStore

/** @internal */
export declare function createDocumentPreviewStore({
  client,
}: DocumentPreviewStoreOptions): DocumentPreviewStore

/** @internal */
export declare function createDocumentStore({
  getClient,
  documentPreviewStore,
  historyStore,
  initialValueTemplates,
  schema,
}: DocumentStoreOptions): DocumentStore

/** @internal */
export declare function createDraftFrom(document: SanityDocument): SanityDocument

/** @internal */
export declare function createGrantsStore({client, currentUser}: GrantsStoreOptions): GrantsStore

/** @internal */
export declare function createHistoryStore({client}: HistoryStoreOptions): HistoryStore

/** @internal */
export declare function createHookFromObservableFactory<T, TArg = void>(
  observableFactory: (arg: TArg) => Observable<T>,
  initialValue: T,
): ReactHook<TArg, LoadingTuple<T>>

/** @internal */
export declare function createHookFromObservableFactory<T, TArg = void>(
  observableFactory: (arg: TArg) => Observable<T>,
  initialValue?: T,
): ReactHook<TArg, LoadingTuple<T | undefined>>

/**
 * Creates a mock `AuthStore` (for testing) that emits an `AuthState` derived
 * from the `client` and `currentUser` given.
 *
 * @internal
 */
export declare function createMockAuthStore({client, currentUser}: MockAuthStoreOptions): AuthStore

/** @internal */
export declare function createNoopTrackerScope<T>(): {
  useReportedValues: () => Reported<T>[]
  Tracker: typeof NoopTracker
  useReporter: (id: string | null, value: T | (() => T)) => void
}

/** @internal */
export declare const createObservableBufferedDocument: (
  listenerEvent$: Observable<ListenerEvent>,
) => {
  updates$: Observable<SnapshotEvent | DocumentRebaseEvent | DocumentMutationEvent>
  consistency$: Observable<boolean>
  remoteSnapshot$: Observable<RemoteSnapshotEvent>
  commitRequest$: Subject<CommitRequest>
  addMutation: (mutation: MutationPayload) => void
  addMutations: (mutations: MutationPayload[]) => void
  commit: () => void
}

/**
 * @internal
 */
export declare function createPatchChannel(): PatchChannel

/**
 * @deprecated Use `definePlugin` instead
 *
 * @hidden
 * @beta
 */
export declare function createPlugin<TOptions = void>(
  arg: PluginFactory<TOptions> | PluginOptions,
): Plugin_2<TOptions>

/** @internal */
export declare function createProjectStore(context: {client: SanityClient}): ProjectStore

/** @internal */
export declare function createPublishedFrom(document: SanityDocument): SanityDocument

/**
 * @hidden
 * @beta */
export declare function createSchema(schemaDef: {name: string; types: any[]}): Schema

/**
 * @internal
 */
export declare function createSearchQuery(
  searchTerms: SearchTerms,
  searchOpts?: SearchOptions & WeightedSearchOptions,
): SearchQuery

/** @internal */
export declare function createSettingsStore(): SettingsStore

/** @internal */
export declare const createSharedResizeObserver: () => SharedResizeObserver

/**
 * PRIMARILY FOR TESTING PURPOSES.
 *
 * This will create a fully resolved source from a config and optionally
 * allows a `client` and `currentUser` override. This exists primarily for
 * testing purposes. If you need to use a source, we recommend using the
 * `useSource` hook to grab the fully resolved source from the `StudioProvider`
 *
 * @internal
 */
export declare function createSourceFromConfig(
  options: CreateWorkspaceFromConfigOptions,
): Promise<Source>

/** @internal */
export declare function createTrackerScope<Value>(): {
  Tracker: (props: {children: React_2.ReactNode}) => React_2.JSX.Element
  useReportedValues: () => Reported<Value>[]
  useReporter: ReporterHook<Value>
  useAutoIdReporter: (value: Value | (() => Value), isEqual?: IsEqualFunction<Value>) => void
}

/** @internal */
export declare function createUserColorManager(options: UserColorManagerOptions): UserColorManager

/** @internal */
export declare function createUseReporter<Value>(
  Context: React_2.Context<TrackerContext<Value>>,
): ReporterHook<Value>

/**
 * Given a `client` and a `currentUser` creates a datastore that handles
 * fetching, batch fetching, and caching users.
 *
 * @internal
 */
export declare function createUserStore({client: _client, currentUser}: UserStoreOptions): UserStore

/**
 * PRIMARILY FOR TESTING PURPOSES.
 *
 * This will create a fully resolved workspace from a config and optionally
 * allows a `client` and `currentUser` override. This exists primarily for
 * testing purposes. If you need to use a workspace, we recommend using the
 * `useWorkspace` hook to grab the fully resolved workspace from the
 * `StudioProvider`
 *
 * @internal
 */
export declare function createWorkspaceFromConfig(
  options: CreateWorkspaceFromConfigOptions,
): Promise<Workspace>

/** @internal */
export declare type CreateWorkspaceFromConfigOptions =
  | SingleWorkspace
  | (SingleWorkspace & {
      currentUser: CurrentUser
      getClient: (options: {apiVersion: string}) => SanityClient
      schema?: SchemaPluginOptions
    })

/**
 *
 * @hidden
 * @beta
 */
export declare interface CrossDatasetReferenceComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<CrossDatasetReferenceValue>>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<CrossDatasetReferenceInputProps>
  item?: ComponentType<ObjectItemProps<CrossDatasetReferenceValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/**
 *
 * @hidden
 * @beta
 */
export declare function CrossDatasetReferenceInput(
  props: CrossDatasetReferenceInputProps,
): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type CrossDatasetReferenceInputProps = ObjectInputProps<
  CrossDatasetReferenceValue,
  CrossDatasetReferenceSchemaType
>

/**
 *
 * @hidden
 * @beta
 */
export declare interface DateComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 * @hidden
 * @beta */
export declare function DateInput(props: DateInputProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare type DateInputProps = StringInputProps

/**
 *
 * @hidden
 * @beta
 */
export declare interface DatetimeComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 * @hidden
 * @beta */
export declare function DateTimeInput(props: DateTimeInputProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare type DateTimeInputProps = StringInputProps

/**
 * @hidden
 * @beta */
export declare function dec(amount?: number, path?: Path): FormDecPatch

/**
 * @internal
 */
export declare function decodePath(gradientPath: string): Path

/** @internal */
export declare const DEFAULT_MAX_RECURSION_DEPTH = 10

/**
 * Unless otherwise specified, this is the API version we use for controlled
 * requests on internal studio APIs. The user should always ask for a specific
 * API version when using the client - this way we can upgrade which version we
 * use internally without having the users code break unexpectedly. It also
 * means the user can easily upgrade to newer versions of GROQ when it arrives.
 *
 * @internal
 */
export declare const DEFAULT_STUDIO_CLIENT_OPTIONS: SourceClientOptions

/**
 * @hidden
 * @beta */
export declare function DefaultDocument(props: DefaultDocumentProps): React_2.ReactElement

/**
 * @hidden
 * @beta */
export declare interface DefaultDocumentProps {
  entryPath: string
  css?: string[]
  basePath?: string
}

declare type DefaultOperators = typeof searchOperators

/**
 * @hidden
 * @beta */
export declare function DefaultPreview(props: DefaultPreviewProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare interface DefaultPreviewProps
  extends Omit<PreviewProps<'default'>, 'renderDefault'> {
  styles?: {
    root?: string
    placeholder?: string
    media?: string
    heading?: string
    title?: string
    subtitle?: string
    hasSubtitle?: string
    mediaString?: string
    status?: string
    children?: string
  }
}

/** @internal */
export declare const defaultRenderAnnotation: RenderAnnotationCallback

/** @internal */
export declare const defaultRenderBlock: RenderBlockCallback

/** @internal */
export declare const defaultRenderField: RenderFieldCallback

/** @internal */
export declare const defaultRenderInlineBlock: RenderBlockCallback

/** @internal */
export declare const defaultRenderInput: RenderInputCallback

/** @internal */
export declare const defaultRenderItem: RenderItemCallback

/** @internal */
export declare const defaultRenderPreview: RenderPreviewCallback

/** @internal */
export declare function defaultTemplateForType(schemaType: SchemaType): Template

/** @internal */
export declare function defaultTemplatesForSchema(schema: Schema): Template[]

/** @internal */
export declare const defaultTheme: StudioTheme

/**
 * @hidden
 * @beta */
export declare function defineConfig<T extends Config>(config: T): T

/** @internal */
export declare function defineDocumentFieldAction(
  fieldAction: DocumentFieldAction,
): DocumentFieldAction

/**
 * Define a document inspector to be used in Sanity configuration.
 *
 * @example
 *
 * ```ts
 * // sanity.config.ts
 *
 * import {RocketIcon} from '@sanity/icons'
 * import {defineConfig, defineDocumentInspector} from 'sanity'
 *
 * const customInspector = defineDocumentInspector({
 *   name: 'custom',
 *   useMenuItem: () => ({
 *     icon: RocketIcon,
 *     showAsAction: true,
 *     title: 'Custom'
 *   }),
 *   component: lazy(() => import('./inspectors/custom')),
 * })
 *
 * export default defineConfig({
 *   // ...
 *
 *   document: {
 *     inspectors: (prev) => [customInspector, ...prev],
 *   },
 * })
 * ```
 *
 * @hidden @beta
 * */
export declare function defineDocumentInspector(inspector: DocumentInspector): DocumentInspector

/**
 * @hidden
 * @beta */
export declare function definePlugin<TOptions = void>(
  arg: PluginFactory<TOptions> | PluginOptions,
): Plugin_2<TOptions>

/**
 * @alpha
 */
export declare function defineSearchFilter<TOperators = SearchOperatorType>(
  filterDef: SearchFilterDefinition<TOperators>,
): typeof filterDef

/**
 * @alpha
 */
export declare function defineSearchFilterOperators<TOperators = SearchOperatorType>(
  operators: Operator<TOperators>[],
): typeof operators

/**
 * @alpha
 */
export declare function defineSearchOperator<
  TType extends string,
  TValue extends unknown | never,
  TOperatorSnippet extends
    | {
        type: TType
        inputComponent?: never
      }
    | {
        type: TType
        inputComponent: SearchOperatorInput<TValue>
      },
>(
  definition: (TOperatorSnippet extends {
    type: TType
    inputComponent: SearchOperatorInput<TValue>
  }
    ? SearchOperatorBuilder<TType, TValue>
    : ValuelessSearchOperatorBuilder<TType>) &
    TOperatorSnippet,
): typeof definition

/**
 * @hidden
 * @beta */
export declare function DetailPreview(props: DetailPreviewProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare type DetailPreviewProps = PreviewProps<'detail'>

/** @internal */
export declare type Diff<A = unknown, O extends object = Record<string, any>> =
  | ArrayDiff<A>
  | BooleanDiff
  | NullDiff
  | NumberDiff
  | ObjectDiff<O>
  | StringDiff
  | TypeChangeDiff

/** @internal */
export declare const DiffCard: React_2.ForwardRefExoticComponent<
  Omit<DiffCardProps & Omit<React_2.HTMLProps<HTMLElement>, 'height' | 'as'>, 'ref'> &
    React_2.RefAttributes<unknown>
>

/** @internal */
export declare interface DiffCardProps {
  annotation?: Annotation
  as?: React_2.ElementType | keyof JSX.IntrinsicElements
  diff?: Diff
  disableHoverEffect?: boolean
  path?: Path | string
  tooltip?:
    | {
        description?: React_2.ReactNode
      }
    | boolean
}

/**
 * Diff components
 *
 * @internal
 */
export declare type DiffComponent<T extends Diff = Diff> = ComponentType<DiffProps<T>>

/** @internal */
export declare type DiffComponentOptions<T extends Diff = Diff> = {
  component: DiffComponent<T>
  showHeader?: boolean
}

/**
 * Resolvers
 *
 * @internal
 */
export declare type DiffComponentResolver = (options: {
  schemaType: SchemaType
  parentSchemaType?: ArraySchemaType | ObjectSchemaType
}) => React.ComponentType<any> | DiffComponentOptions<any> | undefined

/** @internal */
export declare const DiffContext: Context<{
  path: Path
}>

/** @internal */
export declare class DiffErrorBoundary extends React_2.Component<
  DiffErrorBoundaryProps,
  DiffErrorBoundaryState
> {
  static getDerivedStateFromError(error: Error): {
    error: Error
  }
  state: DiffErrorBoundaryState
  componentDidCatch(error: Error): void
  render():
    | string
    | number
    | boolean
    | Iterable<React_2.ReactNode>
    | React_2.JSX.Element
    | null
    | undefined
}

/** @internal */
export declare interface DiffErrorBoundaryProps {
  children: React_2.ReactNode
}

/** @internal */
export declare interface DiffErrorBoundaryState {
  error?: Error
}

/** @internal */
export declare function DiffFromTo(props: DiffFromToProps): React_2.JSX.Element

/** @internal */
export declare interface DiffFromToProps {
  align?: 'top' | 'center' | 'bottom'
  cardClassName?: string
  diff: Diff
  layout?: 'grid' | 'inline'
  path?: Path | string
  previewComponent: FieldPreviewComponent
  schemaType: SchemaType
}

/** @internal */
export declare function DiffInspectWrapper(
  props: DiffInspectWrapperProps & BoxProps,
): React_2.ReactElement

/** @internal */
export declare interface DiffInspectWrapperProps {
  children: React_2.ReactNode
  change: FieldChangeNode
  as?: ExecutionProps['as']
}

/**
 * @hidden
 * @beta */
export declare function diffMatchPatch(value: string, path?: Path): FormDiffMatchPatch

/** @internal */
export declare type DiffProps<T extends Diff = Diff> = {
  diff: T
  schemaType: T extends ObjectDiff
    ? ObjectSchemaType
    : T extends ArrayDiff
    ? ArraySchemaType
    : T extends BooleanDiff
    ? BooleanSchemaType
    : T extends StringDiff
    ? StringSchemaType
    : T extends NumberDiff
    ? NumberSchemaType
    : SchemaType
}

/** @internal */
export declare const diffResolver: DiffComponentResolver

/** @internal */
export declare function DiffString(props: {diff: StringDiff}): React_2.JSX.Element

/** @internal */
export declare function DiffStringSegment(props: {segment: StringDiffSegment}): React_2.ReactElement

/** @internal */
export declare function DiffTooltip(
  props: DiffTooltipProps | DiffTooltipWithAnnotationsProps,
): React_2.JSX.Element

/** @internal */
export declare interface DiffTooltipProps extends TooltipProps {
  children: React_2.ReactElement
  description?: React_2.ReactNode
  diff: Diff
  path?: Path | string
}

/** @internal */
export declare interface DiffTooltipWithAnnotationsProps extends TooltipProps {
  annotations: AnnotationDetails[]
  children: React_2.ReactElement
  description?: React_2.ReactNode
}

/** @internal */
export declare type DiffVisitor = (diff: Diff | StringDiffSegment, path: Path) => boolean

/** @internal */
export declare function DisabledChangeConnectorRoot({
  children,
  className,
}: DisabledChangeConnectorRootProps): React_2.JSX.Element

/** @internal */
export declare interface DisabledChangeConnectorRootProps {
  className?: string
  children: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionComponent extends ActionComponent<DocumentActionProps> {
  /**
   * An optional meta property that can used to replace this document action
   * with another. E.g.:
   *
   * ```js
   * import {defineConfig} from 'sanity'
   * import {MyPublishAction} from '...'
   *
   * export default defineConfig({
   *   document: {
   *     actions: (prev) =>
   *       prev.map((previousAction) =>
   *         previousAction.action === 'publish' ? MyPublishAction : previousAction
   *       ),
   *   },
   * })
   * ```
   */
  action?: 'delete' | 'discardChanges' | 'duplicate' | 'restore' | 'publish' | 'unpublish'
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionConfirmDialogProps {
  type: 'confirm'
  tone?: ButtonTone
  message: React_2.ReactNode
  onConfirm: () => void
  onCancel: () => void
  cancelButtonIcon?: React_2.ComponentType | React_2.ReactNode
  cancelButtonText?: React_2.ReactNode
  confirmButtonIcon?: React_2.ComponentType | React_2.ReactNode
  confirmButtonText?: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionCustomDialogComponentProps {
  type: 'custom'
  component: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionDescription {
  tone?: ButtonTone
  dialog?: DocumentActionDialogProps | false | null
  disabled?: boolean
  icon?: React_2.ReactNode | React_2.ComponentType
  label: string
  onHandle?: () => void
  shortcut?: string | null
  title?: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare type DocumentActionDialogProps =
  | DocumentActionConfirmDialogProps
  | DocumentActionPopoverDialogProps
  | DocumentActionModalDialogProps
  | DocumentActionCustomDialogComponentProps

/**
 * @hidden
 * @beta */
export declare interface DocumentActionModalDialogProps {
  type?: 'dialog'
  content: React_2.ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  footer?: React_2.ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  header?: React_2.ReactNode
  onClose: () => void
  showCloseButton?: boolean
  /**
   *
   * @hidden
   * @beta
   */
  width?: 'small' | 'medium' | 'large' | 'full'
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionPopoverDialogProps {
  type: 'popover'
  content: React_2.ReactNode
  onClose: () => void
}

/**
 * @hidden
 * @beta */
export declare interface DocumentActionProps extends EditStateFor {
  revision?: string
  onComplete: () => void
}

/**
 * @hidden
 * @beta
 */
export declare interface DocumentActionsContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 * @hidden
 * @beta
 */
export declare type DocumentActionsResolver = ComposableOption<
  DocumentActionComponent[],
  DocumentActionsContext
>

/**
 * @hidden
 * @beta */
export declare type DocumentAvailability =
  | {
      available: true
      reason: 'READABLE'
    }
  | {
      available: false
      reason: 'PERMISSION_DENIED' | 'NOT_FOUND'
    }

/**
 * @hidden
 * @beta */
export declare interface DocumentBadgeComponent {
  (props: DocumentBadgeProps): DocumentBadgeDescription | null
}

/**
 * @hidden
 * @beta */
export declare interface DocumentBadgeDescription {
  title?: string
  label?: string | undefined
  color?: 'primary' | 'success' | 'warning' | 'danger'
  icon?: React.ReactNode | React.ComponentType
}

/**
 * @hidden
 * @beta */
export declare interface DocumentBadgeProps extends EditStateFor {}

/**
 * @hidden
 * @beta
 */
export declare interface DocumentBadgesContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 * @hidden
 * @beta
 */
export declare type DocumentBadgesResolver = ComposableOption<
  DocumentBadgeComponent[],
  DocumentBadgesContext
>

/** @internal */
export declare const DocumentChangeContext: Context<DocumentChangeContextInstance | null>

/** @internal */
export declare type DocumentChangeContextInstance = {
  documentId: string
  schemaType: SchemaType
  rootDiff: ObjectDiff | null
  isComparingCurrent: boolean
  FieldWrapper: React.ComponentType<{
    path: Path
    children: React.ReactNode
    hasHover: boolean
  }>
  value: Partial<SanityDocument>
}

/** @hidden @beta */
export declare interface DocumentCommentsEnabledContext {
  documentId?: string
  documentType: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface DocumentComponents {
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps>
  input?: ComponentType<ObjectInputProps>
  item?: ComponentType<ObjectItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 * @hidden
 * @beta */
export declare interface DocumentFieldAction {
  name: string
  useAction: DocumentFieldActionHook
}

/**
 * @hidden
 * @beta */
export declare interface DocumentFieldActionDivider {
  type: 'divider'
}

/**
 * @hidden
 * @beta */
export declare interface DocumentFieldActionGroup {
  type: 'group'
  children: DocumentFieldActionNode[]
  disabled?:
    | boolean
    | {
        reason: ReactNode
      }
  expanded?: boolean
  hidden?: boolean
  icon?: ComponentType
  renderAsButton?: boolean
  status?: DocumentFieldActionStatus
  title: string
  tone?: DocumentFieldActionTone
}

/**
 * @hidden
 * @beta */
export declare interface DocumentFieldActionHook {
  (props: DocumentFieldActionProps): DocumentFieldActionItem | DocumentFieldActionGroup
}

/**
 * @hidden
 * @beta */
export declare interface DocumentFieldActionItem {
  type: 'action'
  disabled?:
    | boolean
    | {
        reason: ReactNode
      }
  hidden?: boolean
  icon?: ComponentType
  iconRight?: ComponentType
  onAction: () => void
  renderAsButton?: boolean
  selected?: boolean
  status?: DocumentFieldActionStatus
  title: string
  tone?: DocumentFieldActionTone
}

/**
 * @hidden
 * @beta */
export declare type DocumentFieldActionNode =
  | DocumentFieldActionItem
  | DocumentFieldActionGroup
  | DocumentFieldActionDivider

/**
 * @hidden
 * @beta */
export declare interface DocumentFieldActionProps {
  documentId: string
  documentType: string
  path: Path
  schemaType: SchemaType
}

/** @internal */
export declare const documentFieldActionsReducer: ConfigPropertyReducer<
  DocumentFieldAction[],
  DocumentFieldActionsResolverContext
>

/**
 * @hidden
 * @beta */
export declare type DocumentFieldActionsResolver = ComposableOption<
  DocumentFieldAction[],
  DocumentFieldActionsResolverContext
>

/**
 * @hidden
 * @beta */
export declare interface DocumentFieldActionsResolverContext extends ConfigContext {
  documentId: string
  documentType: string
  schemaType: SchemaType
}

/**
 * @hidden
 * @beta */
export declare type DocumentFieldActionStatus = 'info' | 'success' | 'warning' | 'error'

/**
 * @hidden
 * @beta */
export declare type DocumentFieldActionTone = 'primary' | 'positive' | 'caution' | 'critical'

/** @internal */
export declare type DocumentFormNode<
  T extends {
    [key in string]: unknown
  } = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType,
> = ObjectFormNode<T, S>

/**
 *
 * Checks if the document ID `documentId` has the same ID as `equalsDocumentId`,
 * ignoring the draft prefix.
 *
 * @public
 *
 * @param documentId - The document ID to check
 * @param equalsDocumentId - The document ID to check against
 *
 * @example
 * Draft vs published document ID, but representing the same document:
 * ```
 * // Prints "true":
 * console.log(documentIdEquals('drafts.agot', 'agot'));
 * ```
 * @example
 * Different documents:
 * ```
 * // Prints "false":
 * console.log(documentIdEquals('hp-tcos', 'hp-hbp'));
 * ```
 *
 * @returns `true` if the document IDs are equal, `false` otherwise
 */
export declare function documentIdEquals(documentId: string, equalsDocumentId: string): boolean

/** @hidden @beta */
export declare interface DocumentInspector {
  name: string
  component: DocumentInspectorComponent
  /**
   * Hook for defining a menu item for the inspector.
   */
  useMenuItem?: (props: DocumentInspectorUseMenuItemProps) => DocumentInspectorMenuItem
  /**
   * Callback for when the inspector is closed, which can be used to clean up custom document pane
   * parameters.
   */
  onClose?: (ctx: {params: Record<string, string | undefined>}) => {
    params: Record<string, string | undefined>
  }
  /**
   * Callback for when the inspector is opened, which can be used to set custom document pane
   * parameters.
   */
  onOpen?: (ctx: {params: Record<string, string | undefined>}) => {
    params: Record<string, string | undefined>
  }
}

/** @hidden @beta */
export declare type DocumentInspectorComponent = ComponentType<DocumentInspectorProps>

/** @hidden @beta */
export declare interface DocumentInspectorContext extends ConfigContext {
  documentId?: string
  documentType: string
}

/** @hidden @beta */
export declare interface DocumentInspectorMenuItem {
  hidden?: boolean
  hotkeys?: string[]
  icon?: ComponentType
  showAsAction?: boolean
  status?: ButtonTone
  title: string
  tone?: ButtonTone
}

/** @hidden @beta */
export declare interface DocumentInspectorProps {
  documentId: string
  documentType: string
  onClose: () => void
}

/** @hidden @beta */
export declare type DocumentInspectorsResolver = ComposableOption<
  DocumentInspector[],
  DocumentInspectorContext
>

/** @hidden @beta */
export declare interface DocumentInspectorUseMenuItemProps {
  documentId: string
  documentType: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare type DocumentLanguageFilterComponent = ComponentType<{
  schemaType: ObjectSchemaType
}>

/**
 *
 * @hidden
 * @beta
 */
export declare interface DocumentLanguageFilterContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare type DocumentLanguageFilterResolver = ComposableOption<
  DocumentLanguageFilterComponent[],
  DocumentLanguageFilterContext
>

/**
 * @hidden
 * @beta */
export declare interface DocumentMutationEvent {
  type: 'mutation'
  document: SanityDocument
  mutations: MutationPayload[]
  origin: 'local' | 'remote'
}

/** @internal */
export declare interface DocumentPairPermissionsOptions {
  client: SanityClient
  schema: Schema
  grantsStore: GrantsStore
  id: string
  type: string
  permission: DocumentPermission
}

/** @internal */
export declare type DocumentPermission =
  | 'delete'
  | 'discardDraft'
  | 'publish'
  | 'unpublish'
  | 'update'
  | 'duplicate'

/**
 * @hidden
 * @beta
 */
export declare interface DocumentPluginOptions {
  badges?: DocumentBadgeComponent[] | DocumentBadgesResolver
  actions?: DocumentActionComponent[] | DocumentActionsResolver
  /** @internal */
  unstable_fieldActions?: DocumentFieldAction[] | DocumentFieldActionsResolver
  /** @hidden @beta */
  inspectors?: DocumentInspector[] | DocumentInspectorsResolver
  /**
   * @hidden
   * @beta
   */
  productionUrl?: AsyncComposableOption<string | undefined, ResolveProductionUrlContext>
  /**
   * @hidden
   * @beta
   */
  unstable_languageFilter?: DocumentLanguageFilterResolver
  /**
   * @hidden
   * @beta
   */
  newDocumentOptions?: NewDocumentOptionsResolver
  /** @internal */
  unstable_comments?: {
    enabled: boolean | ((context: DocumentCommentsEnabledContext) => boolean)
  }
}

/** @internal */
export declare interface DocumentPresence {
  user: User
  path: Path
  sessionId: string
  lastActiveAt: string
}

/** @internal */
export declare function DocumentPreviewPresence(
  props: DocumentPreviewPresenceProps,
): React_2.JSX.Element

/** @internal */
export declare interface DocumentPreviewPresenceProps {
  presence: Omit<DocumentPresence, 'path'>[]
}

/**
 * @hidden
 * @beta */
export declare interface DocumentPreviewStore {
  observePaths: ObservePathsFn
  observeForPreview: ObserveForPreviewFn
  observeDocumentTypeFromId: (id: string, apiConfig?: ApiConfig) => Observable<string | undefined>
  /**
   *
   * @hidden
   * @beta
   */
  unstable_observeDocumentPairAvailability: (
    id: string,
  ) => Observable<DraftsModelDocumentAvailability>
  unstable_observePathsDocumentPair: <T extends SanityDocument = SanityDocument>(
    id: string,
    paths: PreviewPath[],
  ) => Observable<DraftsModelDocument<T>>
}

/** @internal */
export declare interface DocumentPreviewStoreOptions {
  client: SanityClient
}

/**
 * @hidden
 * @beta */
export declare interface DocumentRebaseEvent {
  type: 'rebase'
  document: SanityDocument
  remoteMutations: MutationPayload[]
  localMutations: MutationPayload[]
}

/**
 * @hidden
 * @beta */
export declare interface DocumentRemoteMutationEvent {
  type: 'remoteMutation'
  head: SanityDocument
  transactionId: string
  author: string
  timestamp: Date
  effects: {
    apply: unknown
    revert: unknown
  }
}

/**
 * @hidden
 * @beta */
export declare type DocumentRemoteMutationVersionEvent = Exclude<
  RemoteSnapshotVersionEvent,
  {
    type: 'snapshot'
  }
>

/**
 * @hidden
 * @beta */
export declare interface DocumentStore {
  /** @internal */
  checkoutPair: (idPair: IdPair) => Pair
  initialValue: (
    opts: InitialValueOptions,
    context: InitialValueResolverContext,
  ) => Observable<InitialValueMsg>
  listenQuery: (
    query:
      | string
      | {
          fetch: string
          listen: string
        },
    params: QueryParams,
    options: ListenQueryOptions,
  ) => Observable<any>
  resolveTypeForDocument: (id: string, specifiedType?: string) => Observable<string>
  pair: {
    consistencyStatus: (publishedId: string, type: string) => Observable<boolean>
    /** @internal */
    documentEvents: (publishedId: string, type: string) => Observable<DocumentVersionEvent>
    /** @internal */
    editOperations: (publishedId: string, type: string) => Observable<OperationsAPI>
    editState: (publishedId: string, type: string) => Observable<EditStateFor>
    operationEvents: (
      publishedId: string,
      type: string,
    ) => Observable<OperationSuccess | OperationError>
    validation: (publishedId: string, type: string) => Observable<ValidationStatus>
  }
}

/** @internal */
export declare interface DocumentStoreOptions {
  getClient: (options: SourceClientOptions) => SanityClient
  documentPreviewStore: DocumentPreviewStore
  historyStore: HistoryStore
  schema: Schema
  initialValueTemplates: Template[]
}

/** @internal */
export declare interface DocumentTypeResolveState {
  isLoaded: boolean
  documentType: string | undefined
}

/**
 * @hidden
 * @beta */
export declare type DocumentValuePermission =
  | 'read'
  | 'create'
  | 'update'
  | 'history'
  | 'editHistory'

/** @internal */
export declare interface DocumentValuePermissionsOptions {
  grantsStore: GrantsStore
  document: Record<string, unknown>
  permission: DocumentValuePermission
}

/**
 * @hidden
 * @beta */
export declare interface DocumentVersion {
  consistency$: Observable<boolean>
  remoteSnapshot$: Observable<RemoteSnapshotVersionEvent>
  events: Observable<DocumentVersionEvent>
  patch: (patches: any[]) => MutationPayload[]
  create: (document: Partial<SanityDocument>) => MutationPayload
  createIfNotExists: (document: SanityDocument) => MutationPayload
  createOrReplace: (document: SanityDocument) => MutationPayload
  delete: () => MutationPayload
  mutate: (mutations: MutationPayload[]) => void
  commit: () => void
}

/**
 * @hidden
 * @beta */
export declare type DocumentVersionEvent = WithVersion<ReconnectEvent | BufferedDocumentEvent>

/** @internal */
export declare interface DocumentVersionSnapshots {
  snapshots$: Observable<SanityDocument>
  patch: (patches: any[]) => MutationPayload[]
  create: (document: any) => MutationPayload
  createIfNotExists: (document: any) => MutationPayload
  createOrReplace: (document: any) => MutationPayload
  delete: () => MutationPayload
  mutate: (mutations: MutationPayload[]) => void
  commit: () => void
}

/** @internal */
export declare type DraftId = Opaque<string, 'draftId'>

/** @internal */
export declare const DRAFTS_FOLDER = 'drafts'

/**
 * @hidden
 * @beta */
export declare interface DraftsModelDocument<T extends SanityDocumentLike = SanityDocumentLike> {
  id: string
  type: string | null
  draft: {
    availability: DocumentAvailability
    snapshot: T | undefined
  }
  published: {
    availability: DocumentAvailability
    snapshot: T | undefined
  }
}

/**
 * @hidden
 * @beta */
export declare interface DraftsModelDocumentAvailability {
  /**
   * document readability for the published document
   */
  published: DocumentAvailability
  /**
   * document readability for the draft document
   */
  draft: DocumentAvailability
}

/**
 * This error may happen for arrays of objects where one or more of the members are having duplicate keys
 *
 * @public
 */
export declare type DuplicateKeysError = {
  type: 'DUPLICATE_KEYS'
  schemaType: ArraySchemaType
  duplicates: [index: number, key: string][]
}

/** @internal */
export declare interface EditReferenceLinkComponentProps {
  documentId: string
  documentType: string
  parentRefPath: Path
  template?: TemplateOption
  children: React_2.ReactNode
}

/**
 * @internal
 */
export declare interface EditReferenceOptions {
  id: string
  type: string
  parentRefPath: Path
  template: TemplateOption
}

/** @internal */
export declare const editState: (
  arg1: {
    client: SanityClient
    schema: Schema
  },
  arg2: IdPair,
  arg3: string,
) => Observable<EditStateFor>

/**
 * @hidden
 * @beta */
export declare interface EditStateFor {
  id: string
  type: string
  transactionSyncLock: TransactionSyncLockState | null
  draft: SanityDocument | null
  published: SanityDocument | null
  liveEdit: boolean
  ready: boolean
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface EmailComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 *
 * @hidden
 * @beta
 */
export declare function EmailInput(props: EmailInputProps): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type EmailInputProps = StringInputProps

/** @internal */
export declare function emitOperation(
  operationName: keyof OperationsAPI,
  idPair: IdPair,
  typeName: string,
  extraArgs: any[],
): void

/** @internal */
export declare const EMPTY_ARRAY: never[]

/** @internal */
export declare const EMPTY_OBJECT: Record<string, unknown>

/** @internal */
export declare function EnabledChangeConnectorRoot({
  children,
  className,
  isReviewChangesOpen,
  onOpenReviewChanges,
  onSetFocus,
  ...restProps
}: EnabledChangeConnectorRootProps): React_2.JSX.Element

/** @internal */
export declare interface EnabledChangeConnectorRootProps {
  children: React_2.ReactNode
  className?: string
  isReviewChangesOpen: boolean
  onOpenReviewChanges: () => void
  onSetFocus: (path: Path) => void
}

/**
 * @internal
 */
export declare function encodePath(formBuilderPath: Path): string

/** @internal */
export declare interface ErrorState {
  value: undefined
  error: Error
  isLoading: false
}

/** @internal */
export declare type ErrorStatus = {
  type: 'error'
  error: Error
  attemptNo: number
  isOffline: boolean
  retryAt: Date
}

/** @internal */
export declare const escapeField: (fieldName: string) => string

/** @internal */
export declare interface EvaluationParams {
  identity?: string
}

declare interface ExecuteArgs {
  operationName: keyof OperationsAPI
  idPair: IdPair
  typeName: string
  extraArgs: any[]
}

/** @internal */
export declare interface ExpandFieldSetOperation {
  type: 'expandFieldSet'
  path: Path
}

/** @internal */
export declare type ExpandOperation =
  | ExpandPathOperation
  | ExpandFieldSetOperation
  | SetActiveGroupOperation

/** @internal */
export declare interface ExpandPathOperation {
  type: 'expandPath'
  path: Path
}

/** @internal */
export declare const FallbackDiff: DiffComponent<Diff<unknown, Record<string, unknown>>>

declare interface Features {
  isLoading: boolean
  enabled: boolean
  features: string[]
}

/** @internal */
export declare const FieldActionMenu: React_2.NamedExoticComponent<FieldActionMenuProps>

/** @internal */
export declare interface FieldActionMenuProps {
  nodes: DocumentFieldActionNode[]
  onMenuOpenChange: (open: boolean) => void
}

/** @internal */
declare interface FieldActionsContextValue {
  actions: DocumentFieldActionNode[]
  focused?: boolean
  hovered: boolean
  onMouseEnter: () => void
  onMouseLeave: () => void
}

/** @internal */
export declare interface FieldActionsProps {
  actions: DocumentFieldAction[]
  documentId: string
  documentType: string
  onActions: (actions: DocumentFieldActionNode[]) => void
  path: Path
  schemaType: SchemaType
}

/** @internal */
export declare function FieldActionsProvider(props: FieldActionsProviderProps): React_2.JSX.Element

declare type FieldActionsProviderProps = PropsWithChildren<{
  actions: DocumentFieldActionNode[]
  focused?: boolean
  path: Path
}>

/**
 *
 * The `FieldActionsResolver` component is responsible for resolving the actions for a given field.
 *
 * Since each field action is a React hook, they need to be rendered in a component that returns
 * `null` to allow for the hook's return value to be resolved.
 *
 * The way this works:
 *
 * - The parent component (`FieldProvider`) renders the `FieldActionsResolver` component.
 * - The `FieldActionsResolver` component renders each field action as a child component.
 * - Each field action is a React hook that returns a node, and calls `setFieldAction` with its
 *   index and value.
 * - The `FieldActionsResolver` keeps a state with the array of hook values, making sure the array
 *   has the same length as the number of actions.
 * - The `FieldActionsResolver` calls `onActions` with the array of hook values.
 *
 * @internal
 */
export declare const FieldActionsResolver: React_2.NamedExoticComponent<FieldActionsProps>

/** @internal */
export declare function FieldChange(
  props: {
    change: FieldChangeNode
    readOnly?: boolean
    hidden?: boolean
  } & React_2.HTMLAttributes<HTMLDivElement>,
): React_2.JSX.Element | null

/** @internal */
export declare interface FieldChangeNode {
  type: 'field'
  diff: Diff
  itemDiff?: ItemDiff
  parentDiff?: ObjectDiff | ArrayDiff
  key: string
  path: Path
  error?: FieldValueError
  titlePath: ChangeTitlePath
  schemaType: ObjectFieldType
  showHeader: boolean
  showIndex: boolean
  diffComponent?: DiffComponent
  parentSchema?: ArraySchemaType | ObjectSchemaType
  readOnly?: ConditionalProperty
  hidden?: ConditionalProperty
}

/** @internal @deprecated DO NOT USE */
export declare interface FieldCommentsProps {
  hasComments: boolean
  button: React.ReactNode
  isAddingComment: boolean
}

/**
 * Represents an error that occurred in a specific field of a data object.
 * @public
 *
 * @remarks
 * This interface is used to provide detailed information about the error,
 * including the field name, the error type, and the error message.
 */
export declare interface FieldError {
  /**
   * The type of error that occurred.
   */
  kind: 'error'
  /**
   * The unique identifier for the error.
   */
  key: string
  /**
   * The name of the field that the error occurred in.
   */
  fieldName: string
  /**
   * The specific error that occurred.
   *
   * ```md
   * Possible error types include:
   * - IncompatibleTypeError
   * - TypeAnnotationMismatchError
   * - MissingKeysError
   * - DuplicateKeysError
   * - UndeclaredMembersError
   * - MixedArrayError
   * ```
   *
   * See {@link IncompatibleTypeError},
   * {@link TypeAnnotationMismatchError},
   * {@link MissingKeysError},
   * {@link DuplicateKeysError},
   * {@link UndeclaredMembersError} and
   * {@link MixedArrayError} for more information.
   *
   */
  error:
    | IncompatibleTypeError
    | TypeAnnotationMismatchError
    | MissingKeysError
    | DuplicateKeysError
    | UndeclaredMembersError
    | MixedArrayError
}

/**
 * Represents a field member in a form.
 * @public
 */
export declare interface FieldMember<Node extends BaseFormNode = BaseFormNode> {
  /** The kind of the form node. */
  kind: 'field'
  /** The key of the field. */
  key: string
  /** The name of the field. */
  name: string
  /** The index of the field. */
  index: number
  /** Whether the field is collapsed. */
  collapsed: boolean | undefined
  /** Whether the field is collapsible. */
  collapsible: boolean | undefined
  /** Whether the field is open. */
  open: boolean
  /**
   * @internal
   * Whether this field is in the selected group.
   */
  inSelectedGroup: boolean
  /**
   * @internal
   * Names of the field groups this field is part of.
   */
  groups: string[]
  /**
   * @hidden
   * @beta
   * The form node that represents this field.
   */
  field: Node
}

/**
 * @hidden
 * @beta */
export declare type FieldName = string

/** @internal */
export declare const fieldNeedsEscape: (fieldName: string) => boolean

/** @internal */
export declare interface FieldOperationsAPI {
  patch: {
    execute: (patches: PatchOperations[]) => void
  }
}

/** @internal */
export declare const FieldPresence: typeof FieldPresenceWithoutOverlay

/** @internal */
export declare type FieldPresenceData = {
  element: HTMLElement
  presence: FormNodePresence[]
  maxAvatars: number
}

/** @internal */
export declare const FieldPresenceInner: React_2.NamedExoticComponent<FieldPresenceInnerProps>

/** @internal */
export declare interface FieldPresenceInnerProps {
  maxAvatars?: number
  presence: FormNodePresence[]
  stack?: boolean
  position?: AvatarPosition
  animateArrowFrom?: AvatarPosition
}

/** @internal */
export declare interface FieldPresenceProps {
  presence: FormNodePresence[]
  maxAvatars: number
}

/** @internal */
export declare function FieldPresenceWithoutOverlay(
  props: FieldPresenceProps,
): React_2.JSX.Element | null

/** @internal */
export declare function FieldPresenceWithOverlay(props: FieldPresenceProps): React_2.JSX.Element

/** @internal */
export declare type FieldPreviewComponent<T = any> = ComponentType<{
  color?: UserColor
  schemaType: T extends Array<any>
    ? ArraySchemaType
    : T extends boolean
    ? BooleanSchemaType
    : T extends string
    ? StringSchemaType
    : T extends number
    ? NumberSchemaType
    : T extends Reference
    ? ReferenceSchemaType
    : T extends object
    ? ObjectSchemaType
    : any
  value: T
}>

/**
 * @hidden
 * @public */
export declare type FieldProps =
  | ObjectFieldProps
  | ObjectFieldProps<CrossDatasetReferenceValue>
  | ObjectFieldProps<FileValue>
  | ObjectFieldProps<GeopointValue>
  | ObjectFieldProps<ImageValue>
  | ObjectFieldProps<ReferenceValue>
  | ObjectFieldProps<SlugValue>
  | ArrayFieldProps
  | NumberFieldProps
  | BooleanFieldProps
  | StringFieldProps

/**
 * Represents a member of a field set.
 * @public
 */
export declare interface FieldSetMember {
  /** The kind of member. */
  kind: 'fieldSet'
  /** The key of the member. */
  key: string
  /**
   * Indicates whether the member is included in the currently selected group.
   * If it's hidden and in the currently selected group, it should still be excluded from its group.
   * @internal
   */
  _inSelectedGroup: boolean
  /** The names of the field groups the member belongs to. */
  groups: string[]
  /**
   * @hidden
   * @beta
   * The state of the field set.
   */
  fieldSet: FieldsetState
}

/**
 * @hidden
 * @beta */
export declare interface FieldsetState {
  path: Path
  name: string
  level: number
  title?: string
  description?: string
  hidden?: boolean
  collapsible?: boolean
  collapsed?: boolean
  columns?: number | number[]
  members: (FieldMember | FieldError)[]
}

/** @internal */
export declare interface FieldStatusProps {
  children?: React_2.ReactNode
  maxAvatars?: number
  position?: 'top' | 'bottom'
}

/** @internal */
export declare interface FieldValueError {
  message: string
  value: unknown
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FileComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<FileValue>>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ObjectInputProps<FileValue>>
  item?: ComponentType<ObjectItemProps<FileValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/**
 * @hidden
 * @beta */
export declare function FileInput(props: FileInputProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare type FileInputProps = Omit<
  BaseFileInputProps,
  'assetSources' | 'directUploads' | 'observeAsset' | 'resolveUploader' | 'client'
>

/**
 *
 * @hidden
 * @beta
 */
export declare interface FileLike {
  type: string
  name?: string
}

/** @internal */
export declare function findIndex(array: unknown[], segment: PathSegment): number

/** @internal */
export declare type FIXME = any

/** @internal */
export declare type FIXME_SanityDocument = Record<string, unknown>

/**
 * @internal
 *
 * This function flattens the config tree into a list of configs in the order they should be applied.
 */
export declare const flattenConfig: (
  {plugins, ...currentConfig}: PluginOptions,
  path: string[],
) => {
  config: PluginOptions
  path: string[]
}[]

/**
 * @alpha
 */
export declare function FormBuilder(props: FormBuilderProps): React_2.JSX.Element

/** @internal */
export declare interface FormBuilderComponentResolverContext extends ConfigContext {
  schemaType: SchemaType
}

/**
 * @internal
 */
export declare const FormBuilderContext: Context<FormBuilderContextValue | null>

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormBuilderContextValue {
  /**
   * @deprecated INTERNAL USE ONLY
   * @internal
   */
  __internal: {
    components: {
      CustomMarkers: FormBuilderCustomMarkersComponent
      Markers: FormBuilderMarkersComponent
    }
    field: {
      actions: DocumentFieldAction[]
    }
    file: {
      assetSources: AssetSource[]
      directUploads: boolean
    }
    filterField: FormBuilderFilterFieldFn
    image: {
      assetSources: AssetSource[]
      directUploads: boolean
    }
    getDocument: () => SanityDocument | undefined
    patchChannel: PatchChannel
  }
  autoFocus?: boolean
  changesOpen?: boolean
  collapsedFieldSets: StateTree<boolean> | undefined
  collapsedPaths: StateTree<boolean> | undefined
  focusPath: Path
  focused?: boolean
  groups: FormFieldGroup[]
  id: string
  members: ObjectMember[]
  readOnly?: boolean
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderItemCallback
  renderPreview: RenderPreviewCallback
  schemaType: ObjectSchemaType
  value:
    | {
        [field in string]: unknown
      }
    | undefined
}

/**
 * Component for rendering custom block markers
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
export declare type FormBuilderCustomMarkersComponent = React_2.ComponentType<{
  markers: PortableTextMarker[]
}>

/**
 * @internal
 */
export declare interface FormBuilderFilterFieldFn {
  (type: ObjectSchemaType, field: ObjectField, selectedLanguageIds: string[]): boolean
}

/**
 *
 * @hidden
 * @beta
 */
export declare type FormBuilderInputComponentMap = Record<
  string,
  {
    field?: React_2.ComponentType<FieldProps>
    item?: React_2.ComponentType<ItemProps>
    input?: React_2.ComponentType<InputProps>
    preview?: React_2.ComponentType<PreviewProps>
  }
>

/**
 *
 * @hidden
 * @beta
 */
export declare type FormBuilderMarkersComponent = React_2.ComponentType<{
  markers: PortableTextMarker[]
  renderCustomMarkers?: RenderCustomMarkers
  validation: FormNodeValidation[]
}>

/**
 * @alpha
 */
export declare interface FormBuilderProps
  extends Omit<ObjectFormNode, 'level' | 'path' | 'presence' | 'validation' | '_allMembers'> {
  /** @internal */
  __internal_fieldActions?: DocumentFieldAction[]
  /** @internal Considered internal – do not use. */
  __internal_patchChannel: PatchChannel
  autoFocus?: boolean
  changesOpen?: boolean
  collapsedFieldSets: StateTree<boolean> | undefined
  collapsedPaths: StateTree<boolean> | undefined
  focusPath: Path
  focused: boolean | undefined
  id: string
  onChange: (changeEvent: PatchEvent) => void
  onPathBlur: (path: Path) => void
  onPathFocus: (path: Path) => void
  onPathOpen: (path: Path) => void
  onFieldGroupSelect: (path: Path, groupName: string) => void
  onSetFieldSetCollapsed: (path: Path, collapsed: boolean) => void
  onSetPathCollapsed: (path: Path, collapsed: boolean) => void
  presence: FormNodePresence[]
  readOnly?: boolean
  schemaType: ObjectSchemaType
  validation: ValidationMarker[]
  value:
    | {
        [field in string]: unknown
      }
    | undefined
}

/**
 * @internal
 */
export declare const FormCallbacksContext: React_2.Context<FormCallbacksValue | null>

/** @internal */
export declare const FormCallbacksProvider: React_2.NamedExoticComponent<
  FormCallbacksValue & {
    children: React_2.ReactNode
  }
>

/** @internal */
export declare interface FormCallbacksValue {
  transformPatches?: (patches: FormPatch[]) => FormPatch[]
  onChange: (patchEvent: PatchEvent) => void
  onPathFocus: (path: Path) => void
  onPathBlur: (path: Path) => void
  onPathOpen: (path: Path) => void
  onSetPathCollapsed: (path: Path, collapsed: boolean) => void
  onSetFieldSetCollapsed: (path: Path, collapsed: boolean) => void
  onFieldGroupSelect: (path: Path, fieldGroupName: string) => void
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormDecPatch extends FormPatchBase {
  path: Path
  type: 'dec'
  origin?: FormPatchOrigin
  value: FormPatchJSONValue
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormDiffMatchPatch extends FormPatchBase {
  path: Path
  type: 'diffMatchPatch'
  origin?: FormPatchOrigin
  value: string
}

/** @internal */
export declare const FormField: React_2.NamedExoticComponent<
  FormFieldProps & Omit<React_2.HTMLProps<HTMLDivElement>, 'ref' | 'height' | 'as'>
>

/**
 * @hidden
 * @beta */
export declare interface FormFieldGroup {
  name: string
  selected?: boolean
  disabled?: boolean
  title?: string
  icon?: React_2.ComponentType
}

/** @internal */
export declare const FormFieldHeaderText: React_2.NamedExoticComponent<FormFieldHeaderTextProps>

/** @internal */
export declare interface FormFieldHeaderTextProps {
  /**
   *
   * @hidden
   * @beta
   */
  validation?: FormNodeValidation[]
  description?: React_2.ReactNode
  /**
   * The unique ID used to target the actual input element
   */
  inputId?: string
  title?: React_2.ReactNode
}

/** @internal */
export declare const FormFieldPresenceContext: React_2.Context<FormNodePresence[]>

/** @internal */
export declare interface FormFieldProps {
  /**
   * @hidden
   * @beta
   */
  __unstable_headerActions?: DocumentFieldActionNode[]
  /**
   * @hidden
   * @beta
   */
  __unstable_presence?: FormNodePresence[]
  /** @internal @deprecated DO NOT USE */
  __internal_comments?: FieldCommentsProps
  /** @internal @deprecated ONLY USED BY AI ASSIST PLUGIN */
  __internal_slot?: React_2.ReactNode
  children: React_2.ReactNode
  description?: React_2.ReactNode
  /**
   * The unique ID used to target the actual input element
   */
  inputId?: string
  /**
   * The nesting level of the form field
   */
  level?: number
  title?: React_2.ReactNode
  /**
   * @beta
   */
  validation?: FormNodeValidation[]
}

/** @internal */
export declare const FormFieldSet: React_2.ForwardRefExoticComponent<
  FormFieldSetProps &
    Omit<React_2.HTMLProps<HTMLDivElement>, 'ref' | 'height' | 'as'> &
    React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare interface FormFieldSetProps {
  /**
   *
   * @hidden
   * @beta
   */
  __unstable_headerActions?: DocumentFieldActionNode[]
  /**
   * @beta
   */
  __unstable_presence?: FormNodePresence[]
  /** @internal @deprecated DO NOT USE */
  __internal_comments?: FieldCommentsProps
  /** @internal @deprecated ONLY USED BY AI ASSIST PLUGIN */
  __internal_slot?: React_2.ReactNode
  children: React_2.ReactNode | (() => React_2.ReactNode)
  collapsed?: boolean
  collapsible?: boolean
  columns?: number | number[]
  description?: React_2.ReactNode
  /**
   * The nesting level of the form field set
   */
  level?: number
  onCollapse?: () => void
  onExpand?: () => void
  title?: React_2.ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  validation?: FormNodeValidation[]
  inputId: string
}

/** @internal */
export declare function FormFieldStatus({
  children,
  maxAvatars,
  position,
}: FieldStatusProps): React_2.JSX.Element

/** @internal */
export declare type FormFieldValidation =
  | FormFieldValidationWarning
  | FormFieldValidationError
  | FormFieldValidationInfo

/** @internal */
export declare interface FormFieldValidationError {
  type: 'error'
  label: string
}

/** @internal */
export declare interface FormFieldValidationInfo {
  type: 'info'
  label: string
}

/** @internal */
export declare function FormFieldValidationStatus(
  props: FormFieldValidationStatusProps,
): React_2.JSX.Element

/** @internal */
export declare interface FormFieldValidationStatusProps {
  /**
   *
   * @hidden
   * @beta
   */
  validation?: FormNodeValidation[]
  /**
   *
   * @hidden
   * @beta
   */
  __unstable_showSummary?: boolean
  fontSize?: number | number
  placement?: Placement
}

/** @internal */
export declare interface FormFieldValidationWarning {
  type: 'warning'
  label: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormIncPatch extends FormPatchBase {
  path: Path
  type: 'inc'
  origin?: FormPatchOrigin
  value: FormPatchJSONValue
}

/** @internal */
export declare const FormInput: React_2.NamedExoticComponent<
  (
    | ArrayOfObjectsInputProps<
        {
          _key: string
        },
        ArraySchemaType<unknown>
      >
    | ObjectInputProps<Record<string, any>, ObjectSchemaType>
  ) &
    (FormInputAbsolutePathArg | FormInputRelativePathArg) & {
      /**
       * Whether to include the field around the input. Defaults to false
       */
      includeField?: boolean | undefined
    }
>

/** @internal */
export declare type FormInputAbsolutePathArg = {
  absolutePath: Path
}

/** @internal */
export declare type FormInputRelativePathArg = {
  relativePath: Path
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormInsertPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'insert'
  position: FormInsertPatchPosition
  items: FormPatchJSONValue[]
}

/**
 *
 * @hidden
 * @beta
 */
export declare type FormInsertPatchPosition = 'before' | 'after'

/**
 * @hidden
 * @public */
export declare interface FormNodePresence {
  user: User
  path: Path
  sessionId: string
  lastActiveAt: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare type FormPatch =
  | FormSetPatch
  | FormSetIfMissingPatch
  | FormUnsetPatch
  | FormInsertPatch
  | FormDiffMatchPatch

/**
 * @hidden
 * @beta */
export declare interface FormPatchBase {
  /**
   * A property used to identify this as a Sanity patch type, eg "set", "unset", "insert", etc.
   * This allows us to potentially introduce new patch types in the future without breaking
   * existing code. This is an internal property/implementation detail and should not be used by
   * consumers.
   *
   * @internal
   */
  patchType: symbol
}

/**
 *
 * @hidden
 * @beta
 */
export declare type FormPatchJSONValue =
  | number
  | string
  | boolean
  | {
      [key: string]: FormPatchJSONValue
    }
  | FormPatchJSONValue[]

/**
 *
 * @hidden
 * @beta
 */
export declare type FormPatchOrigin = 'remote' | 'local' | 'internal'

/**
 * Default wiring for `FormBuilderProvider` when used with Sanity
 *
 * @alpha This API might change.
 */
export declare function FormProvider(props: FormProviderProps): React_2.JSX.Element

/**
 * @alpha This API might change.
 */
export declare interface FormProviderProps {
  /** @internal */
  __internal_fieldActions?: DocumentFieldAction[]
  /** @internal Considered internal, do not use. */
  __internal_patchChannel: PatchChannel
  autoFocus?: boolean
  changesOpen?: boolean
  children?: React_2.ReactNode
  collapsedFieldSets: StateTree<boolean> | undefined
  collapsedPaths: StateTree<boolean> | undefined
  focusPath: Path
  focused: boolean | undefined
  groups: FormFieldGroup[]
  id: string
  members: ObjectMember[]
  onChange: (changeEvent: PatchEvent) => void
  onPathBlur: (path: Path) => void
  onPathFocus: (path: Path) => void
  onPathOpen: (path: Path) => void
  onFieldGroupSelect: (path: Path, groupName: string) => void
  onSetPathCollapsed: (path: Path, collapsed: boolean) => void
  onSetFieldSetCollapsed: (path: Path, collapsed: boolean) => void
  presence: FormNodePresence[]
  readOnly?: boolean
  schemaType: ObjectSchemaType
  validation: ValidationMarker[]
  value:
    | {
        [field in string]: unknown
      }
    | undefined
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormSetIfMissingPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'setIfMissing'
  value: FormPatchJSONValue
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormSetPatch extends FormPatchBase {
  path: Path
  type: 'set'
  origin?: FormPatchOrigin
  value: FormPatchJSONValue
}

/** @internal */
export declare type FormState<
  T extends {
    [key in string]: unknown
  } = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType,
> = ObjectFormNode<T, S>

/**
 *
 * @hidden
 * @beta
 */
export declare interface FormUnsetPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'unset'
}

/**
 * @internal
 */
export declare function fromMutationPatches(
  origin: FormPatchOrigin,
  patches: MutationPatch[],
): FormPatch[]

/** @internal */
export declare const FromTo: React_2.ForwardRefExoticComponent<
  Omit<FromToProps, 'ref'> & React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare function FromToArrow(
  props: {
    direction?: FromToArrowDirection
  } & TextProps &
    Omit<React_2.HTMLProps<HTMLDivElement>, 'children' | 'ref'>,
): React_2.JSX.Element

/** @internal */
export declare type FromToArrowDirection = 'down' | 'right'

/** @internal */
export declare interface FromToIndex {
  hasMoved: boolean
  fromIndex?: number
  toIndex?: number
  annotation?: Annotation
}

/** @internal */
export declare type FromToProps = {
  align?: 'top' | 'center' | 'bottom'
  layout?: 'grid' | 'inline'
  from?: React_2.ReactNode
  to?: React_2.ReactNode
} & Omit<React_2.HTMLProps<HTMLDivElement>, 'children' | 'as' | 'height' | 'wrap'>

/**
 * General preview layout key
 *
 * @public
 */
export declare type GeneralPreviewLayoutKey = 'default' | 'media' | 'detail'

/**
 *
 * @hidden
 * @beta
 */
export declare interface GeopointComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<GeopointValue>>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ObjectInputProps<GeopointValue>>
  item?: ComponentType<ObjectItemProps<GeopointValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare function getAnnotationAtPath(
  diff: Diff,
  diffPath: string | Path,
): Annotation | undefined

/** @internal */
export declare function getAnnotationColor(
  colorManager: UserColorManager,
  annotation?: Annotation | null,
): UserColor

/** @internal */
export declare function getChangeVerb(diff: Diff): 'Added' | 'Removed' | 'Changed'

/**
 * Reduce a {@link Source} down to a {@link ConfigContext}, without memoization - use for non-react contexts
 *
 * @param source - Source to convert
 * @returns A config context containing only the defined properties of that interface
 * @internal
 */
export declare function getConfigContextFromSource(source: Source): ConfigContext

/** @internal */
export declare function getDiffAtPath(diff: Diff, diffPath: string | Path): Diff | undefined

/**
 * The observable version of `useDocumentPairPermissions`
 *
 * @see useDocumentPairPermissions
 *
 * @internal
 */
export declare function getDocumentPairPermissions({
  client,
  grantsStore,
  schema,
  id,
  permission,
  type,
}: DocumentPairPermissionsOptions): Observable<PermissionCheckResult>

/**
 * The observable version of `useDocumentValuePermissions`
 *
 * @see useDocumentValuePermissions
 *
 * @internal
 */
export declare function getDocumentValuePermissions({
  grantsStore,
  document,
  permission,
}: DocumentValuePermissionsOptions): Observable<PermissionCheckResult>

/** @internal */
export declare function getDraftId(id: string): DraftId

/**
 * This takes a form state and returns a list of operations required to open a node at a particular path
 * @param node - The base form node (i.e. the form state node for the _document_)
 * @param path - The path to open
 *
 * @internal
 */
export declare function getExpandOperations(node: BaseFormNode, path: Path): ExpandOperation[]

/** @internal */
export declare function GetHookCollectionState<T, K>(
  props: GetHookCollectionStateProps<T, K>,
): React_2.JSX.Element

/** @internal */
export declare interface GetHookCollectionStateProps<T, K> {
  args: T
  children: (props: {states: K[]}) => React_2.ReactNode
  hooks: ActionHook<T, K>[]
  onReset?: () => void
}

/** @internal */
export declare function getIdPair(id: string): {
  draftId: DraftId
  publishedId: PublishedId
}

/**
 * @internal
 */
export declare function getInitialValueStream(
  schema: Schema,
  initialValueTemplates: Template[],
  documentPreviewStore: DocumentPreviewStore,
  opts: InitialValueOptions,
  context: InitialValueResolverContext,
): Observable<InitialValueMsg>

/** @internal */
export declare function getItemKey(arrayItem: unknown): string | undefined

/** @internal */
export declare function getItemKeySegment(arrayItem: unknown): KeyedSegment | undefined

/** @internal */
export declare function getNamelessWorkspaceIdentifier(
  title: string | undefined,
  index: number,
): string

/** @internal */
export declare function getPairListener(
  client: SanityClient,
  idPair: IdPair,
  options?: PairListenerOptions,
): Observable<ListenerEvent>

/** @internal */
export declare function getPreviewPaths(preview: SchemaType['preview']): PreviewPath[] | undefined

/**
 * Obtain a document's published and draft state, along with loading status.
 *
 * @internal
 */
export declare function getPreviewStateObservable(
  documentPreviewStore: DocumentPreviewStore,
  schemaType: SchemaType,
  documentId: string,
  title: React_2.ReactNode,
): Observable<PreviewState>

/**
 * Obtain document preview values used in <SanityPreview> and <SanityDefaultPreview> components.
 * Also displays fallback values if the document cannot be found.
 *
 * @internal
 */
export declare const getPreviewValueWithFallback: ({
  value,
  draft,
  published,
}: {
  value: SanityDocument
  draft?: PreviewValue | Partial<SanityDocument> | null | undefined
  published?: PreviewValue | Partial<SanityDocument> | null | undefined
}) =>
  | PreviewValue
  | {
      title: React_2.JSX.Element
      subtitle: React_2.JSX.Element
      media: () => React_2.JSX.Element
    }

/** @internal */
export declare function getProviderTitle(provider?: string): string | undefined

/** @internal */
export declare function getPublishedId(id: string): PublishedId

/**
 * Get the most specific defined title of a schema type
 * If not set directly on the given type, it will traverse up the tree until it
 * finds one, falling back to the _name_ of the type.
 *
 * @param type - The schema type to get the title of
 * @returns A title, alternatively the schema type _name_
 * @internal
 */
export declare function getSchemaTypeTitle(type: SchemaType): string

/**
 * The observable version of `useTemplatePermissions`
 *
 * @internal
 */
export declare function getTemplatePermissions({
  grantsStore,
  templateItems,
  templates,
  schema,
  context,
}: TemplatePermissionsOptions): Observable<
  Array<TemplatePermissionsResult<Record<string, unknown>>>
>

/** @internal */
export declare function getValueAtPath(rootValue: unknown, path: Path): unknown

/** @internal */
export declare function getValueError(
  value: unknown,
  schemaType: SchemaType,
): FieldValueError | undefined

/**
 * Gets a printable identifer for the workspace - either the name, or the index
 * and any potential title set for it
 *
 * @param workspace - The workspace to get the indentifier for
 * @param index - The index at which the workspace appeared in the source array
 * @returns Printable string (eg `intranet`, or `at index 5 (titled "Intranet")`)
 * @internal
 */
export declare function getWorkspaceIdentifier({name, title}: WorkspaceLike, index: number): string

/** @internal */
export declare interface GlobalErrorChannel {
  subscribe: (subscriber: GlobalErrorSubscriber) => GlobalErrorUnsubscriber
}

/** @internal */
export declare function GlobalErrorHandler(): React_2.JSX.Element

/** @internal */
export declare interface GlobalErrorMessage {
  error: Error | null
  params: {
    colno: number
    lineno: number
    error: Error
    event: ErrorEvent | string
    source?: string
  }
}

/** @internal */
export declare type GlobalErrorSubscriber = (msg: GlobalErrorMessage) => void

/** @internal */
export declare type GlobalErrorUnsubscriber = () => void

/** @internal */
export declare type GlobalPresence = {
  user: User
  status: Status
  lastActiveAt: string
  locations: PresenceLocation[]
}

/** @internal */
export declare const globalScope: typeof globalThis & {
  __sanityErrorChannel?: GlobalErrorChannel | undefined
}

/** @internal */
export declare interface Grant {
  filter: string
  permissions: DocumentValuePermission[]
}

/**
 * @hidden
 * @beta */
export declare interface GrantsStore {
  /**
   * Returns an observable of `PermissionCheckResult`
   *
   * This API is returns an observable (vs a promise) so the consumer can reac
   * to incoming changes to the user permissions (e.g. for changing _debug_
   * roles).
   *
   * This API also accepts a `null` document in which it should return
   * `granted: true`
   */
  checkDocumentPermission(
    checkPermissionName: DocumentValuePermission,
    document: Partial<SanityDocument> | null,
  ): Observable<PermissionCheckResult>
}

/** @internal */
export declare interface GrantsStoreOptions {
  client: SanityClient
  currentUser: CurrentUser | null
}

/** @internal */
export declare function GroupChange(
  props: {
    change: GroupChangeNode
    readOnly?: boolean
    hidden?: boolean
  } & React_2.HTMLAttributes<HTMLDivElement>,
): React_2.ReactElement | null

/**
 * Schema
 */
/**
 * "Changes" (presentation-oriented grouping of diffs)
 *
 * @internal
 */
export declare interface GroupChangeNode {
  type: 'group'
  changes: ChangeNode[]
  key: string
  path: Path
  titlePath: ChangeTitlePath
  schemaType?: SchemaType
  readOnly?: ConditionalProperty
  hidden?: ConditionalProperty
  fieldsetName?: string
}

declare type GuardedOperation = Operation<any[], 'NOT_READY'>

/**
 * An example of how to sync focus path through document.location.hash
 *
 * @internal
 */
export declare function HashFocusManager(props: HashFocusManagerProps): any

/** @internal */
export declare type HashFocusManagerChildArgs = {
  onFocus: (path: Path) => void
  onBlur: () => void
  focusPath: Path
}

/** @internal */
export declare interface HashFocusManagerProps {
  focusPath: any | null
  onFocus: () => void
  onBlur: () => void
  children: (arg0: HashFocusManagerChildArgs) => any
}

/** @internal */
export declare type HexColor = string

/** @internal */
export declare interface HiddenField {
  kind: 'hidden'
  key: string
  name: string
  index: number
}

/**
 * @hidden
 * @beta */
export declare interface HistoryStore {
  getDocumentAtRevision: (
    documentId: string,
    revision: string,
  ) => Promise<SanityDocument | undefined>
  getHistory: (
    documentIds: string[],
    options?: {
      time?: string
      revision?: string
    },
  ) => Promise<{
    documents: SanityDocument[]
  }>
  getTransactions: (documentIds: string[]) => Promise<TransactionLogEventWithMutations[]>
  restore: (id: string, targetId: string, rev: string) => Observable<SanityDocument>
  /** @internal */
  getTimelineController: (options: {
    client: SanityClient
    documentId: string
    documentType: string
  }) => TimelineController
}

/** @internal */
export declare interface HistoryStoreOptions {
  client: SanityClient
}

/**
 * Renders given `keys` as "keycaps" visually.
 *
 * This is a wrapper around `@sanity/ui`'s `Hotkeys` component, which allows for altering keys
 * (eg `alt` to `option`) on Apple devices unless `makePlatformAware` is set to `false`.
 *
 * @param props - Properties to render with
 * @returns React element
 * @public
 */
export declare function Hotkeys({
  makePlatformAware,
  keys: hotKeys,
  ...props
}: HotkeysProps): React_2.JSX.Element

/**
 * Properties for the `Hotkeys` component.
 *
 * @public
 */
export declare type HotkeysProps = HotkeysProps_2 & {
  /**
   * Whether to make the keys platform-aware (eg `alt` to `option` on Apple devices).
   *
   * @defaultValue true
   */
  makePlatformAware?: boolean
} & Omit<HTMLProps<HTMLElement>, 'ref' | 'size' | 'as'> &
  RefAttributes<HTMLElement>

/** @internal */
declare interface HoveredFieldContextValue {
  hoveredStack: string[]
  onMouseEnter: (path: Path) => void
  onMouseLeave: (path: Path) => void
}

/** @internal */
export declare function HoveredFieldProvider(props: PropsWithChildren): React_2.JSX.Element

/** @internal */
export declare type Id = string

/** @internal */
export declare interface IdPair {
  draftId: string
  publishedId: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface ImageComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<ImageValue>>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ObjectInputProps<ImageValue>>
  item?: ComponentType<ObjectItemProps<ImageValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/**
 * @hidden
 * @beta */
export declare function ImageInput(props: ImageInputProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare type ImageInputProps = Omit<
  BaseImageInputProps,
  | 'assetSources'
  | 'directUploads'
  | 'imageUrlBuilder'
  | 'observeAsset'
  | 'client'
  | 'resolveUploader'
>

/**
 * @hidden
 * @beta */
export declare type ImageUrlBuilder = ReturnType<typeof imageUrlBuilder>

/** @internal */
export declare const ImperativeToast: React_2.ForwardRefExoticComponent<
  React_2.RefAttributes<unknown>
>

/**
 * @hidden
 * @beta */
export declare function inc(amount?: number, path?: Path): FormIncPatch

/**
 * This error may happen if the member type is structurally incompatible with the defined schema type.
 * Some examples:
 *   - the schema type defines an array, but the actual value is an object (or vice versa)
 *   - the schema type defines a number, but the actual value is a string (or vice versa)
 *   - the schema type defines an object, but the actual value is a string (or vice versa)
 *
 * @public
 */
export declare type IncompatibleTypeError = {
  type: 'INCOMPATIBLE_TYPE'
  expectedSchemaType: SchemaType
  resolvedValueType: string
  value: unknown
}

/** @internal */
export declare const initialDocumentFieldActions: DocumentFieldAction[]

/** @internal */
export declare interface InitialSnapshotEvent {
  type: 'snapshot'
  documentId: string
  document: SanityDocument | null
}

/**
 * @hidden
 * @beta */
export declare interface InitialValueErrorMsg {
  type: 'error'
  error: Error
}

/**
 * @hidden
 * @beta */
export declare interface InitialValueLoadingMsg {
  type: 'loading'
}

/**
 * @hidden
 * @beta */
export declare type InitialValueMsg =
  | InitialValueLoadingMsg
  | InitialValueSuccessMsg
  | InitialValueErrorMsg

/**
 * @hidden
 * @beta */
export declare interface InitialValueOptions {
  documentId: string
  documentType: string
  templateName?: string
  templateParams?: Record<string, any>
}

/** @internal */
export declare interface InitialValueState {
  loading: boolean
  error: Error | null
  value: SanityDocumentLike
}

/**
 * @hidden
 * @beta */
export declare interface InitialValueSuccessMsg {
  type: 'success'
  value: SanityDocumentLike | null
}

/**
 * Representation of an initial value template _item_
 * Used by the {@link desk.StructureBuilder} class to determine which initial value templates
 * should be available for a desk structure node, such as a list pane.
 *
 * @public
 */
export declare interface InitialValueTemplateItem extends TemplateItem {
  type: 'initialValueTemplateItem'
  /** ID for this template item */
  id: string
  /** Initial value template schema type */
  schemaType: string
}

/**
 * @hidden
 * @beta */
export declare function InlinePreview(props: InlinePreviewProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare type InlinePreviewProps = Omit<PreviewProps<'inline'>, 'renderDefault'>

/**
 * @hidden
 * @public */
export declare type InputProps =
  | ArrayOfObjectsInputProps
  | ArrayOfPrimitivesInputProps
  | BooleanInputProps
  | NumberInputProps
  | ObjectInputProps
  | ObjectInputProps<CrossDatasetReferenceValue>
  | ObjectInputProps<FileValue>
  | ObjectInputProps<GeopointValue>
  | ObjectInputProps<ImageValue>
  | ObjectInputProps<ReferenceValue>
  | ObjectInputProps<SlugValue>
  | PortableTextInputProps
  | StringInputProps

/**
 * @hidden
 * @beta */
export declare function insert(
  items: any[],
  position: FormInsertPatchPosition,
  path?: Path,
): FormInsertPatch

/** @internal */
export declare function InsufficientPermissionsMessage(
  props: InsufficientPermissionsMessageProps,
): React_2.JSX.Element

/** @internal */
export declare interface InsufficientPermissionsMessageProps {
  title?: string
  operationLabel?: string
  currentUser?: CurrentUser | null
}

/**
 *
 * @hidden
 * @beta
 */
export declare function IntentButton(
  props: IntentLinkProps & ButtonProps & Omit<HTMLProps<HTMLButtonElement>, 'as' | 'href' | 'ref'>,
): React_2.JSX.Element

/**
 * Intent parameters (json)
 *
 * @public
 */
declare type IntentJsonParams = {[key: string]: any}

/**
 * Props for the {@link IntentLink} component.
 *
 * @public
 */
declare interface IntentLinkProps {
  /**
   * The name of the intent.
   */
  intent: string

  /**
   * The parameters to include in the intent.
   * {@link IntentParameters}
   */
  params?: IntentParameters

  /**
   * Whether to replace the current URL in the browser history instead of adding a new entry.
   */
  replace?: boolean
}

/**
 * @public
 * @todo dedupe with intent types in core
 */
declare type IntentParameters = BaseIntentParams | [BaseIntentParams, IntentJsonParams]

declare interface IntermediaryError {
  type: 'error'
  args: ExecuteArgs
  error: any
}

declare interface IntermediarySuccess {
  type: 'success'
  args: ExecuteArgs
}

/**
 * This error may happen for arrays (of both objects and primitive values) if we encounter items that are not valid according to the schema definition
 *
 *
 * @hidden
 * @beta
 */
export declare type InvalidItemTypeError = {
  type: 'INVALID_ITEM_TYPE'
  validTypes: SchemaType[]
  resolvedValueType: string
  value: unknown
}

/** @internal */
export declare function isAddedItemDiff(item: ItemDiff): item is ItemDiff & {
  diff: Diff & {
    action: 'added'
  }
}

/** @internal */
export declare function isArray(value: unknown): value is unknown[]

/**
 * @hidden
 * @beta */
export declare function isArrayOfBlocksInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>,
): inputProps is ArrayOfObjectsInputProps

/**
 * @hidden
 * @beta */
export declare function isArrayOfObjectsInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>,
): inputProps is ArrayOfObjectsInputProps

/**
 * @hidden
 * @beta */
export declare function isArrayOfPrimitivesInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>,
): inputProps is ArrayOfPrimitivesInputProps

/**
 * Duck-type check for whether or not this looks like an auth store
 *
 * @param maybeStore - Item to check if matches the AuthStore interface
 * @returns True if auth store, false otherwise
 * @internal
 */
export declare function isAuthStore(maybeStore: unknown): maybeStore is AuthStore

/**
 * @hidden
 * @beta */
export declare function isBooleanInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>,
): inputProps is BooleanInputProps

/** @internal */
export declare function isBuilder(template: unknown): template is Serializeable<Template>

/**
 * @internal
 */
export declare function _isCustomDocumentTypeDefinition(
  def: SchemaTypeDefinition,
): def is SchemaTypeDefinition<'document'>

/** @internal */
export declare const isDev: boolean

/** @internal */
export declare function isDraft(document: SanityDocument): boolean

/** @internal */
export declare function isDraftId(id: string): id is DraftId

/** @internal */
export declare function isEmptyObject(item: unknown): boolean

/** @internal */
export declare type IsEqualFunction<Value> = (a: Value, b: Value) => boolean

/** @internal */
export declare function isFieldChange(change: ChangeNode): change is FieldChangeNode

/** @internal */
export declare function isGroupChange(change: ChangeNode): change is GroupChangeNode

/**
 * @internal
 */
export declare function isNonNullable<T>(value: T): value is NonNullable<T>

/**
 * @hidden
 * @beta */
export declare function isNumberInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>,
): inputProps is NumberInputProps

/**
 * @hidden
 * @beta */
export declare function isObjectInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>,
): inputProps is ObjectInputProps

/**
 * @hidden
 * @beta */
export declare function isObjectItemProps(
  item: ItemProps | Omit<ItemProps, 'renderDefault'>,
): item is ObjectItemProps

/** @internal */
export declare const isProd: boolean

/** @internal */
export declare function isPublishedId(id: string): id is PublishedId

/**
 * @internal
 */
export declare function isRecord(value: unknown): value is Record<string, unknown>

/** @internal */
export declare function isRemovedItemDiff(item: ItemDiff): item is ItemDiff & {
  diff: Diff & {
    action: 'removed'
  }
}

/**
 * @internal
 */
export declare function _isSanityDocumentTypeDefinition(
  def: SchemaTypeDefinition,
): def is SchemaTypeDefinition<'document'>

/** @internal */
export declare function isString(value: unknown): value is string

/**
 * @hidden
 * @beta */
export declare function isStringInputProps(
  inputProps: InputProps | Omit<InputProps, 'renderDefault'>,
): inputProps is StringInputProps

/** @internal */
export declare function isTruthy<T>(value: T | false): value is T

/** @internal */
export declare function isUnchangedDiff(diff: Diff): diff is Diff & {
  action: 'unchanged'
}

/** @internal */
export declare type ItemDiff = ItemDiff_2<Annotation>

/** @public */
export declare type ItemProps =
  | ObjectItemProps
  | ObjectItemProps<CrossDatasetReferenceValue & ObjectItem>
  | ObjectItemProps<FileValue & ObjectItem>
  | ObjectItemProps<GeopointValue & ObjectItem>
  | ObjectItemProps<ImageValue & ObjectItem>
  | ObjectItemProps<ReferenceValue & ObjectItem>
  | ObjectItemProps<SlugValue & ObjectItem>
  | PrimitiveItemProps

/** @internal */
export declare const joinPath: (pathArray: SearchPathSegment[]) => string

/**
 * @hidden
 * @beta */
export declare interface LayoutProps {
  renderDefault: (props: LayoutProps) => React_2.ReactElement
}

/**
 * This component should only be used by core Sanity packages.
 * @internal
 */
export declare function LegacyLayerProvider({
  children,
  zOffset: zOffsetKey,
}: {
  children: React_2.ReactNode
  zOffset: ZIndexContextValueKey
}): React_2.JSX.Element

/**
 * Properties that can be used to override the default theme.
 *
 * @public
 */
export declare interface LegacyThemeProps {
  '--font-family-monospace': string
  '--font-family-base': string
  '--black': string
  '--white': string
  '--brand-primary': string
  '--component-bg': string
  '--component-text-color': string
  '--default-button-color': string
  '--default-button-primary-color': string
  '--default-button-success-color': string
  '--default-button-warning-color': string
  '--default-button-danger-color': string
  '--focus-color': string
  '--gray-base': string
  '--gray': string
  '--main-navigation-color': string
  '--main-navigation-color--inverted': string
  '--state-info-color': string
  '--state-success-color': string
  '--state-warning-color': string
  '--state-danger-color': string
  '--screen-medium-break': string
  '--screen-default-break': string
  '--screen-large-break': string
  '--screen-xlarge-break': string
}

/** @internal */
export declare type LegacyThemeTints = {
  [key in ColorTintKey]: string
}

/**
 * @hidden
 * @beta */
export declare function LinearProgress(props: {
  /** Percentage */
  value: number
}): React_2.JSX.Element

/** @internal */
export declare type ListenerEvent =
  | MutationEvent_2
  | ReconnectEvent
  | InitialSnapshotEvent
  | PendingMutationsEvent

/** @internal */
export declare function listenQuery(
  client: SanityClient,
  query:
    | string
    | {
        fetch: string
        listen: string
      },
  params?: ListenQueryParams,
  options?: ListenQueryOptions,
): Observable<any>

/**
 * @hidden
 * @beta */
export declare interface ListenQueryOptions {
  tag?: string
  apiVersion?: string
  perspective?: ClientPerspective
  throttleTime?: number
  transitions?: ('update' | 'appear' | 'disappear')[]
}

/** @internal */
export declare type ListenQueryParams = Record<string, string | number | boolean | string[]>

/** @internal */
export declare type LoadableState<T> = LoadingState | LoadedState<T> | ErrorState

/** @internal */
export declare interface LoadedState<T> {
  value: T
  error: null
  isLoading: false
}

/** @internal */
export declare interface LoadingState {
  value: undefined
  error: null
  isLoading: true
}

/** @internal */
export declare type LoadingTuple<T> = [T, boolean]

/** @internal */
declare interface Location_2 {
  documentId: string
  path: Path
}
export {Location_2 as Location}

/**
 * @beta
 * @hidden
 */
export declare interface LoginComponentProps {
  projectId: string
  basePath: string
}

/**
 * @hidden
 * @beta */
export declare interface LogoProps {
  title: string
  renderDefault: (props: LogoProps) => React_2.ReactElement
}

/**
 * Given a pathname and a list of workspaces, returns either a workspace match,
 * a redirect, or not-found.
 *
 * @internal
 */
export declare function matchWorkspace({
  pathname,
  workspaces,
  basePathRegex,
}: MatchWorkspaceOptions): MatchWorkspaceResult

/** @internal */
export declare interface MatchWorkspaceOptions {
  workspaces: NormalizedWorkspace[]
  pathname: string
  basePathRegex: RegExp
}

/** @internal */
export declare type MatchWorkspaceResult =
  | {
      type: 'match'
      workspace: WorkspacesContextValue[number]
    }
  | {
      type: 'redirect'
      pathname: string
    }
  | {
      type: 'not-found'
    }

/**
 * @hidden
 * @beta */
export declare function MediaPreview(props: MediaPreviewProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare type MediaPreviewProps = Omit<PreviewProps<'media'>, 'renderDefault'>

declare interface MediaProps {
  border?: boolean
  dimensions: PreviewMediaDimensions
  layout: PreviewLayoutKey
  media: PreviewProps['media']
  radius?: number
  responsive?: boolean
  styles?: {
    media?: string
    mediaString?: string
  }
}

/** @internal */
export declare const MemberField: React_2.NamedExoticComponent<MemberFieldProps>

/** @internal */
export declare function MemberFieldError(props: {member: FieldError}): React_2.JSX.Element

/** @internal */
export declare interface MemberFieldProps {
  member: FieldMember
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}

/** @internal */
export declare const MemberFieldSet: React_2.NamedExoticComponent<{
  member: FieldSetMember
  renderAnnotation?: RenderAnnotationCallback | undefined
  renderBlock?: RenderBlockCallback | undefined
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback | undefined
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}>

/** @internal */
export declare function MemberItemError(props: {member: ArrayItemError}): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare interface MemberItemProps {
  member: ArrayOfObjectsItemMember
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderInlineBlock?: RenderBlockCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderField: RenderFieldCallback
  renderInput: RenderInputCallback
  renderPreview: RenderPreviewCallback
}

/** @internal */
export declare function MetaInfo(props: MetaInfoProps): React_2.JSX.Element

/** @internal */
export declare interface MetaInfoProps {
  title: string
  action?: string
  icon?: React_2.ComponentType
  children?: React_2.ReactNode
  markRemoved?: boolean
}

/**
 * @hidden
 * @beta
 */
export declare interface MissingConfigFile {
  missingConfigFile: true
}

/**
 * This error may happen for arrays of objects where one or more of the members are missing a _key
 *
 * @public
 */
export declare type MissingKeysError = {
  type: 'MISSING_KEYS'
  schemaType: ArraySchemaType
  value: {
    _key?: string
  }[]
}

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
export declare type MixedArrayError = {
  type: 'MIXED_ARRAY'
  schemaType: ArraySchemaType
  value: unknown[]
}

/** @internal */
export declare interface MockAuthStoreOptions {
  currentUser: CurrentUser | null
  client: SanityClient
}

/** @internal */
declare interface MutationEvent_2 {
  type: 'mutation'
  documentId: string
  transactionId: string
  mutations: MutationPayload[]
  effects: {
    apply: unknown
    revert: unknown
  }
  transactionTotalEvents: number
  transactionCurrentEvent: number
  visibility: 'transaction' | 'query'
  transition: 'update' | 'appear' | 'disappear'
}
export {MutationEvent_2 as MutationEvent}

/**
 * @internal
 */
export declare type MutationPatch = Record<string, any>

/**
 *
 * @hidden
 * @beta
 */
export declare interface MutationPatchMsg {
  type: 'mutation'
  patches: FormPatch[]
  snapshot: unknown
}

/**
 * @hidden
 * @beta */
export declare interface MutationPayload {
  create?: any
  createIfNotExists?: any
  createOrReplace?: any
  delete?: any
  patch?: any
}

/** @internal */
export declare const NavbarContext: React_2.Context<NavbarContextValue>

/** @internal */
export declare interface NavbarContextValue {
  onSearchFullscreenOpenChange: (open: boolean) => void
  searchFullscreenOpen: boolean
  searchFullscreenPortalEl: HTMLElement | null
}

/**
 * @hidden
 * @beta */
export declare interface NavbarProps {
  renderDefault: (props: NavbarProps) => React_2.ReactElement
}

/**
 * @hidden
 * @beta
 */
export declare type NewDocumentCreationContext =
  | {
      type: 'global'
      documentId?: undefined
      schemaType?: undefined
    }
  | {
      type: 'document'
      documentId: string
      schemaType: string
    }
  | {
      type: 'structure'
      documentId?: undefined
      schemaType: string
    }

/**
 * @hidden
 * @beta
 */
export declare interface NewDocumentOptionsContext extends ConfigContext {
  creationContext: NewDocumentCreationContext
}

/**
 * @hidden
 * @beta
 */
export declare type NewDocumentOptionsResolver = ComposableOption<
  TemplateItem[],
  NewDocumentOptionsContext
>

/** @internal */
export declare function newDraftFrom(document: SanityDocument): SanityDocument

/** @internal */
export declare function NoChanges(): React_2.JSX.Element

/** @internal */
export declare function noop(): void

declare function NoopTracker({children}: {children: React_2.ReactNode}): React_2.JSX.Element

/** @internal */
declare type NormalizedWorkspace = {
  workspace: WorkspacesContextValue[number]
  name?: string | undefined
  basePath: string
  basePathRegex: RegExp
}

/** @internal */
export declare function normalizeIndexSegment(segment: string): PathSegment

/** @internal */
export declare function normalizeIndexTupleSegment(segment: string): IndexTuple

/** @internal */
export declare function normalizeKeySegment(segment: string): KeyedSegment

/** @internal */
export declare function normalizePathSegment(segment: string): PathSegment

/** @internal */
export declare type NullDiff = NullDiff_2<Annotation>

/**
 *
 * @hidden
 * @beta
 */
export declare interface NumberComponents {
  diff?: ComponentType<any>
  field?: ComponentType<NumberFieldProps>
  input?: ComponentType<NumberInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare type NumberDiff = NumberDiff_2<Annotation>

/**
 * @hidden
 * @public */
export declare interface NumberFieldProps extends BaseFieldProps {
  schemaType: NumberSchemaType
  value: number | undefined
  inputProps: NumberInputProps
}

/** @public */
export declare type NumberFormNode<S extends NumberSchemaType = NumberSchemaType> = BaseFormNode<
  number,
  S
>

/**
 *
 * @hidden
 * @beta
 */
export declare function NumberInput(props: NumberInputProps): React_2.JSX.Element

/**
 * @hidden
 * @public */
export declare interface NumberInputProps<S extends NumberSchemaType = NumberSchemaType>
  extends BaseInputProps,
    NumberFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/** @public */
export declare interface ObjectArrayFormNode<
  T extends ObjectItem = ObjectItem,
  S extends ObjectSchemaType = ObjectSchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  value: T
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember[]
  /** @internal */
  _allMembers: ObjectMember[]
  changesOpen?: boolean
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface ObjectComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ObjectInputProps>
  item?: ComponentType<ObjectItemProps>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare type ObjectDiff<T extends object = Record<string, any>> = ObjectDiff_2<Annotation, T>

/**
 * @hidden
 * @public */
export declare interface ObjectFieldProps<T = Record<string, any>> extends BaseFieldProps {
  schemaType: ObjectSchemaType
  value:
    | {
        [field in string]: unknown
      }
    | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  open: boolean
  onClose: () => void
  onOpen: () => void
  inputProps: ObjectInputProps<T>
}

/** @public */
export declare interface ObjectFormNode<
  T = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember[]
  /** @internal */
  _allMembers: (ObjectMember | HiddenField)[]
}

/**
 * @hidden
 * @beta */
export declare const ObjectInput: React_2.NamedExoticComponent<
  ObjectInputProps<Record<string, any>, ObjectSchemaType>
>

/** @internal */
export declare const ObjectInputMember: React_2.NamedExoticComponent<ObjectInputMemberProps>

/** @internal */
export declare interface ObjectInputMemberProps {
  member: ObjectMember
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}

/**
 * Convenience component for wrapping an object input
 * @internal
 */
export declare function ObjectInputMembers(props: ObjectMembersProps): React_2.JSX.Element

/**
 * @hidden
 * @public */
export declare interface ObjectInputProps<
  T = Record<string, any>,
  S extends ObjectSchemaType = ObjectSchemaType,
> extends BaseInputProps,
    Omit<ObjectFormNode<T, S>, '_allMembers'> {
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onFieldCollapse: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldExpand: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldSetCollapse: (fieldSetName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldSetExpand: (fieldSetName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldGroupSelect: (groupName: string) => void
  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path) => void
  /**
   * @hidden
   * @beta */
  onFieldOpen: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldClose: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/** @public */
export declare type ObjectItem = {
  _type?: string
  _key: string
}

/**
 * Props for the ObjectItem component.
 * @public
 */
export declare interface ObjectItemProps<Item extends ObjectItem = ObjectItem>
  extends BaseItemProps<Item> {
  /** Whether the item has changes in a draft. */
  changed: boolean
  /** The schema type of the object. */
  schemaType: ObjectSchemaType
  /** The schema type of the parent array. */
  parentSchemaType: ArraySchemaType
  /** Whether the item is collapsed. */
  collapsed: boolean | undefined
  /** Whether the item is collapsible. */
  collapsible: boolean | undefined
  /** Callback for when the item is collapsed. */
  onCollapse: () => void
  /** Callback for when the item is expanded. */
  onExpand: () => void
  /** Whether the item is open. */
  open: boolean
  /** Callback for when the item is closed. */
  onClose: () => void
  /** Callback for when the item is opened. */
  onOpen: () => void
  /** The value of the item. */
  value: Item
  /**
   * @hidden
   * @beta */
  inputProps: Omit<ObjectInputProps, 'renderDefault'>
}

/** @public */
export declare type ObjectMember = FieldMember | FieldSetMember | FieldError

/**
 * @deprecated Use ObjectInputMembers instead
 * @internal
 */
export declare const ObjectMembers: typeof ObjectInputMembers

/** @internal */
export declare interface ObjectMembersProps {
  members: ObjectMember[]
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderField: RenderFieldCallback
  renderItem: RenderArrayOfObjectsItemCallback
  renderPreview: RenderPreviewCallback
}

declare type ObserveDocumentPairAvailability = (
  id: string,
) => Observable<DraftsModelDocumentAvailability>

/** @internal */
export declare type ObserveDocumentTypeFromIdFn = (id: string) => Observable<string | undefined>

/**
 * @hidden
 * @beta */
export declare type ObserveForPreviewFn = (
  value: Previewable,
  type: PreviewableType,
  viewOptions?: PrepareViewOptions,
  apiConfig?: ApiConfig,
) => Observable<PreparedSnapshot>

/**
 * @hidden
 * @beta */
export declare interface ObservePathsFn {
  (
    value: Previewable,
    paths: (string | PreviewPath)[],
    apiConfig?: ApiConfig,
  ): Observable<PreviewValue | SanityDocumentLike | Reference | string | null>
}

/** @internal */
export declare const onRetry: () => void

/** @internal */
export declare type Opaque<T, K> = T & {
  __opaqueId__: K
}

/** @internal */
export declare interface Operation<
  ExtraArgs extends any[] = [],
  ErrorStrings extends string = string,
> {
  disabled: false | ErrorStrings | 'NOT_READY'
  execute(...extra: ExtraArgs): void
}

/** @internal */
export declare interface OperationArgs {
  historyStore: HistoryStore
  client: SanityClient
  schema: Schema
  typeName: string
  idPair: IdPair
  snapshots: {
    draft: null | SanityDocument
    published: null | SanityDocument
  }
  draft: DocumentVersionSnapshots
  published: DocumentVersionSnapshots
}

/**
 * @hidden
 * @beta */
export declare interface OperationError {
  type: 'error'
  /** @internal */
  op: keyof OperationsAPI
  id: string
  error: Error
}

/** @internal */
export declare const operationEvents: (arg1: {
  client: SanityClient
  historyStore: HistoryStore
  schema: Schema
}) => Observable<IntermediarySuccess | IntermediaryError>

/** @internal */
export declare interface OperationImpl<
  ExtraArgs extends any[] = [],
  DisabledReason extends string = string,
> {
  disabled: (args: OperationArgs) => DisabledReason | 'NOT_READY' | false
  execute(args: OperationArgs, ...extra: ExtraArgs): void
}

/** @internal */
export declare interface OperationsAPI {
  commit: Operation | GuardedOperation
  delete: Operation<[], 'NOTHING_TO_DELETE' | 'NOT_READY'>
  del: Operation<[], 'NOTHING_TO_DELETE'> | GuardedOperation
  publish:
    | Operation<[], 'LIVE_EDIT_ENABLED' | 'ALREADY_PUBLISHED' | 'NO_CHANGES'>
    | GuardedOperation
  patch: Operation<[patches: Patch[], initialDocument?: Record<string, any>]> | GuardedOperation
  discardChanges: Operation<[], 'NO_CHANGES' | 'NOT_PUBLISHED'> | GuardedOperation
  unpublish: Operation<[], 'LIVE_EDIT_ENABLED' | 'NOT_PUBLISHED'> | GuardedOperation
  duplicate: Operation<[documentId: string], 'NOTHING_TO_DUPLICATE'> | GuardedOperation
  restore: Operation<[revision: string]> | GuardedOperation
}

/**
 * @hidden
 * @beta */
export declare interface OperationSuccess {
  type: 'success'
  /** @internal */
  op: keyof OperationsAPI
  id: string
}

declare type Operator<TOperators = string> = OperatorDivider | OperatorItem<TOperators>

/**
 * @alpha
 */
export declare interface OperatorButtonValueComponentProps<T> {
  value: T
}

declare interface OperatorDateDirectionValue {
  includeTime?: boolean
  date: string | null
}

declare interface OperatorDateEqualValue {
  includeTime?: boolean
  date: string | null
}

declare interface OperatorDateLastValue {
  unit: 'days' | 'months' | 'years'
  unitValue: number | null
}

declare interface OperatorDateRangeValue {
  dateMax: string | null
  dateMin: string | null
  includeTime?: boolean
}

/**
 * @internal
 */
export declare const operatorDefinitions: (
  | (SearchOperatorBuilder<'dateAfter', OperatorDateDirectionValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
      type: 'dateAfter'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
      initialValue: null
      label: string
    })
  | (SearchOperatorBuilder<'dateBefore', OperatorDateDirectionValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
      type: 'dateBefore'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
      initialValue: null
      label: string
    })
  | (SearchOperatorBuilder<'dateEqual', OperatorDateEqualValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateEqualValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateEqualValue>
      type: 'dateEqual'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
      initialValue: {
        date: null
        includeTime: boolean
      }
      label: string
    })
  | (SearchOperatorBuilder<'dateLast', OperatorDateLastValue> & {
      groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateLastValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateLastValue>
      initialValue: {
        unit: string
        unitValue: number
      }
      type: 'dateLast'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateLastValue>
      label: string
    })
  | (SearchOperatorBuilder<'dateNotEqual', OperatorDateEqualValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateEqualValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateEqualValue>
      type: 'dateNotEqual'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
      initialValue: {
        date: null
        includeTime: boolean
      }
      label: string
    })
  | (SearchOperatorBuilder<'dateRange', OperatorDateRangeValue> & {
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateRangeValue>
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateRangeValue>) => string | null
      initialValue: {
        includeTime: boolean
        dateMax: string
        dateMin: null
      }
      inputComponent: SearchOperatorInput<OperatorDateRangeValue>
      type: 'dateRange'
      buttonLabel: string
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeAfter', OperatorDateDirectionValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
      type: 'dateTimeAfter'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
      initialValue: null
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeBefore', OperatorDateDirectionValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
      type: 'dateTimeBefore'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
      initialValue: null
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeEqual', OperatorDateEqualValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateEqualValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateEqualValue>
      type: 'dateTimeEqual'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
      initialValue: {
        date: null
        includeTime: boolean
      }
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeLast', OperatorDateLastValue> & {
      groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateLastValue>) => string | null
      initialValue: {
        unit: string
        unitValue: number
      }
      inputComponent: SearchOperatorInput<OperatorDateLastValue>
      type: 'dateTimeLast'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateLastValue>
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeNotEqual', OperatorDateEqualValue> & {
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateEqualValue>) => string | null
      inputComponent: SearchOperatorInput<OperatorDateEqualValue>
      type: 'dateTimeNotEqual'
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
      initialValue: {
        date: null
        includeTime: boolean
      }
      label: string
    })
  | (SearchOperatorBuilder<'dateTimeRange', OperatorDateRangeValue> & {
      buttonValueComponent: SearchOperatorButtonValue<OperatorDateRangeValue>
      groqFilter: ({
        fieldPath,
        value,
      }: SearchOperatorParams<OperatorDateRangeValue>) => string | null
      initialValue: {
        includeTime: boolean
        dateMax: string
        dateMin: null
      }
      inputComponent: SearchOperatorInput<OperatorDateRangeValue>
      type: 'dateTimeRange'
      buttonLabel: string
      label: string
    })
  | (SearchOperatorBuilder<'arrayCountEqual', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountEqual'
    })
  | (SearchOperatorBuilder<'arrayCountGt', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX_2.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountGt'
    })
  | (SearchOperatorBuilder<'arrayCountGte', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX_2.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountGte'
    })
  | (SearchOperatorBuilder<'arrayCountLt', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX_2.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountLt'
    })
  | (SearchOperatorBuilder<'arrayCountLte', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX_2.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountLte'
    })
  | (SearchOperatorBuilder<'arrayCountNotEqual', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'arrayCountNotEqual'
    })
  | (SearchOperatorBuilder<'arrayCountRange', OperatorNumberRangeValue> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorNumberRangeValue>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorNumberRangeValue>) => string
      initialValue: null
      inputComponent: SearchOperatorInput<OperatorNumberRangeValue>
      label: string
      type: 'arrayCountRange'
    })
  | (SearchOperatorBuilder<'arrayListIncludes', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'arrayListIncludes'
    })
  | (SearchOperatorBuilder<'arrayListNotIncludes', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'arrayListNotIncludes'
    })
  | (SearchOperatorBuilder<'arrayReferenceIncludes', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<Reference>
      label: string
      type: 'arrayReferenceIncludes'
    })
  | (SearchOperatorBuilder<'arrayReferenceNotIncludes', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<Reference>
      label: string
      type: 'arrayReferenceNotIncludes'
    })
  | (SearchOperatorBuilder<'assetFileEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
      label: string
      type: 'assetFileEqual'
    })
  | (SearchOperatorBuilder<'assetFileNotEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
      label: string
      type: 'assetFileNotEqual'
    })
  | (SearchOperatorBuilder<'assetImageEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
      label: string
      type: 'assetImageEqual'
    })
  | (SearchOperatorBuilder<'assetImageNotEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
      label: string
      type: 'assetImageNotEqual'
    })
  | (SearchOperatorBuilder<'booleanEqual', boolean> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<boolean>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<boolean>) => string | null
      initialValue: boolean
      inputComponent: SearchOperatorInput<boolean>
      label: string
      type: 'booleanEqual'
    })
  | (ValuelessSearchOperatorBuilder<'defined'> & {
      buttonLabel: string
      groqFilter: ({fieldPath}: ValuelessSearchOperatorParams) => string | null
      label: string
      type: 'defined'
    })
  | (ValuelessSearchOperatorBuilder<'notDefined'> & {
      buttonLabel: string
      groqFilter: ({fieldPath}: ValuelessSearchOperatorParams) => string | null
      label: string
      type: 'notDefined'
    })
  | (SearchOperatorBuilder<'numberEqual', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberEqual'
    })
  | (SearchOperatorBuilder<'numberGt', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX_2.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberGt'
    })
  | (SearchOperatorBuilder<'numberGte', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX_2.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberGte'
    })
  | (SearchOperatorBuilder<'numberLt', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX_2.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberLt'
    })
  | (SearchOperatorBuilder<'numberLte', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      icon: () => JSX_2.Element
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberLte'
    })
  | (SearchOperatorBuilder<'numberNotEqual', number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<number>
      label: string
      type: 'numberNotEqual'
    })
  | (SearchOperatorBuilder<'numberRange', OperatorNumberRangeValue> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<OperatorNumberRangeValue>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorNumberRangeValue>) => string
      initialValue: null
      inputComponent: SearchOperatorInput<OperatorNumberRangeValue>
      label: string
      type: 'numberRange'
    })
  | (SearchOperatorBuilder<'portableTextEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'portableTextEqual'
    })
  | (SearchOperatorBuilder<'portableTextMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'portableTextMatches'
    })
  | (SearchOperatorBuilder<'portableTextNotEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'portableTextNotEqual'
    })
  | (SearchOperatorBuilder<'portableTextNotMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'portableTextNotMatches'
    })
  | (SearchOperatorBuilder<'referenceEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<Reference>
      label: string
      type: 'referenceEqual'
    })
  | (SearchOperatorBuilder<'referenceNotEqual', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<Reference>
      label: string
      type: 'referenceNotEqual'
    })
  | (SearchOperatorBuilder<'referencesAssetFile', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
      label: string
      type: 'referencesAssetFile'
    })
  | (SearchOperatorBuilder<'referencesAssetImage', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
      label: string
      type: 'referencesAssetImage'
    })
  | (SearchOperatorBuilder<'referencesDocument', Reference> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<Reference>
      groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<Reference>
      label: string
      type: 'referencesDocument'
    })
  | (SearchOperatorBuilder<'slugEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      /**
       * @internal
       */
      label: string
      type: 'slugEqual'
    })
  | (SearchOperatorBuilder<'slugMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'slugMatches'
    })
  | (SearchOperatorBuilder<'slugNotEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'slugNotEqual'
    })
  | (SearchOperatorBuilder<'slugNotMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'slugNotMatches'
    })
  | (SearchOperatorBuilder<'stringEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringEqual'
    })
  | (SearchOperatorBuilder<'stringListEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringListEqual'
    })
  | (SearchOperatorBuilder<'stringListNotEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringListNotEqual'
    })
  | (SearchOperatorBuilder<'stringMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringMatches'
    })
  | (SearchOperatorBuilder<'stringNotEqual', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringNotEqual'
    })
  | (SearchOperatorBuilder<'stringNotMatches', string | number> & {
      buttonLabel: string
      buttonValueComponent: SearchOperatorButtonValue<string | number>
      groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
      initialValue: null
      inputComponent: SearchOperatorInput<string | number>
      label: string
      type: 'stringNotMatches'
    })
)[]

declare type OperatorDivider = {
  type: 'divider'
}

/**
 * @alpha
 */
export declare interface OperatorInputComponentProps<T> {
  fieldDefinition?: SearchFieldDefinition
  onChange: (value: T | null) => void
  value: T | null
}

declare type OperatorItem<TOperators = string> = {
  name: TOperators
  type: 'item'
}

declare interface OperatorNumberRangeValue {
  max: number | null
  min: number | null
}

/** @internal */
export declare function OverlayDisabled(props: PresenceOverlayProps): JSX.Element

/**
 * @hidden
 * @beta */
export declare interface Pair {
  /** @internal */
  transactionsPendingEvents$: Observable<PendingMutationsEvent>
  published: DocumentVersion
  draft: DocumentVersion
}

/** @internal */
export declare interface PairListenerOptions {
  tag?: string
}

/**
 * @hidden
 * @beta */
export declare type ParsedTimeRef = Chunk | 'loading' | 'invalid'

/**
 * @hidden
 * @beta
 */
export declare type PartialContext<TContext extends ConfigContext> = Pick<
  TContext,
  Exclude<keyof TContext, keyof ConfigContext>
>

/** @internal */
export declare type PartialExcept<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>>

declare type Patch = any

/**
 *
 * @hidden
 * @beta
 */
export declare type PatchArg = FormPatch | FormPatch[]

/**
 *
 * @hidden
 * @beta
 */
export declare interface PatchChannel {
  publish: (msg: PatchMsg) => void
  subscribe: (subscriber: PatchMsgSubscriber) => () => void
}

/**
 *
 * @hidden
 * @beta
 */
export declare class PatchEvent {
  static from(input: PatchArg | PatchEvent): PatchEvent
  patches: Array<FormPatch>
  constructor(patches: Array<FormPatch>)
  prepend(...patches: PatchArg[]): PatchEvent
  append(...patches: PatchArg[]): PatchEvent
  prefixAll(segment: PathSegment): PatchEvent
}

/**
 *
 * @hidden
 * @beta
 */
export declare type PatchMsg = MutationPatchMsg | RebasePatchMsg

/**
 *
 * @hidden
 * @beta
 */
export declare interface PatchMsgSubscriber {
  (msg: PatchMsg): void
}

declare type PatchTransformer = (patches: FormPatch[]) => FormPatch[]

/** @internal */
export declare function pathsAreEqual(pathA: Path, pathB: Path): boolean

/** @internal */
export declare function pathToString(path: Path): string

/** @internal */
export declare interface PendingMutationsEvent {
  type: 'pending'
  phase: 'begin' | 'end'
}

/**
 * @hidden
 * @beta */
export declare interface PermissionCheckResult {
  granted: boolean
  reason: string
}

/**
 * @hidden
 * @beta
 */
declare type Plugin_2<TOptions = void> = (options: TOptions) => PluginOptions
export {Plugin_2 as Plugin}

/**
 * @hidden
 * @beta */
export declare type PluginFactory<TOptions> = (options: TOptions) => PluginOptions

/**
 * @hidden
 * @beta
 */
export declare interface PluginOptions {
  name: string
  plugins?: PluginOptions[]
  schema?: SchemaPluginOptions
  document?: DocumentPluginOptions
  tools?: Tool[] | ComposableOption<Tool[], ConfigContext>
  form?: SanityFormConfig
  studio?: {
    components?: StudioComponentsPluginOptions
  }
}

/** @internal */
export declare function PopoverDialog(props: PopoverDialogProps): React_2.JSX.Element

declare interface PopoverDialogProps {
  children: React_2.ReactNode
  header?: React_2.ReactNode
  onClose: () => void
  referenceElement: PopoverProps['referenceElement']
  width: ResponsiveWidthProps['width']
  containerRef?: React_2.Dispatch<React_2.SetStateAction<HTMLDivElement | null>>
}

/** @internal */
export declare type PortableTextEditorElement = HTMLDivElement | HTMLSpanElement

/**
 * Input component for editing block content
 * ({@link https://github.com/portabletext/portabletext | Portable Text}) in the Sanity Studio.
 *
 * Supports multi-user real-time block content editing on larger documents.
 *
 * This component can be configured and customized extensively.
 * {@link https://www.sanity.io/docs/portable-text-features | Go to the documentation for more details}.
 *
 * @public
 * @param props - {@link PortableTextInputProps} component props.
 */
declare function PortableTextInput(props: PortableTextInputProps): React_2.JSX.Element
export {PortableTextInput as BlockEditor}
export {PortableTextInput}

/**
 * Component props for the {@link PortableTextInput} React component.
 *
 * Extends {@link ArrayOfObjectsInputProps}.
 *
 * @public
 * */
export declare interface PortableTextInputProps
  extends ArrayOfObjectsInputProps<PortableTextBlock, ArraySchemaType<PortableTextBlock>> {
  /**
   * Assign hotkeys that can be attached to custom editing functions
   */
  hotkeys?: HotkeyOptions
  /**
   * Array of {@link PortableTextMarker} with meta data connected to the content.
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  markers?: PortableTextMarker[]
  /**
   * Custom copy function
   */
  onCopy?: OnCopyFn
  /**
   * Custom paste function
   */
  onPaste?: OnPasteFn
  /**
   * Function to render custom block actions
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  renderBlockActions?: RenderBlockActionsCallback
  /**
   * Function to render custom markers
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  renderCustomMarkers?: RenderCustomMarkers
}

/**
 * A generic marker for attaching metadata to specific nodes of the Portable Text input.
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 * @param type - a type name for this marker
 * @param data - some data connected to this marker
 * @param path - the path to the Portable Text content connected to this marker
 */
export declare interface PortableTextMarker {
  type: string
  data?: unknown
  path: Path
}

/** @internal */
export declare interface PortableTextMemberItem {
  kind: 'annotation' | 'textBlock' | 'objectBlock' | 'inlineObject'
  key: string
  member: ArrayOfObjectsItemMember
  node: ObjectFormNode
  elementRef?: React_2.MutableRefObject<PortableTextEditorElement | null>
  input?: ReactNode
}

/**
 * Portable text preview layout key
 *
 * @public
 */
export declare type PortableTextPreviewLayoutKey = 'block' | 'blockImage' | 'inline'

/** @internal */
export declare type Position = 'top' | 'bottom' | 'inside' | null

/** @internal */
export declare function prefixPath<
  T extends {
    path: Path
  },
>(patch: T, segment: PathSegment): T

/**
 * Takes in a config (created from the `defineConfig` function) and returns
 * an array of `WorkspaceSummary`. Note: this only partially resolves a config.
 *
 * For usage inside the Studio, it's preferred to pull the pre-resolved
 * workspaces and sources via `useWorkspace` or `useSource`. For usage outside
 * the Studio or for testing, use `resolveConfig`.
 *
 * @internal
 */
export declare function prepareConfig(
  config: Config | MissingConfigFile,
  options?: {
    basePath?: string
  },
): PreparedConfig

/** @internal */
export declare interface PreparedConfig {
  type: 'prepared-config'
  workspaces: WorkspaceSummary[]
}

/**
 * @hidden
 * @beta */
export declare interface PreparedSnapshot {
  type?: PreviewableType
  snapshot: PreviewValue | null | undefined
}

/** @internal */
export declare function prepareForPreview(
  rawValue: unknown,
  type: SchemaType,
  viewOptions?: PrepareViewOptions,
): PreviewValue & {
  _createdAt?: string
  _updatedAt?: string
}

/** @internal */
export declare function prepareTemplates(
  schema: Schema,
  initialValueTemplates: Template[],
): Template[]

/** @internal */
export declare interface PresenceLocation {
  type: 'document'
  documentId: string
  lastActiveAt: string
  path: Path
}

/** @internal */
export declare const PresenceOverlay: typeof OverlayDisabled

/** @internal */
export declare interface PresenceOverlayProps {
  children: React_2.ReactNode
  margins?: [number, number, number, number]
}

/** @internal */
export declare function PresenceScope(props: PresenceScopeProps): React_2.JSX.Element

/** @internal */
export declare interface PresenceScopeProps {
  readOnly?: boolean
  path: Path
  children: React_2.ReactNode
}

/**
 * @hidden
 * @beta */
export declare interface PresenceStore {
  /**
   * @internal
   */
  documentPresence: (documentId: string) => Observable<DocumentPresence[]>
  /**
   * @internal
   */
  globalPresence$: Observable<GlobalPresence[]>
  /**
   * @internal
   */
  reportLocations: (locations: PresenceLocation[]) => Observable<void>
  /**
   * @internal
   */
  setLocation: (nextLocation: PresenceLocation[]) => void
  /**
   * @internal
   */
  debugPresenceParam$: Observable<string[]>
}

/** @internal */
export declare type PresentUser = {
  user: User
  status?: Status
  sessions?: Session[]
}

/**
 * @internal
 */
export declare function Preview(props: RenderPreviewCallbackProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare type Previewable = (
  | {
      _id: string
    }
  | {
      _type: string
    }
  | {
      _ref: string
      _dataset?: string
      _projectId?: string
    }
) & {
  /**
   * optional object used to attach meta data to the prepared result.
   * currently used to add a flag for the invalid preview error fallback and
   * insufficient permissions fallback
   * @internal
   */
  _internalMeta?: {
    type?: string
  }
}

/**
 * @hidden
 * @beta */
export declare interface PreviewableType {
  fields?: {
    name: string
    type: SchemaType
  }[]
  preview?: PreviewConfig
}

/** @internal */
export declare const PreviewCard: React_2.ForwardRefExoticComponent<
  Omit<CardProps & Omit<React_2.HTMLProps<HTMLDivElement>, 'height'>, 'ref'> &
    React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare interface PreviewCardContextValue {
  selected?: boolean
}

/**
 * @hidden
 * @beta
 */
export declare type PreviewComponent = ComponentType<PreviewProps>

/**
 * Preview layout key. See also {@link GeneralPreviewLayoutKey} and {@link PortableTextPreviewLayoutKey}
 *
 * @public
 */
export declare type PreviewLayoutKey = GeneralPreviewLayoutKey | PortableTextPreviewLayoutKey

/**
 * This component is responsible for converting renderPreview() calls into an element.
 * It:
 * - subscribes to "prepared" preview value as long as the element is visible on screen
 * - resolves the configured preview component for the schema type
 * - prepares "preview"-props and passes this to the configured preview component
 * @internal
 * */
export declare function PreviewLoader(
  props: RenderPreviewCallbackProps & {
    component: ComponentType<Omit<PreviewProps, 'renderDefault'>>
  },
): ReactElement

/**
 * @hidden
 * @public
 */
export declare interface PreviewMediaDimensions {
  aspect?: number
  dpr?: number
  fit?: ImageUrlFitMode
  height?: number
  width?: number
}

/**
 * TODO: unify with content path from `@sanity/types`
 *
 *
 * @hidden
 * @beta
 */
export declare type PreviewPath = FieldName[]

/**
 * @hidden
 * @beta
 */
export declare interface PreviewProps<TLayoutKey = PreviewLayoutKey> {
  actions?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  children?: ReactNode
  description?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  error?: Error | null
  fallbackTitle?: ReactNode
  imageUrl?: string
  isPlaceholder?: boolean
  layout?: TLayoutKey
  media?:
    | ReactNode
    | ComponentType<{
        dimensions: PreviewMediaDimensions
        layout: TLayoutKey
      }>
  mediaDimensions?: PreviewMediaDimensions
  progress?: number
  status?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  subtitle?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  title?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType?: SchemaType
  renderDefault: (props: PreviewProps) => ReactElement
}

declare interface PreviewState {
  isLoading?: boolean
  draft?: PreviewValue | Partial<SanityDocument> | null
  published?: PreviewValue | Partial<SanityDocument> | null
}

/** @internal */
export declare type PrimitiveFieldProps = NumberFieldProps | BooleanFieldProps | StringFieldProps

/**
 * @hidden
 * @beta */
export declare type PrimitiveFormNode = BooleanFormNode | NumberFormNode | StringFormNode

/**
 * @hidden
 * @public */
export declare interface PrimitiveInputElementProps {
  value?: string
  id: string
  readOnly: boolean
  placeholder?: string
  onChange: FormEventHandler
  onFocus: FocusEventHandler
  onBlur: FocusEventHandler
  ref: React_2.MutableRefObject<any>
  'aria-describedby': string | undefined
}

/**
 * @hidden
 * @beta */
export declare type PrimitiveInputProps = StringInputProps | BooleanInputProps | NumberInputProps

/** @public */
export declare interface PrimitiveItemProps extends BaseItemProps<string | number | boolean> {
  /**
   * The value of the primitive item.
   */
  value: string | number | boolean
  /**
   * The schema type of the primitive item.
   */
  schemaType: NumberSchemaType | BooleanSchemaType | StringSchemaType
  /**
   * The schema type of the parent array containing the item.
   */
  parentSchemaType: ArraySchemaType
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface PrimitiveMemberItemProps {
  member: ArrayOfPrimitivesItemMember
  renderItem: RenderArrayOfPrimitivesItemCallback
  renderInput: RenderInputCallback
}

declare type PrimitiveValue = string | number | boolean

/**
 * @hidden
 * @beta */
export declare interface ProjectData {
  id: string
  displayName: string
  studioHost: string | null
  isBlocked: boolean
  isDisabled: boolean
  isDisabledByUser: boolean
  metadata: {
    color: string
    externalStudioHost: string
  }
  maxRetentionDays: number
  activityFeedEnabled: boolean
  createdAt: string
  updatedAt: string
  organizationId: string
  members: {
    id: string
    createdAt: string
    updatedAt: string
    isCurrentUser: boolean
    isRobot: boolean
    role: string
    roles: Role[]
  }[]
  features: string[]
  pendingInvites: number
}

/**
 * @hidden
 * @beta */
export declare interface ProjectDatasetData {
  name: string
  aclMode: 'public' | 'private'
  createdAt: string
  createdByUserId: string
  tags: {
    name: string
    title: string
  }[]
}

/**
 * @hidden
 * @beta */
export declare interface ProjectStore {
  get: () => Observable<ProjectData>
  getDatasets: () => Observable<ProjectDatasetData[]>
}

/** @internal */
export declare type PublishedId = Opaque<string, 'publishedId'>

/**
 * @hidden
 * @beta */
export declare type QueryParams = Record<string, string | number | boolean | string[]>

/** @internal */
export declare type ReactHook<TArgs, TResult> = (args: TArgs) => TResult

/**
 *
 * @hidden
 * @beta
 */
export declare interface RebasePatchMsg {
  type: 'rebase'
  patches: FormPatch[]
  snapshot: unknown
}

/**
 * @hidden
 * @beta */
export declare interface ReconnectEvent {
  type: 'reconnect'
}

/** @internal */
export declare interface Rect {
  height: number
  width: number
  top: number
  left: number
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface ReferenceComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<ReferenceValue>>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<ReferenceInputProps>
  item?: ComponentType<ObjectItemProps<ReferenceValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare type ReferenceDiff = ObjectDiff<Reference>

/**
 *
 * @hidden
 * @beta
 */
export declare function ReferenceInput(props: ReferenceInputProps): React_2.JSX.Element

/**
 * @internal
 */
export declare interface ReferenceInputOptions {
  /**
   * Represents the highlighted path if ths current document has a related open
   * child (e.g. reference in place).
   */
  activePath?: {
    path: Path
    state: 'selected' | 'pressed' | 'none'
  }
  /**
   * A specialized `EditReferenceLinkComponent` component that takes in the needed props to open a
   * referenced document to the right
   */
  EditReferenceLinkComponent?: ComponentType<
    Omit<HTMLProps<'a'>, 'children'> & EditReferenceLinkComponentProps
  >
  initialValueTemplateItems?: TemplatePermissionsResult[]
  /**
   * Similar to `EditReferenceChildLink` expect without the wrapping component
   */
  onEditReference?: (options: EditReferenceOptions) => void
}

/**
 * @internal
 */
export declare function ReferenceInputOptionsProvider(
  props: ReferenceInputOptions & {
    children: React_2.ReactNode
  },
): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type ReferenceInputProps = ObjectInputProps<Reference, ReferenceSchemaType>

/** @internal */
export declare type RegionWithIntersectionDetails = {
  distanceTop: number
  distanceBottom: number
  position: 'top' | 'bottom' | 'inside'
  region: ReportedRegionWithRect<FieldPresenceData>
}

/**
 * @hidden
 * @beta */
export declare type RemoteSnapshotEvent = DocumentRemoteMutationEvent | SnapshotEvent

/** @internal */
export declare const remoteSnapshots: (
  arg1: SanityClient,
  arg2: IdPair,
  arg3: string,
) => Observable<RemoteSnapshotVersionEvent>

/**
 * @hidden
 * @beta */
export declare type RemoteSnapshotVersionEvent = WithVersion<RemoteSnapshotEvent>

/** @internal */
export declare function removeDupes(documents: SanityDocument[]): SanityDocument[]

/** @internal */
export declare const removeMissingReferences: (
  doc: SanityDocument,
  existingIds: Record<string, boolean | undefined>,
) => SanityDocument

/**
 * @hidden
 * @public */
export declare type RenderAnnotationCallback<
  T extends BlockAnnotationProps = BlockAnnotationProps,
> = (annotationProps: Omit<T, 'renderDefault'>) => ReactNode

/**
 * @hidden
 * @public  */
export declare type RenderArrayOfObjectsItemCallback = (
  itemProps: Omit<ObjectItemProps, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @beta */
export declare type RenderArrayOfPrimitivesItemCallback = (
  itemProps: Omit<PrimitiveItemProps, 'renderDefault'>,
) => ReactNode

/**
 * Function for rendering custom block actions
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
export declare type RenderBlockActionsCallback = (
  props: RenderBlockActionsProps,
) => React_2.ReactNode

/**
 * Props for rendering block actions
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
export declare interface RenderBlockActionsProps {
  block: PortableTextBlock
  value: PortableTextBlock[] | undefined
  set: (block: PortableTextBlock) => void
  unset: () => void
  insert: (block: PortableTextBlock | PortableTextBlock[]) => void
}

/**
 * @hidden
 * @public */
export declare type RenderBlockCallback<T extends BlockProps = BlockProps> = (
  blockProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * Function for rendering custom block markers
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
export declare type RenderCustomMarkers = (markers: PortableTextMarker[]) => React_2.ReactNode

/**
 * @hidden
 * @public */
export declare type RenderFieldCallback<T extends FieldProps = FieldProps> = (
  fieldProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
export declare type RenderInputCallback<T extends InputProps = InputProps> = (
  inputProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
export declare type RenderItemCallback = (
  itemProps: Omit<ObjectItemProps, 'renderDefault'> | Omit<PrimitiveItemProps, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
export declare type RenderPreviewCallback = (props: RenderPreviewCallbackProps) => ReactNode

/**
 *
 * @hidden
 * @public
 */
export declare interface RenderPreviewCallbackProps<TLayoutKey = PreviewLayoutKey> {
  actions?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  children?: ReactNode
  error?: Error | null
  fallbackTitle?: ReactNode
  isPlaceholder?: boolean
  layout?: TLayoutKey
  mediaDimensions?: PreviewMediaDimensions
  progress?: number
  status?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  value: unknown
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType: SchemaType
  skipVisibilityCheck?: boolean
  style?: CSSProperties
}

/**
 * @internal
 * @deprecated Use `renderStudio(rootElement, config, {reactStrictMode: true})` instead
 */
export declare function renderStudio(
  rootElement: HTMLElement | null,
  config: Config,
  options: boolean,
): () => void

/** @internal */
export declare function renderStudio(rootElement: HTMLElement | null, config: Config): () => void

/** @internal */
export declare function renderStudio(
  rootElement: HTMLElement | null,
  config: Config,
  options: RenderStudioOptions,
): () => void

declare interface RenderStudioOptions {
  basePath?: string
  reactStrictMode?: boolean
}

/** @internal */
export declare type Reported<Value> = [string, Value]

/** @internal */
export declare type ReportedRegionWithRect<T> = T & {
  id: string
  rect: Rect
}

/** @internal */
export declare type ReporterHook<Payload> = (
  id: string | null,
  value: Payload | (() => Payload),
  isEqual?: (a: Payload, b: Payload) => boolean,
) => void

/**
 * A subset of the History API is used, and explicitly declared so it's possible to write a custom
 * history implementation that can be used to integrate the router in a variety of parent routers.
 * @internal
 */
declare type RequiredHistory = Pick<History_2, 'listen' | 'location' | 'push' | 'replace'>

/** @internal */
export declare const resizeObserver: SharedResizeObserver

/**
 * @internal
 */
export declare function resolveConditionalProperty(
  property: ConditionalProperty,
  context: ConditionalPropertyCallbackContext,
): boolean

/**
 * Fully resolves a configuration including subscribing to all sources and
 * workspaces from a config. Returns an `Observable` that waits till all sources
 * emit once before emitting an array of fully resolved sources and workspaces.
 *
 * @internal
 */
export declare function resolveConfig(config: Config): Observable<Workspace[]>

/** @internal */
export declare function resolveDiffComponent<D extends Diff = any>(
  type: SchemaType,
  parentSchemaType?: ArraySchemaType | ObjectSchemaType,
): DiffComponent<D> | DiffComponentOptions | undefined

/**
 *
 * @hidden
 * @beta
 */
export declare type ResolvedUploader = {
  uploader: Uploader
  type: SchemaType
}

/** @internal */
export declare function resolveInitialObjectValue<Params extends Record<string, unknown>>(
  type: ObjectSchemaType,
  params: Params,
  maxDepth: number,
  context: InitialValueResolverContext,
): Promise<any>

/** @internal */
export declare function resolveInitialValue(
  schema: Schema,
  template: Template,
  params:
    | {
        [key: string]: any
      }
    | undefined,
  context: InitialValueResolverContext,
): Promise<{
  [key: string]: any
}>

/**
 * Resolve initial value for the given schema type (recursively)
 *
 * @internal
 */
export declare function resolveInitialValueForType<Params extends Record<string, unknown>>(
  /**
   * This is the name of the document.
   */
  type: SchemaType,
  /**
   * Params is a sanity context object passed to every initial value function.
   */
  params: Params,
  /**
   * Maximum recursion depth (default 9).
   */
  maxDepth: number | undefined,
  context: InitialValueResolverContext,
): Promise<any>

/**
 * @hidden
 * @beta
 */
export declare interface ResolveProductionUrlContext extends ConfigContext {
  document: SanityDocumentLike
}

/** @internal */
export declare interface ResourceCache {
  get<T = unknown>(options: {namespace: string; dependencies: (object | null)[]}): T | undefined
  set(options: {namespace: string; dependencies: (object | null)[]; value: unknown}): void
}

/** @internal */
export declare function ResourceCacheProvider({
  children,
}: ResourceCacheProviderProps): React_2.JSX.Element

/** @internal */
export declare interface ResourceCacheProviderProps {
  children: React_2.ReactNode
}

/** @internal */
export declare type RetryingStatus = {
  type: 'retrying'
}

/** @internal */
export declare const RevertChangesButton: React_2.ForwardRefExoticComponent<
  ButtonProps &
    Omit<React_2.HTMLProps<HTMLButtonElement>, 'ref'> &
    React_2.RefAttributes<HTMLButtonElement>
>

/**
 * @internal
 */
export declare const ReviewChangesContext: Context<ReviewChangesContextValue | null>

/**
 * @internal
 */
export declare interface ReviewChangesContextValue {
  changesOpen?: boolean
}

/**
 * @public
 */
declare interface Route {
  /**
   * The raw string representation of the route.
   */
  raw: string
  /**
   * An array of route segments that make up the route.
   * See {@link RouteSegment}
   */
  segments: RouteSegment[]
  /**
   * An optional object containing route transforms.
   * See {@link RouteTransform} and {@link RouterState}
   */
  transform?: {
    [key: string]: RouteTransform<RouterState>
  }
}

/**
 * @public
 */
declare type RouteChildren =
  | RouterNode[]
  | ((state: RouterState) => Router | RouterNode | RouterNode[] | undefined | false)

/**
 * @public
 */
declare interface Router extends RouterNode {
  /**
   * Indicates whether this router is a route.
   * @internal
   */
  _isRoute: boolean
  /**
   * Encodes the specified router state into a path string.
   * See {@link RouterState}
   *
   */
  encode: (state: RouterState) => string

  /**
   * Decodes the specified path string into a router state.
   * See {@link RouterState}
   */
  decode: (path: string) => RouterState | null

  /**
   * Determines whether the specified path is not found.
   */
  isNotFound: (path: string) => boolean

  /**
   * Gets the base path of this router.
   */
  getBasePath: () => string

  /**
   * Gets the redirect base of this router.
   */
  getRedirectBase: (pathname: string) => string | null

  /**
   * Determines whether the specified path is the root path.
   */
  isRoot: (path: string) => boolean
}

/**
 * The history context is either one of the implementations from the `history` package, or a custom one that only implements
 * the subset of the History API that is used by the router, documented in `RequiredHistory`.
 * @internal
 */
declare type RouterHistory = BrowserHistory | MemoryHistory | HashHistory | RequiredHistory

/**
 * @public
 */
declare interface RouterNode {
  /**
   * The route information for this node. See {@link Route}
   */
  route: Route
  /**
   * An optional scope for this node.
   */
  scope?: string
  /**
   * An optional object containing transforms to apply to this node.
   * See {@link RouteTransform} and {@link RouterState}
   */
  transform?: {
    [key: string]: RouteTransform<RouterState>
  }
  /**
   * The child nodes of this node. See {@link RouteChildren}
   */
  children: RouteChildren
}

/**
 * @public
 */
declare type RouterState = Record<string, unknown>

/**
 * @public
 */
declare interface RouteSegment {
  /**
   * The name of the segment.
   */
  name: string
  /**
   * The type of the segment.
   * Can be either "dir" or "param".
   */
  type: 'dir' | 'param'
}

/**
 * @public
 */
declare interface RouteTransform<T> {
  /**
   * Converts a path string to a state object.
   */
  toState: (value: string) => T

  /**
   * Converts a state object to a path string.
   */
  toPath: (value: T) => string
}

/**
 * @hidden
 * @beta */
export declare type RovingFocusNavigationType = 'arrows' | 'tab'

/**
 * @hidden
 * @beta */
export declare interface RovingFocusProps {
  direction?: 'horizontal' | 'vertical'
  initialFocus?: 'first' | 'last'
  navigation?: RovingFocusNavigationType[]
  loop?: boolean
  pause?: boolean
  rootElement: HTMLElement | HTMLDivElement | null
}

/** @internal */
export declare const SANITY_PATCH_TYPE: unique symbol

/**
 * TODO: rename to `VERSION`
 *
 *
 * @hidden
 * @beta
 */
export declare const SANITY_VERSION: string

export {SanityClient}

/**
 * Used in cases where no custom preview component is provided
 * @internal
 * */
export declare function SanityDefaultPreview(props: SanityDefaultPreviewProps): ReactElement

/** @internal */
export declare interface SanityDefaultPreviewProps extends Omit<PreviewProps, 'renderDefault'> {
  error?: Error | null
  icon?: ElementType | false
}

/**
 * @public
 */
export declare interface SanityFormConfig {
  /**
   * these have not been migrated over
   *
   *
   * @hidden
   * @beta
   */
  unstable?: {
    CustomMarkers?: FormBuilderCustomMarkersComponent
    Markers?: FormBuilderMarkersComponent
  }
  /**
   * @hidden
   * @beta
   */
  components?: {
    input?: ComponentType<InputProps>
    field?: ComponentType<FieldProps>
    item?: ComponentType<ItemProps>
    preview?: ComponentType<PreviewProps>
    block?: ComponentType<BlockProps>
    inlineBlock?: ComponentType<BlockProps>
    annotation?: ComponentType<BlockAnnotationProps>
  }
  file?: {
    /**
     * @hidden
     * @beta
     */
    assetSources?: AssetSource[] | AssetSourceResolver
    directUploads?: boolean
  }
  /**
   * @hidden
   * @beta
   */
  image?: {
    assetSources?: AssetSource[] | AssetSourceResolver
    directUploads?: boolean
  }
}

/** @internal */
export declare class SchemaError extends Error {
  schema: Schema
  constructor(schema: Schema)
}

/**
 * @hidden
 * @beta
 */
export declare interface SchemaPluginOptions {
  name?: string
  types?:
    | SchemaTypeDefinition[]
    | ComposableOption<
        SchemaTypeDefinition[],
        Omit<ConfigContext, 'schema' | 'currentUser' | 'getClient' | 'client'>
      >
  templates?: Template[] | TemplateResolver
}

/**
 * This provides a utility function for use within Sanity Studios to create scrollable containers
 * It also provides a way for components inside a scrollable container to track onScroll on their first parent scroll container
 * NOTE: this is used by different studio utilities to track positions of elements on screen
 * NOTE: It will call any given `onScroll` callback with a Native DOM Event, and not a React Synthetic event
 * NOTE: It will not make sure the element is actually scrollable, this still needs to be done with css as usual
 *
 * @internal
 */
export declare const ScrollContainer: React_2.ForwardRefExoticComponent<
  Omit<ScrollContainerProps<React_2.ElementType<any>>, 'ref'> &
    React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare interface ScrollContainerProps<T extends React_2.ElementType>
  extends Omit<React_2.HTMLProps<T>, 'as' | 'onScroll'> {
  as?: React_2.ElementType | keyof JSX.IntrinsicElements
  onScroll?: (event: Event) => () => void
}

/** @internal */
export declare interface ScrollContextValue {
  onScroll?: ScrollEventHandler
}

/** @internal */
export declare type ScrollEventHandler = (event: Event) => void

/** @internal */
export declare function ScrollMonitor({onScroll, children}: ScrollMonitorProps): React_2.JSX.Element

/** @internal */
export declare interface ScrollMonitorProps {
  onScroll: ScrollEventHandler
  children?: React_2.ReactNode
}

/**
 * @internal
 */
export declare interface SearchableType {
  name: string
  title?: string
  __experimental_search: ObjectSchemaType['__experimental_search']
}

/**
 * @internal
 */
export declare function SearchDialog({
  onClose,
  onOpen,
  open,
}: SearchDialogProps): React_2.JSX.Element

declare interface SearchDialogProps {
  onClose: () => void
  onOpen: () => void
  open: boolean
}

/**
 * @internal
 */
export declare function SearchField(): React_2.JSX.Element

/**
 * @internal
 */
declare interface SearchFieldDefinition {
  documentTypes: string[]
  fieldPath: string
  filterName: string
  id: string
  name: string
  title: string
  titlePath: string[]
  type: string
}

declare interface SearchFilterBaseDefinition<TOperators> {
  description?: string
  icon: ComponentType
  name: string
  operators: Operator<TOperators>[]
}

/**
 * @alpha
 */
export declare type SearchFilterDefinition<TOperators = string> =
  | SearchFilterFieldDefinition<TOperators>
  | SearchFilterPinnedDefinition<TOperators>

declare interface SearchFilterFieldDefinition<TOperators = string>
  extends SearchFilterBaseDefinition<TOperators> {
  fieldType: IntrinsicTypeName
  type: 'field'
}

declare interface SearchFilterPinnedDefinition<TOperators = string>
  extends SearchFilterBaseDefinition<TOperators> {
  fieldPath?: string
  group?: string
  title: string
  type: 'pinned'
}

/**
 * @alpha
 */
export declare interface SearchOperatorBase {
  buttonLabel?: string
  label: string
  icon?: ComponentType
  type: string
}

/**
 * @alpha
 */
export declare interface SearchOperatorBuilder<TType extends string, TValue>
  extends SearchOperatorBase {
  buttonValueComponent: SearchOperatorButtonValue<TValue>
  groqFilter: (params: SearchOperatorParams<TValue>) => string | null
  initialValue: TValue | null
  inputComponent: SearchOperatorInput<TValue>
  type: TType
}

/**
 * @alpha
 */
export declare type SearchOperatorButtonValue<TValue> = ComponentType<
  OperatorButtonValueComponentProps<TValue>
>

/** @internal */
declare interface SearchOperatorDefinition<TValue = any> extends SearchOperatorBase {
  buttonValueComponent?: SearchOperatorButtonValue<TValue>
  groqFilter: (params: SearchOperatorParams<TValue>) => string | null
  initialValue?: TValue
  inputComponent?: SearchOperatorInput<TValue>
  type: string
}

/**
 * @alpha
 */
export declare type SearchOperatorInput<TValue> = ComponentType<OperatorInputComponentProps<TValue>>

/**
 * @alpha
 */
export declare type SearchOperatorParams<TValue> = {
  fieldPath?: string
  value?: TValue
}

declare const searchOperators: {
  stringEqual: SearchOperatorBuilder<'stringEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringEqual'
  }
  stringListEqual: SearchOperatorBuilder<'stringListEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringListEqual'
  }
  stringListNotEqual: SearchOperatorBuilder<'stringListNotEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringListNotEqual'
  }
  stringMatches: SearchOperatorBuilder<'stringMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringMatches'
  }
  stringNotEqual: SearchOperatorBuilder<'stringNotEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringNotEqual'
  }
  stringNotMatches: SearchOperatorBuilder<'stringNotMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'stringNotMatches'
  }
  slugEqual: SearchOperatorBuilder<'slugEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    /**
     * @internal
     */
    label: string
    type: 'slugEqual'
  }
  slugMatches: SearchOperatorBuilder<'slugMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'slugMatches'
  }
  slugNotEqual: SearchOperatorBuilder<'slugNotEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'slugNotEqual'
  }
  slugNotMatches: SearchOperatorBuilder<'slugNotMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'slugNotMatches'
  }
  referenceEqual: SearchOperatorBuilder<'referenceEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<Reference>
    label: string
    type: 'referenceEqual'
  }
  referenceNotEqual: SearchOperatorBuilder<'referenceNotEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<Reference>
    label: string
    type: 'referenceNotEqual'
  }
  referencesAssetFile: SearchOperatorBuilder<'referencesAssetFile', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
    label: string
    type: 'referencesAssetFile'
  }
  referencesAssetImage: SearchOperatorBuilder<'referencesAssetImage', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
    label: string
    type: 'referencesAssetImage'
  }
  referencesDocument: SearchOperatorBuilder<'referencesDocument', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<Reference>
    label: string
    type: 'referencesDocument'
  }
  portableTextEqual: SearchOperatorBuilder<'portableTextEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'portableTextEqual'
  }
  portableTextMatches: SearchOperatorBuilder<'portableTextMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'portableTextMatches'
  }
  portableTextNotEqual: SearchOperatorBuilder<'portableTextNotEqual', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'portableTextNotEqual'
  }
  portableTextNotMatches: SearchOperatorBuilder<'portableTextNotMatches', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'portableTextNotMatches'
  }
  numberEqual: SearchOperatorBuilder<'numberEqual', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberEqual'
  }
  numberGt: SearchOperatorBuilder<'numberGt', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX_2.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberGt'
  }
  numberGte: SearchOperatorBuilder<'numberGte', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX_2.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberGte'
  }
  numberLt: SearchOperatorBuilder<'numberLt', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX_2.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberLt'
  }
  numberLte: SearchOperatorBuilder<'numberLte', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX_2.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberLte'
  }
  numberNotEqual: SearchOperatorBuilder<'numberNotEqual', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'numberNotEqual'
  }
  numberRange: SearchOperatorBuilder<'numberRange', OperatorNumberRangeValue> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorNumberRangeValue>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorNumberRangeValue>) => string
    initialValue: null
    inputComponent: SearchOperatorInput<OperatorNumberRangeValue>
    label: string
    type: 'numberRange'
  }
  defined: ValuelessSearchOperatorBuilder<'defined'> & {
    buttonLabel: string
    groqFilter: ({fieldPath}: ValuelessSearchOperatorParams) => string | null
    label: string
    type: 'defined'
  }
  notDefined: ValuelessSearchOperatorBuilder<'notDefined'> & {
    buttonLabel: string
    groqFilter: ({fieldPath}: ValuelessSearchOperatorParams) => string | null
    label: string
    type: 'notDefined'
  }
  dateAfter: SearchOperatorBuilder<'dateAfter', OperatorDateDirectionValue> & {
    groqFilter: ({
      fieldPath,
      value,
    }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
    type: 'dateAfter'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
    initialValue: null
    label: string
  }
  dateBefore: SearchOperatorBuilder<'dateBefore', OperatorDateDirectionValue> & {
    groqFilter: ({
      fieldPath,
      value,
    }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
    type: 'dateBefore'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
    initialValue: null
    label: string
  }
  dateEqual: SearchOperatorBuilder<'dateEqual', OperatorDateEqualValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateEqualValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateEqualValue>
    type: 'dateEqual'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
    initialValue: {
      date: null
      includeTime: boolean
    }
    label: string
  }
  dateLast: SearchOperatorBuilder<'dateLast', OperatorDateLastValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateLastValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateLastValue>
    initialValue: {
      unit: string
      unitValue: number
    }
    type: 'dateLast'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateLastValue>
    label: string
  }
  dateNotEqual: SearchOperatorBuilder<'dateNotEqual', OperatorDateEqualValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateEqualValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateEqualValue>
    type: 'dateNotEqual'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
    initialValue: {
      date: null
      includeTime: boolean
    }
    label: string
  }
  dateRange: SearchOperatorBuilder<'dateRange', OperatorDateRangeValue> & {
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateRangeValue>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateRangeValue>) => string | null
    initialValue: {
      includeTime: boolean
      dateMax: string
      dateMin: null
    }
    inputComponent: SearchOperatorInput<OperatorDateRangeValue>
    type: 'dateRange'
    buttonLabel: string
    label: string
  }
  dateTimeAfter: SearchOperatorBuilder<'dateTimeAfter', OperatorDateDirectionValue> & {
    groqFilter: ({
      fieldPath,
      value,
    }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
    type: 'dateTimeAfter'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
    initialValue: null
    label: string
  }
  dateTimeBefore: SearchOperatorBuilder<'dateTimeBefore', OperatorDateDirectionValue> & {
    groqFilter: ({
      fieldPath,
      value,
    }: SearchOperatorParams<OperatorDateDirectionValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateDirectionValue>
    type: 'dateTimeBefore'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateDirectionValue>
    initialValue: null
    label: string
  }
  dateTimeEqual: SearchOperatorBuilder<'dateTimeEqual', OperatorDateEqualValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateEqualValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateEqualValue>
    type: 'dateTimeEqual'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
    initialValue: {
      date: null
      includeTime: boolean
    }
    label: string
  }
  dateTimeLast: SearchOperatorBuilder<'dateTimeLast', OperatorDateLastValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateLastValue>) => string | null
    initialValue: {
      unit: string
      unitValue: number
    }
    inputComponent: SearchOperatorInput<OperatorDateLastValue>
    type: 'dateTimeLast'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateLastValue>
    label: string
  }
  dateTimeNotEqual: SearchOperatorBuilder<'dateTimeNotEqual', OperatorDateEqualValue> & {
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateEqualValue>) => string | null
    inputComponent: SearchOperatorInput<OperatorDateEqualValue>
    type: 'dateTimeNotEqual'
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateEqualValue>
    initialValue: {
      date: null
      includeTime: boolean
    }
    label: string
  }
  dateTimeRange: SearchOperatorBuilder<'dateTimeRange', OperatorDateRangeValue> & {
    buttonValueComponent: SearchOperatorButtonValue<OperatorDateRangeValue>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorDateRangeValue>) => string | null
    initialValue: {
      includeTime: boolean
      dateMax: string
      dateMin: null
    }
    inputComponent: SearchOperatorInput<OperatorDateRangeValue>
    type: 'dateTimeRange'
    buttonLabel: string
    label: string
  }
  booleanEqual: SearchOperatorBuilder<'booleanEqual', boolean> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<boolean>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<boolean>) => string | null
    initialValue: boolean
    inputComponent: SearchOperatorInput<boolean>
    label: string
    type: 'booleanEqual'
  }
  assetFileEqual: SearchOperatorBuilder<'assetFileEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
    label: string
    type: 'assetFileEqual'
  }
  assetFileNotEqual: SearchOperatorBuilder<'assetFileNotEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
    label: string
    type: 'assetFileNotEqual'
  }
  assetImageEqual: SearchOperatorBuilder<'assetImageEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
    label: string
    type: 'assetImageEqual'
  }
  assetImageNotEqual: SearchOperatorBuilder<'assetImageNotEqual', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: ({onChange, value}: OperatorInputComponentProps<Reference>) => JSX_2.Element
    label: string
    type: 'assetImageNotEqual'
  }
  arrayCountEqual: SearchOperatorBuilder<'arrayCountEqual', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountEqual'
  }
  arrayCountGt: SearchOperatorBuilder<'arrayCountGt', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX_2.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountGt'
  }
  arrayCountGte: SearchOperatorBuilder<'arrayCountGte', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX_2.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountGte'
  }
  arrayCountLt: SearchOperatorBuilder<'arrayCountLt', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX_2.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountLt'
  }
  arrayCountLte: SearchOperatorBuilder<'arrayCountLte', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    icon: () => JSX_2.Element
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountLte'
  }
  arrayCountNotEqual: SearchOperatorBuilder<'arrayCountNotEqual', number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<number>
    label: string
    type: 'arrayCountNotEqual'
  }
  arrayCountRange: SearchOperatorBuilder<'arrayCountRange', OperatorNumberRangeValue> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<OperatorNumberRangeValue>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<OperatorNumberRangeValue>) => string
    initialValue: null
    inputComponent: SearchOperatorInput<OperatorNumberRangeValue>
    label: string
    type: 'arrayCountRange'
  }
  arrayListIncludes: SearchOperatorBuilder<'arrayListIncludes', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'arrayListIncludes'
  }
  arrayListNotIncludes: SearchOperatorBuilder<'arrayListNotIncludes', string | number> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<string | number>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<string | number>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<string | number>
    label: string
    type: 'arrayListNotIncludes'
  }
  arrayReferenceIncludes: SearchOperatorBuilder<'arrayReferenceIncludes', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<Reference>
    label: string
    type: 'arrayReferenceIncludes'
  }
  arrayReferenceNotIncludes: SearchOperatorBuilder<'arrayReferenceNotIncludes', Reference> & {
    buttonLabel: string
    buttonValueComponent: SearchOperatorButtonValue<Reference>
    groqFilter: ({fieldPath, value}: SearchOperatorParams<Reference>) => string | null
    initialValue: null
    inputComponent: SearchOperatorInput<Reference>
    label: string
    type: 'arrayReferenceNotIncludes'
  }
}

/**
 * @alpha
 */
export declare type SearchOperatorType = keyof DefaultOperators

/**
 * @internal
 */
export declare interface SearchOptions {
  __unstable_extendedProjection?: string
  comments?: string[]
  includeDrafts?: boolean
  limit?: number
  offset?: number
  skipSortByScore?: boolean
  sort?: SearchSort[]
}

declare interface SearchParams {
  __types: string[]
  __limit: number
  __offset: number
  [key: string]: unknown
}

/**
 * @internal
 */
declare interface SearchPath {
  weight: number
  path: string
  mapWith?: string
}

declare type SearchPathSegment = string | number | []

declare interface SearchQuery {
  query: string
  params: SearchParams
  options: Record<string, unknown>
  searchSpec: SearchSpec[]
  terms: string[]
}

/**
 * @internal
 */
export declare type SearchSort = {
  direction: SortDirection
  field: string
  mapWith?: string
}

/**
 * @internal
 */
declare interface SearchSpec {
  typeName: string
  paths?: SearchPath[]
}

/**
 * @internal
 */
export declare interface SearchTerms {
  filter?: string
  query: string
  types: SearchableType[]
}

/**
 *
 * @hidden
 * @beta
 */
export declare function SelectInput(props: StringInputProps): React_2.JSX.Element

/** @internal */
declare type Selection_2 = [Id, FieldName[]]
export {Selection_2 as Selection}

/**
 * @hidden
 * @beta */
export declare type SelectionState = 'inactive' | 'rev' | 'range' | 'loading' | 'invalid'

/** @internal */
export declare type Serializeable<T> = {
  serialize(): T
}

/** @internal */
export declare interface Session {
  sessionId: string
  userId: string
  lastActiveAt: string
  locations: PresenceLocation[]
}

/** @internal */
export declare const SESSION_ID: string

/**
 * @hidden
 * @beta */
export declare function set(value: any, path?: Path): FormSetPatch

/** @internal */
export declare interface SetActiveGroupOperation {
  type: 'setSelectedGroup'
  path: Path
  groupName: string
}

/** @internal */
export declare function setAtPath<T>(
  currentTree: StateTree<T> | undefined,
  path: Path,
  value: T,
): StateTree<T>

/**
 * @hidden
 * @beta */
export declare function setIfMissing(value: any, path?: Path): FormSetIfMissingPatch

/** @internal */
export declare interface Settings {
  forKey: (key: string) => {
    listen: (defaultValue: unknown) => Observable<unknown>
    set: (value: string) => void
    del: () => void
  }
  listen: (key: string, defaultValue: unknown) => Observable<unknown>
  set: (key: string, value: unknown) => void
  del: (key: string) => void
  forNamespace: (sub: string) => Settings
}

/** @internal */
export declare interface SettingsStore {
  forNamespace: (ns: string) => Settings
}

/** @internal */
export declare interface SharedResizeObserver {
  observe: (
    element: Element,
    observer: Subscriber<ResizeObserverEntry_2>,
    options?: ResizeObserverOptions,
  ) => () => void
}

/** @internal */
export declare class SimpleFocusManager extends React_2.Component<
  SimpleFocusManagerProps,
  SimpleFocusManagerState
> {
  state: {
    focusPath: never[]
  }
  handleFocus: (path: Path) => void
  handleBlur: () => void
  render(): any
}

/** @internal */
export declare interface SimpleFocusManagerProps {
  path: any | null
  onFocus: () => void
  onBlur: () => void
  children: (arg: any) => any
}

/** @internal */
export declare interface SimpleFocusManagerState {
  focusPath: Array<any>
}

/**
 * If a single workspace is used, not specifying a name or basePath is acceptable
 *
 *
 * @hidden
 * @beta
 */
export declare type SingleWorkspace = Omit<WorkspaceOptions, 'name' | 'basePath'> & {
  name?: string
  basePath?: string
}

/** @internal */
export declare type Size = 'xsmall' | 'small' | 'medium'

/**
 *
 * @hidden
 * @beta
 */
export declare interface SlugComponents {
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps<SlugValue>>
  input?: ComponentType<ObjectInputProps<SlugValue>>
  item?: ComponentType<ObjectItemProps<SlugValue & ObjectItem>>
  preview?: ComponentType<PreviewProps>
}

/**
 *
 * @hidden
 * @beta
 */
export declare function SlugInput(props: SlugInputProps): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type SlugInputProps = ObjectInputProps<SlugValue, SlugSchemaType>

/**
 * @hidden
 * @beta */
export declare interface SnapshotEvent {
  type: 'snapshot'
  document: SanityDocument
}

/** @internal */
declare interface SnapshotPair {
  transactionsPendingEvents$: Observable<PendingMutationsEvent>
  draft: DocumentVersionSnapshots
  published: DocumentVersionSnapshots
}

/** @internal */
export declare const snapshotPair: (
  arg1: SanityClient,
  arg2: IdPair,
  arg3: string,
) => Observable<SnapshotPair>

/**
 * @internal
 */
declare type SortDirection = 'asc' | 'desc'

/**
 * Represents a source.
 * @public
 */
export declare interface Source {
  /** The type of the source. */
  type: 'source'
  /** The name of the source. */
  name: string
  /** The title of the source. */
  title: string
  /** The ID of the project. */
  projectId: string
  /** The name of the dataset. */
  dataset: string
  /** The schema of the source. */
  schema: Schema
  /** The templates of the source. */
  templates: Template[]
  /** The tools of the source. */
  tools: Tool[]
  /** The current user of the source. */
  currentUser: CurrentUser | null
  /** Whether the user is authenticated. */
  authenticated: boolean
  /** @internal */
  auth: AuthStore
  /**
   * Returns a client instance.
   * @param clientOptions - Options to pass to the client. See {@link SourceClientOptions}
   */
  getClient: (clientOptions: SourceClientOptions) => SanityClient
  /**
   * Document-related functionality.
   * @hidden
   * @beta
   */
  document: {
    /**
     * Returns an array of actions for the document.
     * @hidden
     * @beta
     */
    actions: (props: PartialContext<DocumentActionsContext>) => DocumentActionComponent[]
    /**
     * Returns an array of badges for the document.
     * @hidden
     * @beta
     */
    badges: (props: PartialContext<DocumentActionsContext>) => DocumentBadgeComponent[]
    /** @internal */
    unstable_fieldActions: (
      props: PartialContext<DocumentFieldActionsResolverContext>,
    ) => DocumentFieldAction[]
    /**
     * Resolves the production URL for the document.
     * @hidden
     * @beta
     */
    resolveProductionUrl: (
      context: PartialContext<ResolveProductionUrlContext>,
    ) => Promise<string | undefined>
    /**
     * Resolves the new document options.
     * @hidden
     * @beta
     */
    resolveNewDocumentOptions: (context: NewDocumentCreationContext) => InitialValueTemplateItem[]
    /** @alpha */
    unstable_languageFilter: (
      props: PartialContext<DocumentLanguageFilterContext>,
    ) => DocumentLanguageFilterComponent[]
    /**
     * @hidden
     * @beta
     */
    inspectors: (props: PartialContext<DocumentInspectorContext>) => DocumentInspector[]
    /** @internal */
    unstable_comments: {
      enabled: (props: DocumentCommentsEnabledContext) => boolean
    }
  }
  /**
   * Form-related functionality.
   * @hidden
   * @beta
   */
  form: {
    /**
     * File-related functionality.
     * @hidden
     * @beta
     */
    file: {
      /** The asset sources. */
      assetSources: AssetSource[]
      /** Whether direct uploads are enabled. */
      directUploads: boolean
    }
    /**
     * Image-related functionality.
     * @hidden
     * @beta
     */
    image: {
      /** The asset sources. */
      assetSources: AssetSource[]
      /** Whether direct uploads are enabled. */
      directUploads: boolean
    }
    /**
     * Components for the form.
     * @hidden
     * @beta
     */
    components?: {
      input?: ComponentType<Omit<InputProps, 'renderDefault'>>
      field?: ComponentType<Omit<FieldProps, 'renderDefault'>>
      item?: ComponentType<Omit<ItemProps, 'renderDefault'>>
      preview?: ComponentType<Omit<PreviewProps, 'renderDefault'>>
    }
    /**
     * these have not been migrated over and are not merged by the form builder
     *
     * @hidden
     * @beta
     */
    unstable?: {
      CustomMarkers?: FormBuilderCustomMarkersComponent
      Markers?: FormBuilderMarkersComponent
    }
  }
  /**
   * @hidden
   * @beta
   */
  studio?: {
    /**
     * @hidden
     * @beta
     */
    components?: StudioComponents
  }
  /** @alpha */
  search: {
    filters: SearchFilterDefinition[]
    operators: SearchOperatorDefinition[]
  }
  /** @internal */
  __internal: {
    bifur: BifurClient
    staticInitialValueTemplateItems: InitialValueTemplateItem[]
    options: SourceOptions
  }
}

/** @public */
export declare interface SourceClientOptions {
  /**
   * API version to use. See {@link https://www.sanity.io/docs/api-versioning | api-versioning}
   */
  apiVersion: string
}

/**
 * @hidden
 * @beta
 */
export declare interface SourceOptions extends PluginOptions {
  title?: string
  /**
   * Project ID for this source
   */
  projectId: string
  /**
   * Dataset name for this source
   */
  dataset: string
  /**
   * API hostname used for requests. Generally used for custom CNAMEs, allowing businesses to use
   * their own domain for API requests. Must include protocol:
   * eg `https://sanityapi.mycompany.com`
   *
   * Note that (currently) the project ID will be prepended to the passed URL, so the above
   * example would end up as: `https://<projectId>.sanityapi.mycompany.com`
   */
  apiHost?: string
  /**
   * Authentication options for this source.
   */
  auth?: AuthConfig | AuthStore
  /**
   * @hidden
   * @beta
   */
  unstable_clientFactory?: (options: ClientConfig) => SanityClient
}

/** @internal */
export declare function SourceProvider({
  children,
  ...props
}: SourceProviderProps): React_2.JSX.Element

/** @internal */
export declare type SourceProviderProps =
  | {
      source: Source
      children?: React_2.ReactNode
    }
  | {
      name: string
      children?: React_2.ReactNode
    }

/**
 *
 * @hidden
 * @beta
 */
export declare interface SpanComponents {
  diff?: ComponentType<any>
  field?: ComponentType<ObjectFieldProps>
  input?: ComponentType<ObjectInputProps>
  item?: ComponentType<ObjectItemProps>
  preview?: ComponentType<PreviewProps>
}

declare interface State {
  disableTransition: boolean
}

declare interface State_2 {
  isLoading: boolean
  error?: Error
  value?: PreviewValue
}

/**
 * @hidden
 * @beta */
export declare interface StateTree<T> {
  value: T | undefined
  children?: {
    [key: string]: StateTree<T>
  }
}

/** @internal */
export declare type Status = 'online' | 'editing' | 'inactive'

/** @hidden @beta */
export declare const StatusButton: React_2.ForwardRefExoticComponent<
  StatusButtonProps &
    Omit<React_2.HTMLProps<HTMLButtonElement>, 'ref' | 'disabled'> &
    React_2.RefAttributes<HTMLButtonElement>
>

/** @hidden @beta */
export declare interface StatusButtonProps extends Omit<ButtonProps, 'iconRight'> {
  disabled?:
    | boolean
    | {
        reason: ReactNode
      }
  hotkey?: string[]
  label?: string
  mode?: ButtonMode
  tooltip?: Omit<TooltipProps, 'content' | 'disabled' | 'portal'>
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface StringComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/** @internal */
export declare type StringDiff = StringDiff_2<Annotation>

/** @internal */
export declare type StringDiffSegment = StringSegmentChanged | StringSegmentUnchanged

/**
 * @hidden
 * @public */
export declare interface StringFieldProps extends BaseFieldProps {
  schemaType: StringSchemaType
  value: string | undefined
  inputProps: StringInputProps
}

/** @public */
export declare type StringFormNode<S extends StringSchemaType = StringSchemaType> = BaseFormNode<
  string,
  S
>

/**
 *
 * @hidden
 * @beta
 */
export declare function StringInput(props: StringInputProps): React_2.JSX.Element

/**
 * @hidden
 * @public */
export declare interface StringInputProps<S extends StringSchemaType = StringSchemaType>
  extends BaseInputProps,
    StringFormNode<S> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/** @internal */
export declare type StringSegmentChanged = StringSegmentChanged_2<Annotation>

/** @internal */
export declare type StringSegmentUnchanged = StringSegmentUnchanged_2

/** @internal */
export declare function stringToPath(path: string): Path

/**
 * @hidden
 * @beta */
export declare function Studio(props: StudioProps): ReactElement

/**
 * @hidden
 * @beta */
export declare interface StudioComponents {
  layout: React_2.ComponentType<Omit<LayoutProps, 'renderDefault'>>
  logo: React_2.ComponentType<Omit<LogoProps, 'renderDefault'>>
  navbar: React_2.ComponentType<Omit<NavbarProps, 'renderDefault'>>
  toolMenu: React_2.ComponentType<Omit<ToolMenuProps, 'renderDefault'>>
}

/**
 * @hidden
 * @beta */
export declare interface StudioComponentsPluginOptions {
  layout?: React_2.ComponentType<LayoutProps>
  logo?: React_2.ComponentType<LogoProps>
  navbar?: React_2.ComponentType<NavbarProps>
  toolMenu?: React_2.ComponentType<ToolMenuProps>
}

/**
 * The Studio Layout component is the root component of the Sanity Studio UI.
 * It renders the navbar, the active tool, and the search modal as well as the error boundary.
 *
 * @public
 * @returns A Studio Layout element that renders the navbar, the active tool, and the search modal as well as the error boundary
 * @remarks This component should be used as a child component to the StudioProvider
 * @example Rendering a Studio Layout
 * ```ts
 * <StudioProvider
 *  basePath={basePath}
 *  config={config}
 *  onSchemeChange={onSchemeChange}
 *  scheme={scheme}
 *  unstable_history={unstable_history}
 *  unstable_noAuthBoundary={unstable_noAuthBoundary}
 * >
 *   <StudioLayout />
 *</StudioProvider>
 * ```
 */
export declare function StudioLayout(): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare function StudioLogo(props: LogoProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare function StudioNavbar(): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare interface StudioProps {
  config: Config
  basePath?: string
  /**
   * Useful for scenarios where the Studio is embedded in another app,
   * and the surrounding app also implements light and dark color schemes.
   *
   * The callback is fired whenever the user selects a new color scheme in the "Appearance" menu in the top-right dropdown.
   * It also fires on first render with its initial value if you don't provide a `scheme` prop.
   *
   * If the user selects "System" in the "Appearance" menu, the callback will be fired with `"system"` as the scheme.
   * To resolve `"system"` to the same color scheme as the Studio use the `usePrefersDark` hook from `@sanity/ui`:
   *
   * ```tsx
   * import {usePrefersDark} from '@sanity/ui'
   * import {Studio} from 'sanity'
   *
   * export default function StudioPage() {
   *   const prefersDark = usePrefersDark()
   *   const [_scheme, setScheme] = useState('system')
   *   const prefersScheme = prefersDark ? 'dark' : 'light'
   *   const scheme = _scheme === 'system' ? prefersScheme : _scheme
   *
   *   return (
   *     <AppLayout scheme={scheme}>
   *       <Studio config={config} onSchemeChange={setScheme} />
   *     </AppLayout>
   *   )
   * }
   * ```
   *
   *
   * @hidden
   * @beta
   */
  onSchemeChange?: (nextScheme: StudioThemeColorSchemeKey) => void
  /**
   * By default the Studio handles the color scheme itself, but you can provide a color scheme to use.
   * If you only define `scheme` then the top-right "Appearance" dropdown menu will be hidden,
   * and the Studio will stay in sync with the `scheme` prop.
   *
   * You may setup two-way sync and re-enable the "Appearance" dropdown menu by also providing an `onSchemeChange` callback:
   * ```tsx
   * import {Studio} from 'sanity'
   * import {useSession} from 'your-app'
   *
   * export default function StudioPage() {
   *   const session = useSession()
   *   // Overrides the default scheme to be what's in the app user session
   *   const [_scheme, setScheme] = useState(session.scheme)
   *   const scheme = _scheme === 'system' ? session.scheme : _scheme
   *
   *   return (
   *     <AppLayout scheme={scheme}>
   *       <Studio config={config} scheme={scheme} onSchemeChange={setScheme} />
   *     </AppLayout>
   *   )
   * }
   * ```
   *
   *
   * @hidden
   * @beta
   */
  scheme?: StudioThemeColorSchemeKey
  /**
   * @hidden
   * @beta */
  unstable_history?: RouterHistory
  /**
   * @hidden
   * @beta */
  unstable_globalStyles?: boolean
  /**
   * @hidden
   * @beta */
  unstable_noAuthBoundary?: boolean
}

/**
 * @hidden
 * @beta */
export declare function StudioProvider({
  children,
  config,
  basePath,
  onSchemeChange,
  scheme,
  unstable_history: history,
  unstable_noAuthBoundary: noAuthBoundary,
}: StudioProviderProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare interface StudioProviderProps extends StudioProps {
  children: React_2.ReactNode
}

/** @public */
export declare interface StudioTheme extends RootTheme {
  /** @internal */
  __dark?: boolean
  /** @internal */
  __legacy?: boolean
}

/**
 * Used to specify light or dark mode, or to respect system settings (prefers-color-scheme media query) use 'system'
 * @public
 */
export declare type StudioThemeColorSchemeKey = ThemeColorSchemeKey | 'system'

/**
 * @hidden
 * @beta */
export declare function StudioToolMenu(props: ToolMenuProps): React_2.JSX.Element

/** @internal */
export declare const supportsTouch: boolean

/** @internal */
export declare interface SyncState {
  isSyncing: boolean
}

/**
 *
 * @hidden
 * @beta
 */
export declare function TagsArrayInput(props: TagsArrayInputProps): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type TagsArrayInputProps = ArrayOfPrimitivesInputProps<string>

/**
 *
 * @hidden
 * @beta
 */
export declare function TelephoneInput(props: TelephoneInputProps): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type TelephoneInputProps = StringInputProps

/**
 * An initial value template is a template that can be used to create a new documents.
 *
 * This allows a document type to have multiple different starting values while having the same
 * shared schema definition. Using parameters allows for dynamic template values.
 *
 * As the name implies, these are _initial_ values, not _default_ values. The distinction is that
 * the initial value is only set when the document is created - it is not "merged" into existing
 * documents that may lack values for fields.
 *
 * All document types will by default (automatically, behind the scenes) have an initial value
 * template generated for them, which will have the same ID as the schema type name. The value of
 * this template will be the value of the `initialValue` property on the schema type definition,
 * or an empty object if none is set.
 *
 * @public
 */
export declare interface Template<Params = any, Value = any> {
  /**
   * Template ID. Automatically generated templates will have the same ID as the schema type name.
   */
  id: string
  /**
   * Template title.
   */
  title: string
  /**
   * Schema type name the template belongs to. For the automatically generated templates,
   * this will be equal to the `id` property.
   */
  schemaType: string
  /**
   * Template icon. Rendered in places such as the "new document" dialog. Optional.
   * Inferred from the schema type icon if not set.
   */
  icon?: SchemaType['icon']
  /**
   * Value to use as initial value. Can either be a static object value, or a function that
   * resolves _to_ an object value. If using a function, it can be given a set of parameters,
   * which can then determine the value that is returned.
   */
  value: InitialValueProperty<Params, Value>
  /**
   * Array of parameters the template accepts. Currently not used (any parameters are accepted),
   * but by defining parameters, the templates that require parameters can be identified and
   * excluded from UIs that do not provide them.
   */
  parameters?: TemplateParameter[]
  /**
   * Template description. Rendered in places such as the "new document" dialog. Optional.
   *
   * @deprecated No longer used
   */
  description?: string
}

/** @public */
export declare type TemplateArrayFieldDefinition = TemplateFieldDefinition & {
  type: 'array'
  /** Defines items that are definition of. See {@link TemplateReferenceTarget} and {@link TypeTarget} */
  of: (TemplateReferenceTarget | TypeTarget)[]
}

/**
 * Field definition for a template parameter.
 * Closely resembles API used to define fields for object schema types.
 *
 * @public
 */
export declare interface TemplateFieldDefinition {
  /**
   * Parameter name. Must be unique within the template.
   */
  name: string
  /**
   * Parameter type, eg `string`, `number`, `boolean` etc.
   */
  type: string
  /**
   * Parameter type. Will be attempted to be automatically set if not given,
   * by title-casing the `name` property.
   */
  title?: string
  /**
   * Description for the parameter. Optional.
   * May be used in the future to explain the parameter in UIs.
   */
  description?: string
  /**
   * Optional bag of options for the parameter. Currently unused.
   */
  options?: {
    [key: string]: any
  }
}

/**
 * Represents the items that can appear in different parts of the Sanity studio when creating
 * new documents - examples being the "New document" button in the navigation bar,
 * the corresponding button in panes, as well as the "Create new" button on references.
 *
 * Differs from an actual _template_ in that a single template can be pointed at by multiple
 * different items. This is useful when the template can create different values based on
 * passed parameters.
 *
 * @public
 */
export declare interface TemplateItem {
  /**
   * ID for the template. Must be unique within the set of templates.
   */
  templateId: string
  /**
   * Title for the item.
   * Defaults to the title of the associated template.
   */
  title?: string
  /**
   * Parameters for the template - an object of any JSON-serializable values
   */
  parameters?: {
    [key: string]: any
  }
  /**
   * React icon for the item, if any.
   * Defaults to the icon for the associated template.
   */
  icon?: ElementType | ReactElement
  /**
   * Experimental: not fully supported yet
   * Hints at what the document ID for the new document should be.
   * Leave undefined to let the system decide.
   *
   * @experimental
   * @beta
   * @hidden
   */
  initialDocumentId?: string
  /**
   * @deprecated No longer used anywhere
   * @hidden
   */
  subtitle?: string
  /**
   * @deprecated No longer used anywhere
   * @hidden
   */
  description?: string
}

/** @internal */
export declare interface TemplateOption {
  id: string
  params?: Record<string, string | number | boolean>
}

/**
 * Parameter for a template. Closely resembles API used to define fields for object schema types.
 * See {@link TemplateFieldDefinition} and {@link TemplateArrayFieldDefinition}
 * @public
 */
export declare type TemplateParameter = TemplateFieldDefinition | TemplateArrayFieldDefinition

/** @internal */
export declare interface TemplatePermissionsOptions {
  grantsStore: GrantsStore
  schema: Schema
  templates: Template[]
  templateItems: InitialValueTemplateItem[]
  context: InitialValueResolverContext
}

/** @internal */
export declare interface TemplatePermissionsResult<TInitialValue = Record<string, unknown>>
  extends PermissionCheckResult,
    InitialValueTemplateItem {
  granted: boolean
  reason: string
  resolvedInitialValue: TInitialValue
  subtitle?: string
  template: Template
}

/**
 * @hidden
 * @beta */
export declare function TemplatePreview(props: TemplatePreviewProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare interface TemplatePreviewProps {
  description?: React_2.ReactNode
  isPlaceholder?: boolean
  media?: MediaProps['media']
  mediaDimensions?: PreviewMediaDimensions
  subtitle?:
    | React_2.ElementType<{
        layout: 'default'
      }>
    | React_2.ReactNode
  title?:
    | React_2.ElementType<{
        layout: 'default'
      }>
    | React_2.ReactNode
}

/** @public */
export declare interface TemplateReferenceTarget {
  type: 'reference'
  /** Type to reference. See {@link TypeTarget} */
  to: TypeTarget | TypeTarget[]
}

/** @public */
export declare type TemplateResolver = ComposableOption<Template[], ConfigContext>

/**
 *
 * @hidden
 * @beta
 */
export declare interface TextComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 *
 * @hidden
 * @beta
 */
export declare function TextInput(props: TextInputProps): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type TextInputProps = StringInputProps<TextSchemaType>

/** @internal */
export declare const TextWithTone: React_2.ForwardRefExoticComponent<
  Omit<TextWithToneProps, 'ref'> & React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare interface TextWithToneProps extends ComponentProps<typeof Text_2> {
  tone: ButtonTone
  dimmed?: boolean
}

/** @internal */
export declare interface TimeAgoOpts {
  minimal?: boolean
  agoSuffix?: boolean
}

/**
 * Timeline maintains information about the history of a document:
 * Grouping raw translog entries into sensible groups, replaying and
 * reconstructing different versions and abstract other details.
 *
 * Note that this class by itself is not capable of _fetching_ information,
 * but will only organize and structure the incoming translog entries.
 *
 *
 * @hidden
 * @beta
 */
export declare class Timeline {
  reachedEarliestEntry: boolean
  publishedId: string
  draftId: string
  private _transactions
  private _chunks
  private _possiblePendingTransactions
  private _recreateTransactionsFrom?
  private _trace?
  constructor(opts: TimelineOptions)
  get chunkCount(): number
  /** Maps over the chunk from newest to oldest. */
  mapChunks<T>(mapper: (chunk: Chunk, idx: number) => T): T[]
  reset(): void
  /**
   * Adds a remote mutation to the timeline. This methods assumes that the remote mutations
   * come in correct order for their respective version, but has no ordering requirements
   * across draft/published.
   *
   * Example: [D1, D2, P1] (where D1 and P1 were mutations done to the draft and published
   * version in the same transaction) is a valid input. [P1, D2, D1] is _not_ valid since
   * the mutation for the draft is out of order.
   */
  addRemoteMutation(entry: DocumentRemoteMutationVersionEvent): void
  addTranslogEntry(event: TransactionLogEventWithEffects): void
  /** Mark that we've reached the earliest entry. */
  didReachEarliestEntry(): void
  /**
   * updateChunks synchronizes the chunks to match the current state
   * of the transactions array. After calling this method you need
   * to invalidate all Chunks.
   */
  updateChunks(): void
  private _removeInvalidatedChunks
  private _addChunksFromTransactions
  private _invalidateTransactionFrom
  private _createInitialChunk
  /**
   * Resolves a time reference.
   *
   * Note that the chunk returned is only valid if the timeline stays constant.
   * Once the timeline is updated, you must re-parse all references.
   */
  parseTimeId(id: string): ParsedTimeRef
  findLastPublishedBefore(chunk: Chunk | null): ParsedTimeRef
  isLatestChunk(chunk: Chunk): boolean
  createTimeId(chunk: Chunk): string
  lastChunk(): Chunk
  transactionByIndex(idx: number): Transaction | null
  chunkByTransactionIndex(idx: number, startChunkIdx?: number): Chunk
  replayBackwardsBetween(firstIdx: number, lastIdx: number, doc: CombinedDocument): CombinedDocument
  replayBackwardsUntil(firstIdx: number, doc: CombinedDocument): CombinedDocument
  calculateDiff(
    initialDoc: CombinedDocument,
    finalDoc: CombinedDocument,
    firstIdx: number,
    lastIdx: number,
  ): Diff_2<Annotation>
}

/**
 * The controller is responsible for fetching information
 * about a document and maintaining a Timeline.
 *
 *
 * @hidden
 * @beta
 */
export declare class TimelineController {
  timeline: Timeline
  client: SanityClient
  handler: TimelineControllerOptions['handler']
  version: number
  /**
   * The selection state represents the  different states of the current selection:
   * - inactive: No selection is active.
   * - rev: A selection is active for a single revision.
   * - range: A selection is active for a range and we have all the data needed to render it.
   * - loading: A selection is active, but we don't have the entries yet.
   * - invalid: The selection picked is invalid.
   */
  selectionState: SelectionState
  constructor(options: TimelineControllerOptions)
  private _aligner
  private _fetchMore
  private _fetchAtLeast
  private _isRunning
  private _isSuspended
  private _didErr
  private _since
  private _sinceTime
  private _rev
  private _revTime
  private _reconstruction?
  clearRange(): void
  setRange(since: string | null, rev: string | null): void
  setLoadMore(flag: boolean): void
  get sinceTime(): Chunk | null
  get revTime(): Chunk | null
  get realRevChunk(): Chunk
  /** Returns true when there's an older revision we want to render. */
  onOlderRevision(): boolean
  findRangeForNewRev(rev: Chunk): [string | null, string | null]
  findRangeForNewSince(since: Chunk): [string, string | null]
  setRevTime(rev: string | null): void
  setSinceTime(since: string | null): void
  sinceAttributes(): Record<string, unknown> | null
  displayed(): Record<string, unknown> | null
  setReconstruction(since: Chunk | null, rev: Chunk): void
  currentDiff(): Diff_2<Annotation> | null
  currentObjectDiff(): ObjectDiff_2<Annotation> | null
  handleRemoteMutation(ev: RemoteSnapshotVersionEvent): void
  start(): void
  resume(): void
  suspend(): void
  private tick
  private fetchMoreTransactions
  private markChange
}

/**
 * @hidden
 * @beta */
export declare type TimelineControllerOptions = {
  timeline: Timeline
  client: SanityClient
  documentId: string
  documentType: string
  handler?: (err: Error | null, controller: TimelineController) => void
}

/**
 * @hidden
 * @beta */
export declare interface TimelineOptions {
  publishedId: string
  enableTrace?: boolean
}

/** @internal */
export declare interface TimelineState {
  chunks: Chunk[]
  diff: ObjectDiff_2<Annotation, Record<string, any>> | null
  /** null is used here when the chunks hasn't loaded / is not known */
  hasMoreChunks: boolean | null
  isLoading: boolean
  /**
   * Whether this timeline is fully loaded and completely empty (true for new documents)
   * It can be `null` when the chunks hasn't loaded / is not known
   */
  isPristine: boolean | null
  lastNonDeletedRevId: string | null
  onOlderRevision: boolean
  realRevChunk: Chunk | null
  revTime: Chunk | null
  selectionState: SelectionState
  sinceAttributes: Record<string, unknown> | null
  sinceTime: Chunk | null
  timelineDisplayed: Record<string, unknown> | null
  timelineReady: boolean
}

/** @internal */
export declare interface TimelineStore {
  findRangeForRev: TimelineController['findRangeForNewRev']
  findRangeForSince: TimelineController['findRangeForNewSince']
  loadMore: () => void
  getSnapshot: () => TimelineState
  subscribe: (callback: () => void) => () => void
}

/** @internal */
export declare interface ToastParams {
  closable?: boolean
  description?: React_2.ReactNode
  duration?: number
  onClose?: () => void
  title?: React_2.ReactNode
  status?: 'error' | 'warning' | 'success' | 'info'
}

/**
 * @internal
 */
export declare function toMutationPatches(patches: FormPatch[]): MutationPatch[]

/**
 * A tool can be thought of as a top-level "view" or "app".
 * They are available through the global menu bar, and has a URL route associated with them.
 *
 * In essence, a tool is a React component that is rendered when the tool is active,
 * along with a title, name (URL segment) and icon.
 *
 * Tools can handle {@link desk.Intent | intents} such as "edit" or "create" by defining a
 * function for the `canHandleIntent` property, as well as the `getIntentState` property,
 * which defines what an intent will be mapped to in terms of the tool's URL state.
 *
 * @public
 */
export declare interface Tool<Options = any> {
  /**
   * The React component that renders the tool.
   */
  component: ComponentType<{
    tool: Tool<Options>
  }>
  /**
   * React component for the icon representing the tool.
   */
  icon?: ComponentType
  /**
   * The name of the tool, used as part of the URL.
   */
  name: string
  /**
   * Options are passed through from the configuration to the component defined by the `component`
   */
  options?: Options
  /**
   * The router for the tool. See {@link router.Router}
   */
  router?: Router
  /**
   * Title of the tool - used for the navigation menu item, along with the icon.
   */
  title: string
  /**
   * Determines whether the tool will control the `document.title`.
   */
  controlsDocumentTitle?: boolean
  /**
   * Gets the state for the given intent.
   *
   * @param intent - The intent to get the state for.
   * @param params - The parameters for the intent.
   * @param routerState - The current router state. See {@link router.RouterState}
   * @param payload - The payload for the intent.
   * @returns The state for the intent.
   */
  getIntentState?: (
    intent: string,
    params: Record<string, string>,
    routerState: RouterState | undefined,
    payload: unknown,
  ) => unknown
  /**
   * Determines whether the tool can handle the given intent.
   *
   * @param intent - The intent to check.
   * @param params - The parameters for the intent.
   * @param payload - The payload for the intent.
   * @returns `true` if the tool can handle the intent, `false` otherwise.
   */
  canHandleIntent?: (intent: string, params: Record<string, unknown>, payload: unknown) => boolean
}

/**
 * @hidden
 * @beta */
export declare const ToolLink: React_2.ForwardRefExoticComponent<
  Omit<ToolLinkProps & Omit<React_2.HTMLProps<HTMLAnchorElement>, 'name' | 'href'>, 'ref'> &
    React_2.RefAttributes<HTMLAnchorElement>
>

/**
 * @hidden
 * @beta */
export declare interface ToolLinkProps {
  children: React_2.ReactNode
  name: string
}

/**
 * @hidden
 * @beta */
export declare interface ToolMenuProps {
  activeToolName?: string
  closeSidebar: () => void
  context: 'sidebar' | 'topbar'
  isSidebarOpen: boolean
  tools: Tool[]
  renderDefault: (props: ToolMenuProps) => React_2.ReactElement
}

/** @internal */
export declare const TooltipOfDisabled: React_2.ForwardRefExoticComponent<
  TooltipProps & React_2.RefAttributes<HTMLDivElement>
>

/** @internal */
export declare interface TrackedArea {
  element: HTMLElement
}

/** @internal */
export declare interface TrackedChange {
  element: HTMLElement
  path: Path
  isChanged: boolean
  hasFocus: boolean
  hasHover: boolean
  hasRevertHover: boolean
  zIndex: number
}

/** @internal */
export declare const Tracker:
  | (({children}: {children: ReactNode}) => JSX_2.Element)
  | ((props: {children: ReactNode}) => JSX_2.Element)

/** @internal */
export declare interface TrackerContext<Value> {
  add: (id: string, value: Value) => void
  update: (id: string, value: Value) => void
  remove: (id: string) => void
  read: () => Reported<Value>[]
  subscribe: (subscriber: Subscriber<Reported<Value>[]>) => () => void
}

/**
 * @hidden
 * @beta */
export declare interface Transaction {
  index: number
  id: string
  author: string
  timestamp: string
  draftEffect?: MendozaEffectPair
  publishedEffect?: MendozaEffectPair
}

declare interface TransactionSyncLockState {
  enabled: boolean
}

/**
 * @hidden
 * @beta */
export declare const TransformPatches: React_2.NamedExoticComponent<
  {
    transform: PatchTransformer
  } & {
    children: React_2.ReactNode
  }
>

/**
 * This error may happen if the _type of the value is different from the declared schema type
 * It represents a case where we encounter field value that is structurally compatible with the field's defined schema type
 * (e.g. they are both json objects), but the _type name is different from what the schema type expects
 *
 * Note on compatibility: The schema of a field may be defined as an object with fields (a, b, c), but the value is an object with (d, e, f)
 * These are still structurally compatible because (d, e, f) will be considered undeclared members
 *
 * @public
 */
export declare type TypeAnnotationMismatchError = {
  type: 'TYPE_ANNOTATION_MISMATCH'
  expectedSchemaType: SchemaType
  resolvedValueType: string
}

/** @internal */
export declare type TypeChangeDiff = TypeChangeDiff_2<Annotation>

/**
 * @public
 */
export declare interface TypeTarget {
  type: string
}

/** @internal */
export declare const uncaughtErrorHandler: () => string

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
export declare type UndeclaredMembersError = {
  type: 'UNDECLARED_MEMBERS'
  schemaType: ArraySchemaType
}

/**
 * Universal array input that will introspect its schemaType and delegate to the right implementation
 * Useful as a fallback/last resort input for an array type
 *
 *
 * @hidden
 * @beta
 */
export declare function UniversalArrayInput(
  props: ArrayOfObjectsInputProps | ArrayOfPrimitivesInputProps,
): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare function unset(path?: Path): FormUnsetPatch

/**
 * @internal
 * @deprecated FOR INTERNAL USE.
 */
export declare function unstable_useValuePreview(props: {
  enabled?: boolean
  ordering?: SortOrdering
  schemaType?: SchemaType
  value: unknown | undefined
}): State_2

/**
 *
 * @hidden
 * @beta
 */
export declare type Uploader<S extends SchemaType = SchemaType> = {
  type: string
  accepts: string
  upload: (
    client: SanityClient,
    file: File,
    type: S,
    options?: UploadOptions,
  ) => Observable<UploadProgressEvent>
  priority: number
}

/**
 * @internal
 */
export declare type UploaderDef = {
  type: string
  accepts: string
  upload: (client: SanityClient, file: File, type: SchemaType) => Observable<UploadProgressEvent>
}

/**
 *
 * @hidden
 * @beta
 */
export declare type UploaderResolver<S extends SchemaType = SchemaType> = (
  type: S,
  file: FileLike,
) => Uploader<S> | null

/**
 * @hidden
 * @beta */
export declare interface UploadEvent {
  file: File
  schemaType: SchemaType
  uploader: Uploader
}

/**
 *
 * @hidden
 * @beta
 */
export declare type UploadOptions = {
  metadata?: AssetMetadataType[]
  storeOriginalFilename?: boolean
  label?: string
  title?: string
  description?: string
  creditLine?: string
  source?: AssetSourceSpec
}

/**
 *
 * @hidden
 * @beta
 */
export declare type UploadProgressEvent = {
  type: 'uploadProgress'
  patches: FormPatch[] | null
}

/**
 *
 * @hidden
 * @beta
 */
export declare interface UrlComponents {
  diff?: ComponentType<any>
  field?: ComponentType<StringFieldProps>
  input?: ComponentType<StringInputProps>
  item?: ComponentType<PrimitiveItemProps>
  preview?: ComponentType<PreviewProps>
}

/**
 *
 * @hidden
 * @beta
 */
export declare function UrlInput(props: UrlInputProps): React_2.JSX.Element

/**
 *
 * @hidden
 * @beta
 */
export declare type UrlInputProps = StringInputProps

/** @internal */
export declare function useActiveWorkspace(): ActiveWorkspaceMatcherContextValue

/** @internal */
export declare function useAnnotationColor(annotation?: Annotation | null): UserColor

/**
 * React hook that returns a configured Sanity client instance based on the given configuration.
 * Automatically uses the correct project and dataset based on the current active workspace.
 *
 * @public
 * @param clientOptions - Options for the client. Specifying
 *   {@link https://www.sanity.io/docs/api-versioning | apiVersion} is required in order to
 *   prevent breaking changes if studio changes the API version used in other places.
 *   See {@link SourceClientOptions}
 * @returns A configured Sanity client instance
 * @remarks The client instance is automatically memoized based on API version
 * @example Instantiating a client
 * ```ts
 * function MyComponent() {
 *   const client = useClient({apiVersion: '2021-06-07'})
 *   // ... do something with client instance ...
 * }
 * ```
 */
export declare function useClient(clientOptions?: SourceClientOptions): SanityClient

/**
 * @deprecated Use `useColorSchemeValue` or `useColorSchemeSetValue` instead
 * @internal
 */
export declare function useColorScheme(): {
  scheme: ThemeColorSchemeKey
  setScheme: false | ((nextScheme: StudioThemeColorSchemeKey) => void)
}

/** @internal */
export declare function _useColorSchemeInternalValue(): StudioThemeColorSchemeKey

/**
 * @internal
 */
export declare function useColorSchemeOptions(
  setScheme: (nextScheme: StudioThemeColorSchemeKey) => void,
): (
  | {
      title: string
      name: 'system'
      label: string
      selected: boolean
      onSelect: () => void
      icon: React_2.ForwardRefExoticComponent<
        Omit<React_2.SVGProps<SVGSVGElement>, 'ref'> & React_2.RefAttributes<SVGSVGElement>
      >
    }
  | {
      title: string
      name: 'dark'
      label: string
      selected: boolean
      onSelect: () => void
      icon: React_2.ForwardRefExoticComponent<
        Omit<React_2.SVGProps<SVGSVGElement>, 'ref'> & React_2.RefAttributes<SVGSVGElement>
      >
    }
  | {
      title: string
      name: 'light'
      label: string
      selected: boolean
      onSelect: () => void
      icon: React_2.ForwardRefExoticComponent<
        Omit<React_2.SVGProps<SVGSVGElement>, 'ref'> & React_2.RefAttributes<SVGSVGElement>
      >
    }
)[]

/** @alpha */
export declare function useColorSchemeSetValue():
  | false
  | ((nextScheme: StudioThemeColorSchemeKey) => void)

/** @alpha */
export declare function useColorSchemeValue(): ThemeColorSchemeKey

/**
 * Reduce a {@link Source} down to a {@link ConfigContext}, memoizing using `React.useMemo`
 *
 * @param source - Source to convert
 * @returns A config context containing only the defined properties of that interface
 * @internal
 */
export declare function useConfigContextFromSource(source: Source): ConfigContext

/** @internal */
export declare function useConnectionState(
  publishedDocId: string,
  docTypeName: string,
): ConnectionState

/** @internal */
export declare function useConnectionStatusStore(): ConnectionStatusStore

/**
 * Retrieves information about the currently authenticated user.
 *
 * @returns The current user or null if not available.
 *
 * @public
 *
 * @example
 * ```ts
 * const currentUser = useCurrentUser()
 *
 * if (currentUser) {
 *  console.log('Logged in as', currentUser.name)
 * }
 * ```
 */
export declare function useCurrentUser(): CurrentUser | null

/**
 * React hook that returns the name of the current dataset
 *
 * @public
 * @returns The name of the current dataset
 * @example Using the `useDataset` hook
 * ```ts
 * function MyComponent() {
 *   const dataset = useDataset()
 *   // ... do something with the dataset name ...
 * }
 * ```
 */
export declare function useDataset(): string

/**
 * A hook for doing side effects as a response to a change in a hook value between renders
 *
 * @example
 * ```ts
 * useDidUpdate(hasFocus, (hadFocus, hasFocus) => {
 *  if (hasFocus) {
 *    scrollIntoView(elementRef.current)
 *   }
 * })
 * ```
 *
 * @beta
 * @hidden
 */
export declare function useDidUpdate<T>(
  /** The value you want to respond to changes in. */
  current: T,
  /** Callback to run when the value changes. */
  didUpdate: (previous: T | undefined, current: T) => void,
  compare?: (previous: T | undefined, current: T) => boolean,
): void

/** @internal */
export declare function useDiffAnnotationColor(diff: Diff, path?: string | Path): UserColor

/** @internal */
export declare function useDocumentChange(): DocumentChangeContextInstance

/** @internal */
export declare function useDocumentOperation(
  publishedDocId: string,
  docTypeName: string,
): OperationsAPI

/** @internal */
export declare function useDocumentOperationEvent(
  publishedDocId: string,
  docTypeName: string,
): OperationSuccess | OperationError | undefined

/** @internal */
export declare function useDocumentPairPermissions({
  id,
  type,
  permission,
  client: overrideClient,
  schema: overrideSchema,
  grantsStore: overrideGrantsStore,
}: PartialExcept<DocumentPairPermissionsOptions, 'id' | 'type' | 'permission'>): ReturnType<
  typeof useDocumentPairPermissionsFromHookFactory
>

/**
 * Gets document pair permissions based on a document ID and a type.
 *
 * This permissions API is a high-level permissions API that is draft-model
 * aware. In order to determine whether or not the user has the given
 * permission, both the draft and published documents are pulled and run through
 * all of the user's grants. If any pre or post conditions fail a permissions
 * checks, the operations will not be granted.
 *
 * The operations this hook accepts are only relevant to document pairs. E.g.
 * `'create'` is not included as an operation because it's not possible to tell
 * if a document can be created by only using the initial ID and type because an
 * initial template value may not have a matching grant (e.g. locked-document
 * pattern `!locked`). In contrast, the operation `'duplicate'` is supported
 * because the draft value of the document can be live queried and checked for
 * matching grants.
 *
 * Note: for live-edit documents, non-applicable operations (e.g. publish) will
 * return as true.
 *
 * @see useDocumentValuePermissions
 *
 * @internal
 */
export declare const useDocumentPairPermissionsFromHookFactory: ReactHook<
  DocumentPairPermissionsOptions,
  LoadingTuple<PermissionCheckResult | undefined>
>

/** @internal */
export declare function useDocumentPresence(documentId: string): DocumentPresence[]

/**
 * @hidden
 * @beta */
export declare function useDocumentPreviewStore(): DocumentPreviewStore

/**
 * @hidden
 * @beta */
export declare function useDocumentStore(): DocumentStore

/** @internal */
export declare function useDocumentType(
  documentId: string,
  specifiedType?: string,
): DocumentTypeResolveState

/** @internal */
export declare function useDocumentValuePermissions({
  document,
  permission,
  ...rest
}: PartialExcept<DocumentValuePermissionsOptions, 'permission' | 'document'>): ReturnType<
  typeof useDocumentValuePermissionsFromHookFactory
>

/**
 * Gets permissions based on the value of the document passed into the hook
 * (stateless).
 *
 * Note: this is a lower-level API (compared to `useDocumentPairPermissions`)
 * that is _not_ draft-model aware.
 *
 * As a consequence, the operations it accepts are also low-level. (e.g.
 * `'publish'` permissions can't be determined with this API). This is because
 * it's not possible to tell if a user can do high-level document pair
 * operations on document using only one document value.
 *
 * For example, in order to determine if a user can publish, the current value
 * of the published document needs to be pulled and checked against the user's
 * grants. If there are no matching grants, then it fails the pre-condition and
 * no operation is allowed regardless of the given document.
 *
 * @see useDocumentPairPermissions
 *
 * @internal
 */
export declare const useDocumentValuePermissionsFromHookFactory: ReactHook<
  DocumentValuePermissionsOptions,
  LoadingTuple<PermissionCheckResult | undefined>
>

/** @internal */
export declare function useDocumentValues<T = Record<string, unknown>>(
  documentId: string,
  paths: string[],
): LoadableState<T | undefined>

/** @internal */
export declare function useEditState(
  publishedDocId: string,
  docTypeName: string,
  priority?: 'default' | 'low',
): EditStateFor

/** @internal */
export declare function useFeatureEnabled(featureKey: string): Features

/** @internal */
export declare function useFieldActions(): FieldActionsContextValue

/**
 *
 * @hidden
 * @beta
 */
export declare function useFormBuilder(): FormBuilderContextValue

/** @internal */
export declare function useFormCallbacks(): FormCallbacksValue

/** @internal */
export declare function useFormState<
  T extends {
    [key in string]: unknown
  } = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType,
>(
  schemaType: ObjectSchemaType,
  {
    comparisonValue,
    value,
    fieldGroupState,
    collapsedFieldSets,
    collapsedPaths,
    focusPath,
    openPath,
    presence,
    validation,
    readOnly,
    changesOpen,
  }: {
    fieldGroupState?: StateTree<string> | undefined
    collapsedFieldSets?: StateTree<boolean> | undefined
    collapsedPaths?: StateTree<boolean> | undefined
    value: Partial<FIXME_SanityDocument>
    comparisonValue: Partial<FIXME_SanityDocument> | null
    openPath: Path
    focusPath: Path
    presence: FormNodePresence[]
    validation: ValidationMarker[]
    changesOpen?: boolean
    readOnly?: boolean
  },
): FormState<T, S> | null

/**
 * React hook that returns the value of the field specified by a path.
 * @public
 *
 * @param path - An array notation with segments that are either strings representing field names, index integers for arrays with simple values, or objects with a _key for arrays containing objects
 *
 * @returns The value of the field specified by the path
 *
 * @example Using the `useFormValue` hook
 * ```ts
 * function MyComponent() {
 *    // get value of field 'name' in object 'author'
 *    const authorName = useFormValue(['author', 'name'])
 *    // get value of the second item in array 'tags' of type 'string'
 *    const secondTag = useFormValue(['tags', 1])
 *    // get value of the reference with the matching key in an array of references
 *    const specificBook = useFormValue([ 'bibliography', {_key: '<key>'} ])
 *   // ... do something with the form values ...
 * }
 * ```
 */
export declare function useFormValue(path: Path): unknown

/** @internal */
export declare function useGlobalPresence(): GlobalPresence[]

/**
 * @hidden
 * @beta */
export declare function useGrantsStore(): GrantsStore

/**
 * @hidden
 * @beta */
export declare function useHistoryStore(): HistoryStore

/** @internal */
export declare function useHoveredField(): HoveredFieldContextValue

/**
 * @internal
 */
export declare function useInitialValue(props: {
  documentId: string
  documentType: string
  templateName?: string
  templateParams?: Record<string, unknown>
}): InitialValueState

/**
 * @internal
 */
export declare function useInitialValueResolverContext(): InitialValueResolverContext

/** @internal */
export declare function useLoadable<T>(value$: Observable<T>): LoadableState<T | undefined>

/** @internal */
export declare function useLoadable<T>(value$: Observable<T>, initialValue: T): LoadableState<T>

/** @internal */
export declare function useMiddlewareComponents<T extends {}>(props: {
  pick: (plugin: PluginOptions) => ComponentType<T>
  defaultComponent: ComponentType<T>
}): ComponentType<T>

/** @internal */
export declare function useOnScroll(callback: Subscriber<Event>): void

/**
 * @hidden
 * @beta */
export declare function usePresenceStore(): PresenceStore

/** @internal */
export declare function usePreviewCard(): PreviewCardContextValue

/** @internal */
export declare function useProject(): {
  value: ProjectData | null
}

/** @internal */
export declare function useProjectDatasets(): {
  value: ProjectDatasetData[] | null
}

/**
 * React hook that returns the current project id
 *
 * @public
 * @returns The current project id
 * @example Using the `useProjectId` hook
 * ```ts
 * function MyComponent() {
 *   const projectId = useProjectId()
 *   // ... do something with the project id ...
 * }
 * ```
 */
export declare function useProjectId(): string

/**
 * @hidden
 * @beta */
export declare function useProjectStore(): ProjectStore

/**
 * @hidden
 * @beta */
export declare function UserAvatar(props: UserAvatarProps): React_2.JSX.Element

/**
 * @hidden
 * @beta */
export declare interface UserAvatarProps {
  animateArrowFrom?: AvatarPosition
  position?: AvatarPosition
  size?: AvatarSize
  status?: AvatarStatus
  tone?: 'navbar'
  user: User | string
  withTooltip?: boolean
}

/** @internal */
export declare interface UserColor {
  name: ColorHueKey
  background: HexColor
  border: HexColor
  text: HexColor
  tints: ColorTints
}

/** @internal */
export declare type UserColorHue = string

/** @internal */
export declare interface UserColorManager {
  get: (userId: UserId | null) => UserColor
  listen: (userId: UserId) => Observable<UserColor>
}

/** @internal */
export declare interface UserColorManagerOptions {
  anonymousColor?: UserColor
  userStore?: {
    me: Observable<{
      id: string
    } | null>
  }
  colors?: Record<UserColorHue, UserColor>
  currentUserColor?: UserColorHue
  scheme: ThemeColorSchemeKey
}

/** @internal */
export declare function UserColorManagerProvider({
  children,
  manager: managerFromProps,
}: UserColorManagerProviderProps): React_2.ReactElement

/** @internal */
export declare interface UserColorManagerProviderProps {
  children: React_2.ReactNode
  manager?: UserColorManager
}

/**
 * @internal
 */
export declare function useReferenceInputOptions(): ReferenceInputOptions

/** @internal */
export declare const useReportedValues:
  | (() => Reported<TrackedChange | TrackedArea>[])
  | (() => Reported<TrackedChange | TrackedArea>[])

/** @internal */
export declare const useReporter:
  | ((
      id: string | null,
      value: TrackedChange | TrackedArea | (() => TrackedChange | TrackedArea),
    ) => void)
  | ReporterHook<TrackedChange | TrackedArea>

/** @internal */
export declare function useResolveInitialValueForType<Params extends Record<string, unknown>>(): (
  /**
   * This is the name of the document.
   */
  type: SchemaType,
  /**
   * Params is a sanity context object passed to every initial value function.
   */
  params: Params,
) => Promise<any>

/** @internal */
export declare function useResourceCache(): ResourceCache

/**
 * @internal
 */
export declare function useReviewChanges(): ReviewChangesContextValue

/**
 * Checks whether or not the given user has the role with the given ID
 *
 * @param user - The user to check (currently only the current user is supported)
 *   If `null` is passed, this function always returns `false`.
 * @param roleId - The ID of the role to check for
 *
 * @returns true if the user has the role, false otherwise
 *
 * @example
 * Fetch the current user and check if they have the role "administrator":
 * ```ts
 * import {userHasRole, useCurrentUser} from 'sanity'
 *
 * export function MyComponent() {
 *   const user = useCurrentUser()
 *   const hasAdminRole = userHasRole(user, 'administrator')
 *   return <div>Is administrator: {hasAdminRole ? 'Yes' : 'No'}</div>
 * }
 * ```
 * @public
 */
export declare function userHasRole(
  user:
    | (Omit<CurrentUser, 'role'> & {
        role?: string
      })
    | null,
  roleId: string,
): boolean

/** @internal */
export declare type UserId = string

/**
 * This hook handles focus with the keyboard arrows.
 *
 * @see {@link https://a11y-solutions.stevenwoodson.com/solutions/focus/roving-focus/ | Roving focus definition}
 *
 * @example
 * ```tsx
 * function MyComponent() {
 *   const [rootElement, setRootElement] = setRootElement(null)
 *
 *   useRovingFocus({
 *     rootElement: rootElement,
 *   })
 *
 *   return (
 *     <div ref={setRootElement}>
 *       <button>Button</button>
 *       <button>Button</button>
 *       <button>Button</button>
 *     </div>
 *   )
 * }
 * ```
 *
 *
 * @hidden
 * @beta
 */
export declare function useRovingFocus(props: RovingFocusProps): undefined

/** @internal */
export declare interface UserSessionPair {
  user: User
  session: Session
}

/**
 * @hidden
 * @beta */
export declare interface UserStore {
  getUser(userId: string): Promise<User | null>
  getUsers(userIds: string[]): Promise<User[]>
}

/** @internal */
export declare interface UserStoreOptions {
  client: SanityClient
  currentUser: CurrentUser | null
}

/**
 * React hook that returns the schema registry for the current project
 *
 * @public
 * @returns The schema registry for the current project
 * @example Using the `useSchema` hook
 * ```ts
 * function MyComponent() {
 *   const schema = useSchema()
 *   // ... do something with the schema ...
 * }
 * ```
 */
export declare function useSchema(): Schema

/** @internal */
export declare function useSettingsStore(): SettingsStore

/**
 * @internal
 * @deprecated INTERNAL USE ONLY
 */
export declare function useSource(): Source

/** @internal */
export declare function useSyncState(publishedDocId: string, documentType: string): SyncState

/** @internal */
export declare function useTemplatePermissions({
  templateItems,
  ...rest
}: PartialExcept<TemplatePermissionsOptions, 'templateItems'>): ReturnType<
  typeof useTemplatePermissionsFromHookFactory
>

/**
 * Takes in an array of initial template values and returns an object of
 * `TemplatePermissionsResult` keyed by the IDs of the initial template values
 * given.
 *
 * The `TemplatePermissionsResult` is an object that contains a `granted`
 * boolean per key and can be used to determine if a user has the ability to
 * create documents using the given initial value template items.
 *
 * For each initial template value item, the corresponding template is found and
 * resolved against the parameters in each the initial template value item. The
 * resolved value is then run through the document-value permissions. If there
 * are any matching grants for the resolved initial template value, the
 * `TemplatePermissionsResult` will include `granted: true`.
 *
 * @internal
 */
export declare const useTemplatePermissionsFromHookFactory: ReactHook<
  TemplatePermissionsOptions,
  LoadingTuple<TemplatePermissionsResult<Record<string, unknown>>[] | undefined>
>

/**
 *
 * @hidden
 * @beta
 */
export declare function useTemplates(): Template[]

/**
 * @internal
 *
 * @example
 * ```tsx
 * // First create a callback using React’s `useCallback` hook
 * const myCallback = useCallback(() => {
 *   // this is not throttled
 * }, [])
 *
 * // Then make a throttled version using the `useThrottledCallback` hook
 * const myThrottledCallback = useThrottledCallback(myCallback, 100)
 *
 * // Call the throttled callback
 * <Button onClick={myThrottledCallback} />
 * ```
 */
export declare function useThrottledCallback(
  callback: (...args: any[]) => any,
  wait: number,
  options: ThrottleSettings,
): (...args: any[]) => any

/** @internal */
export declare function useTimeAgo(time: Date | string, {minimal, agoSuffix}?: TimeAgoOpts): string

declare interface UseTimelineControllerOpts {
  documentId: string
  documentType: string
  onError?: (err: Error) => void
  rev?: string
  since?: string
}

/**
 * Custom hook which wraps around `useSyncExternalStore`.
 * Accepts a selector function which can be used to opt-in to specific timelineStore updates.
 *
 * @internal
 */
export declare function useTimelineSelector<ReturnValue>(
  timelineStore: TimelineStore,
  selector: (timelineState: TimelineState) => ReturnValue,
): ReturnValue

/**
 * Creates a store which handles the creation of a document Timeline,
 * TimelineController and also fetches pre-requisite document snapshots.
 *
 * `TimelineStore` exposes select TimelineController methods used to query
 * ranges and fetch more transactions. It can also be used with
 * `useSyncExternalStore` to subscribe to selected state changes.
 *
 * @internal
 * */
export declare function useTimelineStore({
  documentId,
  documentType,
  onError,
  rev,
  since,
}: UseTimelineControllerOpts): TimelineStore

/**
 *
 * @hidden
 * @beta
 */
export declare function useTools(): Tool[]

/**
 * This React hook should be considered an escape hatch – to make sure that a value is the same
 * on every render. SHOULD NOT BE USED IN MOST CASES.
 * @deprecated please use `useMemo` and `useCallback` strategies instead to make deps stable, this hook runs comparisons on every single render and while each comparison can be fast, it quickly adds up
 *
 * @internal
 */
export declare function useUnique<ValueType>(value: ValueType): ValueType

/** @internal */
export declare function useUser(userId: string): LoadingTuple<User | null | undefined>

/** @internal */
export declare function useUserColor(userId: string | null): UserColor

/** @internal */
export declare function useUserColorManager(): UserColorManager

/**
 * @hidden
 * @beta */
export declare function useUserStore(): UserStore

/** @internal */
export declare function useValidationStatus(
  publishedDocId: string,
  docTypeName: string,
): ValidationStatus

/**
 * @internal
 */
export declare function useVirtualizerScrollInstance(): VirtualizerScrollInstance

/**
 * @hidden
 * @beta */
export declare function useWorkspace(): Workspace

/** @internal */
export declare function useWorkspaces(): WorkspaceSummary[]

/**
 * TODO: Rename to `useZOffsets`
 *
 * @internal
 */
export declare function useZIndex(): ZIndexContextValue

/**
 * Validates the base paths of every workspace
 * Only exported for testing purposes
 *
 * @param workspaces - An array of workspaces
 * @internal
 */
export declare function validateBasePaths(workspaces: WorkspaceLike[]): void

/**
 * Validates the workspace names of every workspace
 * Only exported for testing purposes
 *
 * @param workspaces - An array of workspaces
 * @internal
 */
export declare function validateNames(workspaces: WorkspaceLike[]): void

/** @internal */
export declare interface ValidateWorkspaceOptions {
  workspaces: WorkspaceLike[]
}

/**
 * Validates workspace configuration, throwing if:
 *
 * - Workspaces do not all have base paths and names (if multiple given)
 * - Base paths or names are invalid
 * - Base paths or names are not unique
 *
 * @internal
 */
export declare function validateWorkspaces({workspaces}: ValidateWorkspaceOptions): void

/** @internal */
export declare const validation: (
  arg1: {
    client: SanityClient
    getClient: (options: SourceClientOptions) => SanityClient
    observeDocumentPairAvailability: ObserveDocumentPairAvailability
    schema: Schema
  },
  arg2: IdPair,
  arg3: string,
) => Observable<ValidationStatus>

/**
 * @hidden
 * @beta */
export declare interface ValidationStatus {
  isValidating: boolean
  validation: ValidationMarker[]
  revision?: string
}

/** @internal */
export declare function ValueError({error}: {error: FieldValueError}): React_2.JSX.Element

/**
 * @alpha
 */
export declare interface ValuelessSearchOperatorBuilder<TType extends string>
  extends SearchOperatorBase {
  buttonValueComponent?: never
  groqFilter: (params: ValuelessSearchOperatorParams) => string | null
  initialValue?: never
  inputComponent?: never
  type: TType
}

/**
 * @alpha
 */
export declare type ValuelessSearchOperatorParams = {
  fieldPath?: string
}

/**
 * @internal
 */
export declare interface VirtualizerScrollInstance {
  /**
   * The parent that has the overflow scroll
   */
  scrollElement: HTMLElement | null
  /**
   * The container that wraps the array items
   */
  containerElement: MutableRefObject<HTMLElement | null>
}

/**
 * This is used to store the reference to the scroll element for virtualizer
 * @internal
 */
export declare const VirtualizerScrollInstanceContext: Context<VirtualizerScrollInstance | null>

/**
 *
 * @internal
 */
export declare function VirtualizerScrollInstanceProvider(
  props: VirtualizerScrollInstanceProviderProps,
): React_2.JSX.Element

/**
 * @internal
 */
declare interface VirtualizerScrollInstanceProviderProps extends VirtualizerScrollInstance {
  children: React_2.ReactNode
}

/**
 * Visit all diffs in tree, until visitor returns false
 *
 * @param diff - Diff to visit
 * @param visitor - Visitor function, return false to stop from going deeper
 *
 * @internal
 */
export declare function visitDiff(
  diff: Diff | StringDiffSegment,
  visitor: DiffVisitor,
  path?: Path,
): void

/**
 * @internal
 */
export declare interface WeightedSearchOptions {
  filter?: string
  params?: Record<string, unknown>
  tag?: string
  unique?: boolean
}

/** @internal */
export declare interface WelcomeEvent {
  type: 'welcome'
}

/**
 * @internal
 * @deprecated - Will be removed in 4.0.0, use the `useReferringDocuments(<documentId>)` hook instead
 */
export declare function WithReferringDocuments({
  children,
  id,
}: {
  children: (props: {isLoading: boolean; referringDocuments: SanityDocument[]}) => ReactElement
  /**
   * @deprecated - no longer required
   */
  documentStore?: DocumentStore
  id: string
}): ReactElement<any, string | JSXElementConstructor<any>>

/**
 * @hidden
 * @beta */
export declare type WithVersion<T> = T & {
  version: 'published' | 'draft'
}

/**
 * Definition for Workspace
 *
 * @public
 */
export declare interface Workspace extends Omit<Source, 'type'> {
  type: 'workspace'
  /**
   * URL base path to use, for instance `/myWorkspace`
   * Note that this will be prepended with any _studio_ base path, eg `/studio/myWorkspace`,
   * and is a client-side routing feature. If you're looking to serve your studio from a subpath,
   * you're probably looking for the `basePath` property in `sanity.cli.ts`/`sanity.cli.js`.
   */
  basePath: string
  /** Subtitle to show under the name of the workspace */
  subtitle?: string
  /** React component to use as icon for this workspace */
  icon: ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  unstable_sources: Source[]
}

/** @internal */
export declare interface WorkspaceLike {
  name?: string
  title?: string
  basePath?: string
}

/**
 * @hidden
 * @beta
 */
export declare interface WorkspaceOptions extends SourceOptions {
  basePath: string
  subtitle?: string
  logo?: ComponentType
  icon?: ComponentType
  /**
   * @hidden
   * @beta
   */
  theme?: StudioTheme
  /**
   * @hidden
   * @beta
   */
  unstable_sources?: SourceOptions[]
}

/** @internal */
export declare function WorkspaceProvider({
  children,
  workspace,
}: WorkspaceProviderProps): React_2.JSX.Element

/** @internal */
export declare interface WorkspaceProviderProps {
  workspace: Workspace
  children?: React_2.ReactChild
}

/** @internal */
export declare const WorkspacesContext: Context<WorkspacesContextValue | null>

/** @internal */
export declare type WorkspacesContextValue = WorkspaceSummary[]

/** @internal */
export declare function WorkspacesProvider({
  config,
  children,
  basePath,
}: WorkspacesProviderProps): React_2.JSX.Element

/** @internal */
export declare interface WorkspacesProviderProps {
  config: Config
  children: React_2.ReactNode
  basePath?: string
}

/** @internal */
export declare interface WorkspaceSummary {
  type: 'workspace-summary'
  name: string
  title: string
  icon: ReactNode
  subtitle?: string
  basePath: string
  auth: AuthStore
  projectId: string
  dataset: string
  theme: StudioTheme
  schema: Schema
  /**
   * @internal
   * @deprecated not actually deprecated but don't use or you'll be fired
   */
  __internal: {
    sources: Array<{
      name: string
      projectId: string
      dataset: string
      title: string
      auth: AuthStore
      schema: Schema
      source: Observable<Source>
    }>
  }
}

/**
 * TODO: Rename to `ZOffsetsContextValue`
 *
 * @internal
 */
export declare interface ZIndexContextValue {
  /** Used by: Navbar */
  navbar: number | number[]
  navbarPopover: number | number[]
  navbarDialog: number | number[]
  /** Used by: DefaultPane, DocumentPane */
  pane: number | number[]
  paneHeader: number | number[]
  paneFooter: number | number[]
  paneResizer: number | number[]
  /** Used by: EditItemFoldOut, Spinner, ConnectorsOverlay, tippy.css, BaseDateTimeInput */
  portal: number | number[]
  /** Used by: Tooltip */
  popover: number | number[]
  /** Used by: `@sanity/google-maps-input` */
  modal: number | number[]
  /** TODO this path does not seem to be correct - fix?  */
  /** Used by: `movingItem` in packages/sanity/src/styles/layout/helpers.css */
  movingItem: number | number[]
  /** Used for shadow behind the navbar search, and behind sidemenu */
  drawershade: number | number[]
  /** Used by: Snackbar */
  drawer: number | number[]
  /** Used for UI that sits on top of the entire application */
  fullscreen: number | number[]
  /** Used for toasts */
  toast: number | number[]
  dropdown: number | number[]
  navbarFixed: number | number[]
  fullscreenEdit: number | number[]
  popoverBackground: number | number[]
  tooltip: number | number[]
  modalBackground: number | number[]
  spinner: number | number[]
}

/** @internal */
export declare type ZIndexContextValueKey = keyof ZIndexContextValue

/**
 * TODO: Rename to `ZOffsetsProvider`
 *
 * @internal
 */
export declare function ZIndexProvider({
  children,
}: {
  children?: React_2.ReactNode
}): React_2.ReactElement

export * from '@sanity/types'

export {}

declare module '@sanity/types' {
  interface ArrayDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ArrayOfObjectsComponents | ArrayOfPrimitivesComponents
  }
  interface BlockDefinition {
    /**
     * Components for the block schema type
     *
     * @public
     * @remarks - This only applies to the block text type, and not block object types (like images).
     * - Don't render arbitrary text nodes inside regular text blocks, as this will confuse the editor with
     * what is editable text and not. Make sure to wrap all nodes which are NOT part of the edited text inside a
     * container with `contentEditable={false}` and with `style={{userSelection: 'none'}}` so that
     * the editor can distinguish between editable text and non-editable text.
     * @example Example of custom block component with delete button next to it that removes the block.
     * ```ts
     * {
     *   block: (blockProps) => {
     *     return (
     *       <Flex>
     *         <Box flex={1}>{blockProps.renderDefault(blockProps)}</Box>
     *         <Box contentEditable={false} style={{userSelect: 'none'}}>
     *           <Button
     *             icon={TrashIcon}
     *             onClick={(event) => {
     *               event.preventDefault()
     *               blockProps.onRemove()
     *              }}
     *             />
     *         </Box>
     *       </Flex>
     *     )
     *   },
     * },
     * ```
     */
    components?: {
      block?: ComponentType<BlockProps>
    }
  }
  interface BlockDecoratorDefinition {
    /**
     * Component for rendering a decorator.
     *
     * See also {@link BlockDecoratorProps | BlockDecoratorProps}
     *
     * @public
     * @remarks - Try not to hard code CSS properties that could be derived from `@sanity/ui`.
     * This will make sure your rendering looks good independent of the theme context it appears in.
     * - Don't render arbitrary text nodes as this will confuse the editor with
     * what is editable text and not. If you need arbitrary text, make sure to wrap them in in a
     * container with `contentEditable={false}`.
     * @example Example of rendering custom decorator that highlights text.
     * ```ts
     * const Highlight = (props: BlockDecoratorProps) => (
     *   <span style={{backgroundColor: '#ff0'}}>
     *     {props.children}
     *   </span>
     * )
     * ```
     */
    component?: ComponentType<BlockDecoratorProps>
  }
  interface BlockStyleDefinition {
    /**
     * Component for rendering a text style.
     *
     * See also {@link BlockStyleProps | BlockStyleProps}
     *
     * @public
     * @remarks - Try not to hard code CSS properties that could be derived from `@sanity/ui`.
     * This will make sure your rendering looks good independent of the theme context it appears in.
     * - Don't render arbitrary text nodes as this will confuse the editor with
     * what is editable text and not. If you need arbitrary text, make sure to wrap them in in a
     * container with `contentEditable={false}`.
     * @example Example of rendering a custom style for article leads which is bigger,
     * and bolder, but will adapt to what the current `@sanity/ui` theme has defined
     * as actual values for weight "bold" and `size={3}`.
     * ```ts
     * import {Text} from '@sanity/ui'
     *
     * const LeadStyle = (props: BlockStyleProps) => (
     *   <Text weight="bold" size={3}>
     *     {props.children}
     *   </Text>
     * )
     * ```
     */
    component?: ComponentType<BlockStyleProps>
  }
  interface BlockListDefinition {
    /**
     * Component for rendering a block as a list item
     *
     * See also {@link BlockListItemProps | BlockListItemProps}
     *
     * @public
     * @remarks - Try not to hard code CSS properties that could be derived from `@sanity/ui`.
     * This will make sure your rendering looks good independent of the theme context it appears in.
     * - Don't render arbitrary text nodes as this will confuse the editor with
     * what is editable text and not. If you need arbitrary text, make sure to wrap them in in a
     * container with `contentEditable={false}`.
     */
    component?: ComponentType<BlockListItemProps>
  }
  interface BlockAnnotationDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: {
      annotation?: ComponentType<BlockAnnotationProps>
    }
  }
  interface BooleanDefinition {
    components?: BooleanComponents
  }
  interface DateDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: DateComponents
  }
  interface DatetimeDefinition {
    components?: DatetimeComponents
  }
  interface DocumentDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: DocumentComponents
  }
  interface FileDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: FileComponents
  }
  interface GeopointDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: GeopointComponents
  }
  interface ImageDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ImageComponents
  }
  interface NumberDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: NumberComponents
  }
  interface ObjectDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ObjectComponents
  }
  interface ReferenceDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ReferenceComponents
  }
  interface CrossDatasetReferenceDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: CrossDatasetReferenceComponents
  }
  interface SlugDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: SlugComponents
  }
  interface SpanDefinition {
    components?: SpanComponents
  }
  interface StringDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: StringComponents
  }
  interface TextDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: TextComponents
  }
  interface UrlDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: UrlComponents
  }
  interface EmailDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: EmailComponents
  }
}
//# sourceMappingURL=definitionExtensions.d.ts.map
